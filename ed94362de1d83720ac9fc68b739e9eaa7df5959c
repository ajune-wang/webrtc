{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ad22ffe3_1f43d16f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2023-06-01T10:05:58Z",
      "side": 1,
      "message": "Using SafeTask() didn\u0027t work for guarding against deallocation of container in this case, since the container is living on the signaling thread and the invokes go to the network thread.",
      "revId": "ed94362de1d83720ac9fc68b739e9eaa7df5959c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1039771_613fe401",
        "filename": "pc/transceiver_list.cc",
        "patchSetId": 1
      },
      "lineNbr": 58,
      "author": {
        "id": 5508
      },
      "writtenOn": "2023-06-01T10:30:32Z",
      "side": 1,
      "message": "as an alternative approach to PostTask, would it make sense to update the code in `RtpTransceiver` to update `transceivers_n_` whenever `channel_-\u003eSetRtpTransport(...)` is called?\n\nBesides avoiding PostTask here, that would make the state on the network thread be guaranteed to be up to date (since we won\u0027t know when the posted task will actually run in relation to the SetRtpTransport() call).",
      "revId": "ed94362de1d83720ac9fc68b739e9eaa7df5959c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}