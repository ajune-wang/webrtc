{
  "comments": [
    {
      "key": {
        "uuid": "96942ee0_c6378dbb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-10-06T09:03:45Z",
      "side": 1,
      "message": "PTAL. The android failure is a DCHECK\n\n10-06 08:04:18.157  5572  5672 E rtc     : #\n10-06 08:04:18.157  5572  5672 E rtc     : # Fatal error in: ../../modules/video_coding/codecs/vp8/libvpx_vp8_encoder.cc, line 958\n10-06 08:04:18.157  5572  5672 E rtc     : # last system error: 11\n10-06 08:04:18.157  5572  5672 E rtc     : # Check failed: frame.width() \u003d\u003d codec_.width (320 vs. 160)\n10-06 08:04:18.157  5572  5672 E rtc     : # \n\nI think the reason is that when the ToI420 call is postponed, and no longer done in VideoStreamEncoder the crop-and-scale logic in VideoStreamEncoder stops working, see https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/video/video_stream_encoder.cc;drc\u003d895556e19c081ba9a5f0e015f0fe95745d677b55;l\u003d1343.\n\nThis may work better after https://webrtc-review.googlesource.com/c/src/+/186303 is landed and properly integrated with android jni code.",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "36db0950_ee286f9d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-10-06T09:08:31Z",
      "side": 1,
      "message": "This would break scaling logic.\n\nE.g. here:\nhttps://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/video/video_stream_encoder.cc;l\u003d1343;drc\u003d895556e19c081ba9a5f0e015f0fe95745d677b55\n\nThe frame is already converted to I420, because SW encoders don\u0027t support native.\n\nThe same happens in SimulcastEncoderAdater:\nhttps://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/media/engine/simulcast_encoder_adapter.cc;l\u003d425;drc\u003dc5a74ffba49e90a9382c9eb6a795fe7d6abd74a1\n\nTo make this work you need to also copy all scaling logic in to each individual encoder.",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9d144382_11536735",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-10-06T09:32:15Z",
      "side": 1,
      "message": "I wouldn\u0027t want scaling logic in encoders, but I was hoping that your cl (linke din previous comment) to add VideoFramebuffer::CropAndScale would let us keep the logic in VideoStreamEncoder, but make it work fine also with kNative.",
      "parentUuid": "36db0950_ee286f9d",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "010cf70a_56cf9fa2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 8683
      },
      "writtenOn": "2020-10-06T09:52:17Z",
      "side": 1,
      "message": "Native frames could implement this in theory I think, returning their underlying data type scaled.",
      "parentUuid": "9d144382_11536735",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "588ecf0f_eaf08b3b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-10-06T10:02:36Z",
      "side": 1,
      "message": "Yes, but that can only work if all clients (chrome, android apps) implement it, otherwise the code path would be inefficient, as they will convert to memory I420 meanwhile. Or we have CropAndScale which can sometimes return nullptr\n\nAll in all, \"supports kNative\" should mean \"Pass the frame without touching it at all\". Therefore all the encoders would have to handle scaling/converting themselves.",
      "parentUuid": "010cf70a_56cf9fa2",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "481b712e_8b05287c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-10-06T11:08:45Z",
      "side": 1,
      "message": "I\u0027m not really familiar with current android code (that\u0027s why I added Sami as reviewer), but I\u0027m fairly sure we\u0027ve had code implementing scaling of texture frames by just tweaking a transformation matrix.\n\nAs for having encoders handle scaling/conversion, they can already handle conversion (via ToI420, and we\u0027re discussing generalizing it for other pixel formats supported directly by the encoder). If required, I wouldn\u0027t oppose forcing them to also handle crop and scale, provided we make sure utilities are in place to make it easy without lots of code duplication. But keeping it out of encoders is better, if we can do it without a performance penalty.\n\nThe current code path broken by this cl seems somewhat inefficient. If I understand it correctly, it will convert texture frames to I420, possibly crop to discard som of the I420 pixels, and then scale in main memory using libyuv. The scaled frames are then passed to the VP8 software encoder. Is thet right? It would be more efficient to \"crop and scale\" the texture frame by tweaking the transformation matrix, and have actual scaling done on the GPU as part of ToI420.",
      "parentUuid": "588ecf0f_eaf08b3b",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}