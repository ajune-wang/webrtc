{
  "comments": [
    {
      "key": {
        "uuid": "d98dbf7b_3c76f9d8",
        "filename": "rtc_base/repeating_task.cc",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "Shouldn\u0027t line 37 be run regardless of interval mode?",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e77ad1d8_ad621536",
        "filename": "rtc_base/repeating_task.cc",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "In excluding mode it\u0027s only used for stopping state. But semantically it makes some sense to keep updating it, so I moved it out.",
      "parentUuid": "d98dbf7b_3c76f9d8",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "944b1e73_add8e0f8",
        "filename": "rtc_base/repeating_task.cc",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "I don\u0027t think you need this comment---the one on line 46 is sufficient.",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2b0d9dc_8a696163",
        "filename": "rtc_base/repeating_task.cc",
        "patchSetId": 4
      },
      "lineNbr": 40,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "944b1e73_add8e0f8",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d559c343_0526f66b",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "Document that this is always finite, except for the special case where it\u0027s +inf to signal that the task should stop.",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "360d1fea_d117a598",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 56,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d559c343_0526f66b",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "affe69be_a6145a6c",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 84,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "themselves",
      "range": {
        "startLine": 84,
        "startChar": 37,
        "endLine": 84,
        "endChar": 46
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa204f5a_633f8ae2",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 84,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "affe69be_a6145a6c",
      "range": {
        "startLine": 84,
        "startChar": 37,
        "endLine": 84,
        "endChar": 46
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "71b4f305_16b35c07",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 86,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "\"you must stop one task before starting another\"\n\nHmm. Do you actually need the ability to re-use the handle for another task? The state diagram would be much simpler without it, and simplicity is a great asset in this sort of code.",
      "range": {
        "startLine": 86,
        "startChar": 32,
        "endLine": 86,
        "endChar": 69
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4c213c3e_b654ab7c",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 86,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "Not for another task, but for the same task again. In uses where a class has a Start() and Stop() method. I considered using some kind of unique_ptr semantics for this, but in practice, that just made everything more complex without really making anything more clear (we still need to handle the state of the unique_ptr). The state diagram is still simple enough, so I think it\u0027s fine.",
      "parentUuid": "71b4f305_16b35c07",
      "range": {
        "startLine": 86,
        "startChar": 32,
        "endLine": 86,
        "endChar": 69
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "831f358c_f2e7cf8c",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 86,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-16T09:57:44Z",
      "side": 1,
      "message": "But the API you\u0027ve made doesn\u0027t say anything about the same task again. It even requires the caller to supply the task each time.",
      "parentUuid": "4c213c3e_b654ab7c",
      "range": {
        "startLine": 86,
        "startChar": 32,
        "endLine": 86,
        "endChar": 69
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a29659a_8062afdf",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 86,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-16T11:01:26Z",
      "side": 1,
      "message": "I mean that the current use case for restarting a task is to restart with an identical task. From the handles point of view it\u0027s not a requirement that it\u0027s identical.\n\nIf we believe that there\u0027s a risk for bugs due to starting with a different task by accident I guess it would make sense to make it so it\u0027s only possible to restart the task, not call start again with a new (potentially identical) task.\n\nHowever, that would increase the number of states for the class, now we have two states: Running and Stopped. Then we would have three: Not started, Running and Started but stopped. I also think it could be a bit complicated ownership wise. (We would have to keep the task alive even after stopping it, in case we want to restart it)\n\nBut maybe I\u0027m misinterpreting your suggestion?",
      "parentUuid": "831f358c_f2e7cf8c",
      "range": {
        "startLine": 86,
        "startChar": 32,
        "endLine": 86,
        "endChar": 69
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9b61c8e7_4028bd5a",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 86,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-16T12:13:02Z",
      "side": 1,
      "message": "I was thinking of something like having only (1) constructors or create functions that create the handle and start the task, and (2) a method that stops the task. Then there would be two states, Running and Stopped, and we would never transition from Stopped back to Running. Users that want to restart things would simply use a new handle.",
      "parentUuid": "7a29659a_8062afdf",
      "range": {
        "startLine": 86,
        "startChar": 32,
        "endLine": 86,
        "endChar": 69
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4104b36d_cd6209f5",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 86,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-16T14:38:19Z",
      "side": 1,
      "message": "But the new handle would need a new scope as well, something we usually don\u0027t have. We could work around this by putting into a unique_ptr, but then we are essentially back to the situation of having two states, either a nullptr or a handle instance. I also don\u0027t want to rely on the destructor of the handle to stop the task as that\u0027s not always what we want to do.\n\nI\u0027d like to not make the interface and usage overly complicated (with unique_ptr, moves, etc), having two possible states for the handle seems like a reasonable tradeoff. If it\u0027s confusing, maybe there\u0027s something we can add to the documentation?",
      "parentUuid": "9b61c8e7_4028bd5a",
      "range": {
        "startLine": 86,
        "startChar": 32,
        "endLine": 86,
        "endChar": 69
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "63841f28_46e243c9",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 86,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-16T15:04:13Z",
      "side": 1,
      "message": "\u003e But the new handle would need a new scope as well, something we usually don\u0027t have. We could work around this by putting into a unique_ptr, but then we are essentially back to the situation of having two states, either a nullptr or a handle instance. I also don\u0027t want to rely on the destructor of the handle to stop the task as that\u0027s not always what we want to do.\n\nNot necessarily a new scope. You can overwrite an existing handle:\n\n  task_ \u003d RepeatingTask::Start(kIncludingExecution, []{Foo(17); return 4711;});\n  ...\n  task_.Stop();\n  task_ \u003d RepeatingTask::Start(kIncludingExecution, []{Bar(\"baz\"); return 17;});\n\n\u003e I\u0027d like to not make the interface and usage overly complicated (with unique_ptr, moves, etc), having two possible states for the handle seems like a reasonable tradeoff. If it\u0027s confusing, maybe there\u0027s something we can add to the documentation?",
      "parentUuid": "4104b36d_cd6209f5",
      "range": {
        "startLine": 86,
        "startChar": 32,
        "endLine": 86,
        "endChar": 69
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "128ae9ef_583bcf74",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 86,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-16T15:52:26Z",
      "side": 1,
      "message": "We still would need to have two states right? Maybe we can land this as is, and then you can create a CL with your suggestions on how to improve it?",
      "parentUuid": "63841f28_46e243c9",
      "range": {
        "startLine": 86,
        "startChar": 32,
        "endLine": 86,
        "endChar": 69
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f9dec924_88b4f2c9",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 86,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-16T16:10:51Z",
      "side": 1,
      "message": "I made it movable in the way you suggested in the last CL (without exclusive mode)",
      "parentUuid": "128ae9ef_583bcf74",
      "range": {
        "startLine": 86,
        "startChar": 32,
        "endLine": 86,
        "endChar": 69
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c261ba31_232bf635",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "spelling",
      "range": {
        "startLine": 92,
        "startChar": 6,
        "endLine": 92,
        "endChar": 18
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6abec04f_831e5cb0",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 92,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c261ba31_232bf635",
      "range": {
        "startLine": 92,
        "startChar": 6,
        "endLine": 92,
        "endChar": 18
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5aaa0cdb_e5a87bc9",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 94,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-16T15:04:13Z",
      "side": 1,
      "message": "Hmm. Is it obvious which of the two is the default? Consider forcing callers to spell it out.",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ef9a903a_53067165",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 94,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-16T15:52:26Z",
      "side": 1,
      "message": "I just realized that the only place we actually use the exclusive mode is in the overuse checker task, and that is called with a 5 second interval, meaning that the difference excluding execution time makes would be minimal in comparison. do you agree that it makes sense to remove the exclusive interval mode in light of that?",
      "parentUuid": "5aaa0cdb_e5a87bc9",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "27c050e3_8f013f51",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "Alternatively, (1) create a local unique_ptr foo that holds the task, (2) set repeating_task_ \u003d foo.get(), (3) call PostTask with std::move(foo). That way you always have a unique_ptr as owner, and don\u0027t have to explain that you\u0027re doing something tricky with ownership.",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "962ad9b0_54e8bef8",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "The comment is a leftover from a refactor, it\u0027s not needed here as it\u0027s implied by WrapUnique, so removed that.\n\nI tried that variant before. but I think it mostly made it more verbose without really clarifying anything. The wrapunique here also matches the one done when reposting the task nicely IMO.",
      "parentUuid": "27c050e3_8f013f51",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b4ca8466_40f3c6a6",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-16T09:57:44Z",
      "side": 1,
      "message": "\u003e The comment is a leftover from a refactor, it\u0027s not needed here as it\u0027s implied by WrapUnique, so removed that.\n\nAck.\n\n\u003e I tried that variant before. but I think it mostly made it more verbose without really clarifying anything.\n\nI find there\u0027s great value in never ever having raw pointer own stuff. When reading code, it\u0027s a great help to know that since there\u0027s always a unique_ptr holding ownership, the compiler has your back and will tell you if there are mistakes.\n\nThat said, if you still feel it\u0027s easier to read this way, OK. It *is* fewer steps.\n\n\u003e The wrapunique here also matches the one done when reposting the task nicely IMO.\n\nYes, but that one is forced by our API, which forces the caller to hold ownership in a raw pointer when calling Run(). Not a great example to emulate.",
      "parentUuid": "962ad9b0_54e8bef8",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "734dcd4c_bd5a1f7b",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 113,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-16T11:01:26Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b4ca8466_40f3c6a6",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3c804533_2bce045c",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 121,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "delayed",
      "range": {
        "startLine": 121,
        "startChar": 21,
        "endLine": 121,
        "endChar": 27
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c25032d_e38f3d92",
        "filename": "rtc_base/repeating_task.h",
        "patchSetId": 4
      },
      "lineNbr": 121,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3c804533_2bce045c",
      "range": {
        "startLine": 121,
        "startChar": 21,
        "endLine": 121,
        "endChar": 27
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b6a327fd_b70fc164",
        "filename": "rtc_base/repeating_task_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 36,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "Don\u0027t we have a library function for sleeping? C++11 thread and std::chrono stuff is forbidden by the Chromium style guide IIRC.",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31101edc_6f5e5aa4",
        "filename": "rtc_base/repeating_task_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 36,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "I found only SleepMs, but that can return early if there are system events. Added comments explaining that \u003cchrono\u003e and \u003cthread\u003e is not allowed in production. I figure it should be alright in test code?",
      "parentUuid": "b6a327fd_b70fc164",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ed8d99c_ba6ad588",
        "filename": "rtc_base/repeating_task_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 36,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-16T09:57:44Z",
      "side": 1,
      "message": "Hmm, I guess so.",
      "parentUuid": "31101edc_6f5e5aa4",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "62c7049c_f89a0fdb",
        "filename": "rtc_base/repeating_task_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 84,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "kShortIntervalCount?",
      "range": {
        "startLine": 84,
        "startChar": 28,
        "endLine": 84,
        "endChar": 29
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "296c8f19_b28ba877",
        "filename": "rtc_base/repeating_task_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 84,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "62c7049c_f89a0fdb",
      "range": {
        "startLine": 84,
        "startChar": 28,
        "endLine": 84,
        "endChar": 29
      },
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "26d3efd5_de5fa774",
        "filename": "video/overuse_frame_detector.cc",
        "patchSetId": 4
      },
      "lineNbr": 559,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-15T14:03:50Z",
      "side": 1,
      "message": "Would it make sense to allow Stop() even if the task isn\u0027t running?",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f6e1234_4ee2fffa",
        "filename": "video/overuse_frame_detector.cc",
        "patchSetId": 4
      },
      "lineNbr": 559,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-15T15:14:14Z",
      "side": 1,
      "message": "Looking at the uses, it seems like it. Done!",
      "parentUuid": "26d3efd5_de5fa774",
      "revId": "aa3aeb3b090d5a134c69cbf0d7f719250ff5f86a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}