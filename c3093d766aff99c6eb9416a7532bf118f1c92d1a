{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "158d139d_604e76cc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 10
      },
      "lineNbr": 0,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-08-31T21:56:58Z",
      "side": 1,
      "message": "Thanks for the thorough review Danil!",
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "de9d4b22_adb2ff7a",
        "filename": "api/video_codecs/spatial_layer.cc",
        "patchSetId": 10
      },
      "lineNbr": 34,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:28:43Z",
      "side": 1,
      "message": "This feels a bit fragile to me. Do we have guarantees on sanity of input? Otherwise eg scalability_mode[1] \u003e\u003d \u00271\u0027 could trigger on lots of different chars, and scalability_mode[1] - \u00270\u0027 could be way out of range too.\n\nUnless this method is designed to be called very often, I think I\u0027d prefer either just matching against the known fixed strings. Alternatively using something like sscanf or even a regexp and validating the layer counts.",
      "range": {
        "startLine": 29,
        "startChar": 2,
        "endLine": 34,
        "endChar": 3
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "efd6c1b6_a17aea77",
        "filename": "api/video_codecs/spatial_layer.cc",
        "patchSetId": 10
      },
      "lineNbr": 34,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-09-01T13:38:14Z",
      "side": 1,
      "message": "there is also check `scalability_mode[1] \u003c\u003d \u00273\u0027` to avoid too large values of the spatial_id.\n\nproblem with known fixed strings is that that list need to be kept up to date with the scalability modes we support.\nCurrent expression (cheap regexp) cover them all and also future modes that would use same or similar naming scheme.",
      "parentUuid": "de9d4b22_adb2ff7a",
      "range": {
        "startLine": 29,
        "startChar": 2,
        "endLine": 34,
        "endChar": 3
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d62ae25_6046ed24",
        "filename": "api/video_codecs/spatial_layer.cc",
        "patchSetId": 10
      },
      "lineNbr": 34,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:59:55Z",
      "side": 1,
      "message": "Right. Still not really a fan of the string representation as a whole. Since it\u0027s a string straight from the internets I would feel better if we had strict parsing in one place and translate to a known support type, where mapping to layers counts is easier.\nRight now we\u0027re ok with e.g. \"LWT3XHUFE\" parsing ok as 3. Might not be an issues per say but the more places we add with string parsing...\n\nI don\u0027t want to delay this feature unnecessarily though.",
      "parentUuid": "efd6c1b6_a17aea77",
      "range": {
        "startLine": 29,
        "startChar": 2,
        "endLine": 34,
        "endChar": 3
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c85eb5ca_3d83487d",
        "filename": "api/video_codecs/spatial_layer.cc",
        "patchSetId": 10
      },
      "lineNbr": 34,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-09-01T14:42:42Z",
      "side": 1,
      "message": "in \"LWT3XHUFE\"\nscalability_mode[1] \u003d\u003d \u0027W\u0027 which is larger than \u00273\u0027.\nbut for the strings\n\"L3T3_SCREENSHARE\u0027 or \"L3T1T1T3\" this function would return 3 spatial layers.\n\n\u0027proper\u0027 solution is do something like\nauto svc_controller \u003d CreateScalabilityStructure(scalability_mode);\nif (!svc_controller) return absl::nullopt;\nreturn svc_controller-\u003eStreamConfig().num_spatial_layers;\n\nbut that seems a bit heavy to me.",
      "parentUuid": "2d62ae25_6046ed24",
      "range": {
        "startLine": 29,
        "startChar": 2,
        "endLine": 34,
        "endChar": 3
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "74ea97e5_f6eff3e5",
        "filename": "media/engine/internal_decoder_factory_unittest.cc",
        "patchSetId": 10
      },
      "lineNbr": 37,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:28:43Z",
      "side": 1,
      "message": "nite: maybe comment what the parameters are",
      "range": {
        "startLine": 37,
        "startChar": 58,
        "endLine": 37,
        "endChar": 69
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa5a6c16_e5aab23c",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 10
      },
      "lineNbr": 66,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:28:43Z",
      "side": 1,
      "message": "nit: a little misleading comment",
      "range": {
        "startLine": 66,
        "startChar": 5,
        "endLine": 66,
        "endChar": 17
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9901af23_d9de53cd",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 10
      },
      "lineNbr": 75,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:28:43Z",
      "side": 1,
      "message": "Maybe it would be better to delegate this knowledge the the codec classes instead? E.g. something like:\nif (absl::EqualsIgnoreCase(format.name, cricket::kVp8CodecName))\n    return VP8Encoder::SupportsScalabilityMode(scalability_mode);\n\n...since I think the H264 format can support SVC, but our OpenH264 implementation does not. Maintaining that knowledge in the codec class instead of the factory seems easier to me.",
      "range": {
        "startLine": 74,
        "startChar": 31,
        "endLine": 75,
        "endChar": 37
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9c7442a_9936b472",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 10
      },
      "lineNbr": 75,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-09-01T13:38:14Z",
      "side": 1,
      "message": "There is a TODO few lines above for exactly that.",
      "parentUuid": "9901af23_d9de53cd",
      "range": {
        "startLine": 74,
        "startChar": 31,
        "endLine": 75,
        "endChar": 37
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a77404b5_a23eb6a0",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 10
      },
      "lineNbr": 75,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:59:55Z",
      "side": 1,
      "message": "Ah, missed that. Why delay it?",
      "parentUuid": "c9c7442a_9936b472",
      "range": {
        "startLine": 74,
        "startChar": 31,
        "endLine": 75,
        "endChar": 37
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53dedf8c_8d9147bf",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 10
      },
      "lineNbr": 77,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:28:43Z",
      "side": 1,
      "message": "nit: {/*is_supported\u003d*/false, /*is_power_efficient\u003d*/false} ?",
      "range": {
        "startLine": 77,
        "startChar": 71,
        "endLine": 77,
        "endChar": 76
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "018f8844_ab85da82",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 10
      },
      "lineNbr": 85,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:28:43Z",
      "side": 1,
      "message": "Our h264 encoder supports simulcast..?",
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce25dc68_80b86f52",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 10
      },
      "lineNbr": 85,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:59:55Z",
      "side": 1,
      "message": "...and temporal layers which is what matters according to comment below :)",
      "parentUuid": "018f8844_ab85da82",
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2fccfdb_0573df15",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 10
      },
      "lineNbr": 87,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:28:43Z",
      "side": 1,
      "message": "The L?T? modes (i.e. pure simulcast) are supported by vp8 and h264",
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2d68018_fbfffa85",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 10
      },
      "lineNbr": 87,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-09-01T13:38:14Z",
      "side": 1,
      "message": "L?T? are full svc modes.\nS?T? are simulcast over _same_ ssrc modes.\nscalability mode doesn\u0027t describe simulcast over _multiple_ ssrcs (there should be scalability mode per ssrc)",
      "parentUuid": "c2fccfdb_0573df15",
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b7744cd5_32d9d869",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 10
      },
      "lineNbr": 87,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:59:55Z",
      "side": 1,
      "message": "Sorry, meant the S?T? ones. Ah, that\u0027s the distinction. So VP8 is included just for temporal layer support?",
      "parentUuid": "b2d68018_fbfffa85",
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21580a86_1d4f58c6",
        "filename": "media/engine/internal_encoder_factory.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:28:43Z",
      "side": 1,
      "message": "Could this be an enum instead, e.g. media/base/svc_scalability_mode.h ?",
      "range": {
        "startLine": 32,
        "startChar": 6,
        "endLine": 32,
        "endChar": 50
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "edf6d31c_a41b135a",
        "filename": "media/engine/internal_encoder_factory.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-09-01T13:38:14Z",
      "side": 1,
      "message": "probably not: the input string comes all the way from js api.",
      "parentUuid": "21580a86_1d4f58c6",
      "range": {
        "startLine": 32,
        "startChar": 6,
        "endLine": 32,
        "endChar": 50
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "af398b1c_490a884e",
        "filename": "media/engine/internal_encoder_factory.h",
        "patchSetId": 10
      },
      "lineNbr": 32,
      "author": {
        "id": 5524
      },
      "writtenOn": "2021-09-01T13:59:55Z",
      "side": 1,
      "message": "Imo all the more reason to translate it in one place, as close to js as possible.\nBut I see that might be out of scope here. Something to add to the refactoring backlog maybe.",
      "parentUuid": "edf6d31c_a41b135a",
      "range": {
        "startLine": 32,
        "startChar": 6,
        "endLine": 32,
        "endChar": 50
      },
      "revId": "c3093d766aff99c6eb9416a7532bf118f1c92d1a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}