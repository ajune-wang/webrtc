{
  "comments": [
    {
      "key": {
        "uuid": "520f9246_986c2216",
        "filename": "audio/channel_receive.cc",
        "patchSetId": 18
      },
      "lineNbr": 124,
      "author": {
        "id": 7704
      },
      "writtenOn": "2018-10-23T14:46:32Z",
      "side": 1,
      "message": "can this method be called during destruction? Do we need any synchronization primitives here?\n\nI.e. SetReceiveAudioSink(nullptr) can be called while this method is being executed. While on the interface level, SetReceiveAudioSink guarantees that no further processing will occur, one might already be in progress.\n\n\nAnd on the other note: in the real downstream implemenetation today, we are invoking this method under the lock (so that SetReceiveAudioSink(nullptr) blocks until OnData()  finishes).\n\nis audio_coding-\u003eIncomingPacket asynchronous?",
      "range": {
        "startLine": 124,
        "startChar": 21,
        "endLine": 124,
        "endChar": 27
      },
      "revId": "e6b94681a825e824775f6a2dd155f34a611a658b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75838485_57d1f289",
        "filename": "audio/channel_receive.cc",
        "patchSetId": 18
      },
      "lineNbr": 124,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-10-24T12:06:32Z",
      "side": 1,
      "message": "Related: I think it\u0027s currently required that StopPlayout is called, before destroying the object.\n\nI think it is reasonable to require that SetReceiveAudioSink(nullptr) is synchronous, in that it waits for any current OnData calls to complete. Similar to VideoSourceInterface:RemoveSink, which we\u0027ve been discussing extensively in the past. Should be documented in media_Transport_interface.h.\n\nNow, synchronous remove also has some problems, but the reasonable alternative requires an additional OnRemovalComplete callback or the like, signalling that is is safe to destroy the sink.",
      "parentUuid": "520f9246_986c2216",
      "range": {
        "startLine": 124,
        "startChar": 21,
        "endLine": 124,
        "endChar": 27
      },
      "revId": "e6b94681a825e824775f6a2dd155f34a611a658b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "560d311e_3d96051b",
        "filename": "audio/test/media_transport_test.cc",
        "patchSetId": 18
      },
      "lineNbr": 36,
      "author": {
        "id": 7704
      },
      "writtenOn": "2018-10-24T03:13:26Z",
      "side": 1,
      "message": "just to check: you are saying that when you changed it to 1, opus wasn\u0027t working?",
      "range": {
        "startLine": 36,
        "startChar": 14,
        "endLine": 36,
        "endChar": 26
      },
      "revId": "e6b94681a825e824775f6a2dd155f34a611a658b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ce2f2fc_e1a3e6ed",
        "filename": "audio/test/media_transport_test.cc",
        "patchSetId": 18
      },
      "lineNbr": 36,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-10-24T12:06:32Z",
      "side": 1,
      "message": "Yes. For some reason, opus must always be configured with two channels on this level (otherwise, instantiating the encoder just fails), and when it\u0027s used in production, there are additional attributes in SDP to say if it\u0027s actually stereo or mono. It\u0027s a bit weird, and I haven\u0027t tried to really understand it.",
      "parentUuid": "560d311e_3d96051b",
      "range": {
        "startLine": 36,
        "startChar": 14,
        "endLine": 36,
        "endChar": 26
      },
      "revId": "e6b94681a825e824775f6a2dd155f34a611a658b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}