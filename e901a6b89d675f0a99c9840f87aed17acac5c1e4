{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7041d345_7c40a90d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 12094
      },
      "writtenOn": "2024-02-02T08:15:37Z",
      "side": 1,
      "message": "@philipel@chromium.org, this CL mainly add HEVC support for h26x_packet_buffer. `Clear` and `ClearTo` are not implemented yet. I\u0027ll add them in a separate CL.",
      "revId": "e901a6b89d675f0a99c9840f87aed17acac5c1e4",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2af9b9c0_18cba9ab",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2024-02-05T07:01:18Z",
      "side": 1,
      "message": "Holding off until H.26x experts have chimed in.\nSomewhat skeptical of merging the buffer classes when the resulting H26x class has \"if this codec/that codec\" functions. A common base class with subclasses may be a cleaner pattern.",
      "revId": "e901a6b89d675f0a99c9840f87aed17acac5c1e4",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "60681dd5_9d851155",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 12094
      },
      "writtenOn": "2024-02-05T07:40:16Z",
      "side": 1,
      "message": "Philip might have some experiments two years ago, and decided to move forward with the standalone h26x_packet_buffer (see conversation with Philip above). It would be hard for him to recall the reason, but if you and Philip (or other reviewers) think it worths to try the inheritance pattern again, I can update the CL and see if there is any problems at this time.",
      "parentUuid": "2af9b9c0_18cba9ab",
      "revId": "e901a6b89d675f0a99c9840f87aed17acac5c1e4",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d13d50d8_3c82b0cf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 18005
      },
      "writtenOn": "2024-02-05T07:56:28Z",
      "side": 1,
      "message": "Let me explain the difference of H.265 packet buffer impl. against H.264 packet buffer:\n\n1. For H.264 the output from depacketizer is an array of NALUs(without start code) with their indices in RTPHeader.H264CodecSpecific;\n   - Packet buffer is expected to 1) check existence of key-frame before outputting frame; 2) add start code before NALU; 3) configure RTPHeader.frameType according to current frame\u0027s real type.\n   \n2. For H.265 the output from depacketizer is already segments with start code inserted when necessary, and RTPHeader.frameType configured. Packet buffer is expected to only check existence of key-frame before outputting frame. Nothing else. The decision of not having H.265 codec specific RTPHeader member is made with RTC team at the beginning.\n\nLooks a little overkill to have a base H.26x packet_buffer class and H.264/H.265 override that, but I don\u0027t have strong objection on doing that.",
      "parentUuid": "60681dd5_9d851155",
      "revId": "e901a6b89d675f0a99c9840f87aed17acac5c1e4",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}