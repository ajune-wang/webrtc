{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1de27d3d_7e600492",
        "filename": "logging/rtc_event_log/events/rtc_event_field_extraction.cc",
        "patchSetId": 11
      },
      "lineNbr": 22,
      "author": {
        "id": 5531
      },
      "writtenOn": "2021-09-15T09:56:46Z",
      "side": 1,
      "message": "why not uint8_t?",
      "range": {
        "startLine": 22,
        "startChar": 0,
        "endLine": 22,
        "endChar": 8
      },
      "revId": "ff1d06fc5f199e1949e9cb27389155142d2c292b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ad75598_be7910fe",
        "filename": "logging/rtc_event_log/events/rtc_event_field_extraction.cc",
        "patchSetId": 11
      },
      "lineNbr": 27,
      "author": {
        "id": 5531
      },
      "writtenOn": "2021-09-15T09:56:46Z",
      "side": 1,
      "message": "log is still not super clear, and the fact that i happens to become the 2-logarithm isn\u0027t super relevant in this context. Id suggest something like:\n\nuint64_t required_bits \u003d 1; // We need one bit to encode zero\nwhile(max_magnitude \u003e\u003e\u003d 1){\n ++required_bits;\n}\nreturn required_bits;\n\nOr considering how it\u0027s used below:\n\nuint64_t required_bits \u003d 0;\nwhile(max_magnitude){\n ++required_bits;\n max_magnitude \u003e\u003e\u003d 1;\n}\nreturn required_bits;",
      "range": {
        "startLine": 23,
        "startChar": 2,
        "endLine": 27,
        "endChar": 17
      },
      "revId": "ff1d06fc5f199e1949e9cb27389155142d2c292b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b29a40b_a6fa78de",
        "filename": "logging/rtc_event_log/events/rtc_event_field_extraction.cc",
        "patchSetId": 11
      },
      "lineNbr": 35,
      "author": {
        "id": 5531
      },
      "writtenOn": "2021-09-15T09:56:46Z",
      "side": 1,
      "message": "bitwidth_positive",
      "range": {
        "startLine": 35,
        "startChar": 17,
        "endLine": 35,
        "endChar": 29
      },
      "revId": "ff1d06fc5f199e1949e9cb27389155142d2c292b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e88a1ee6_e763ab49",
        "filename": "logging/rtc_event_log/events/rtc_event_field_extraction.cc",
        "patchSetId": 11
      },
      "lineNbr": 37,
      "author": {
        "id": 5531
      },
      "writtenOn": "2021-09-15T09:56:46Z",
      "side": 1,
      "message": "bitwidth_negative",
      "range": {
        "startLine": 37,
        "startChar": 17,
        "endLine": 37,
        "endChar": 29
      },
      "revId": "ff1d06fc5f199e1949e9cb27389155142d2c292b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee7fb9a9_b9d151a0",
        "filename": "logging/rtc_event_log/events/rtc_event_field_extraction.h",
        "patchSetId": 11
      },
      "lineNbr": 75,
      "author": {
        "id": 5531
      },
      "writtenOn": "2021-09-15T09:56:46Z",
      "side": 1,
      "message": "Won\u0027t this be expensive to always do in the inner loop like this?",
      "range": {
        "startLine": 75,
        "startChar": 4,
        "endLine": 75,
        "endChar": 45
      },
      "revId": "ff1d06fc5f199e1949e9cb27389155142d2c292b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cf299027_766ff3ab",
        "filename": "logging/rtc_event_log/events/rtc_event_field_extraction.h",
        "patchSetId": 11
      },
      "lineNbr": 83,
      "author": {
        "id": 5531
      },
      "writtenOn": "2021-09-15T09:56:46Z",
      "side": 1,
      "message": "nit: mask positions would imply using an int for the position, while this is a mask for what values are defined, (compare to numpy masked arrays: https://numpy.org/doc/stable/reference/maskedarray.html)",
      "range": {
        "startLine": 83,
        "startChar": 20,
        "endLine": 83,
        "endChar": 29
      },
      "revId": "ff1d06fc5f199e1949e9cb27389155142d2c292b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c161a24_832a7bc3",
        "filename": "logging/rtc_event_log/events/rtc_event_field_extraction.h",
        "patchSetId": 11
      },
      "lineNbr": 118,
      "author": {
        "id": 5531
      },
      "writtenOn": "2021-09-15T09:56:46Z",
      "side": 1,
      "message": "Is this for error reporting? Maybe return optional\u003cError\u003e? Or ideally, avoid getting into the error state and simply CHECK/DCHECK. IF you really can\u0027t avoid using a bool for error handling, it should be documented and have an annotation to enforce usage of the return value at the call site.",
      "range": {
        "startLine": 118,
        "startChar": 0,
        "endLine": 118,
        "endChar": 4
      },
      "revId": "ff1d06fc5f199e1949e9cb27389155142d2c292b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6ed416f8_bb545292",
        "filename": "logging/rtc_event_log/events/rtc_event_field_extraction.h",
        "patchSetId": 11
      },
      "lineNbr": 126,
      "author": {
        "id": 5531
      },
      "writtenOn": "2021-09-15T09:56:46Z",
      "side": 1,
      "message": "nit: one line...",
      "range": {
        "startLine": 125,
        "startChar": 0,
        "endLine": 126,
        "endChar": 30
      },
      "revId": "ff1d06fc5f199e1949e9cb27389155142d2c292b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}