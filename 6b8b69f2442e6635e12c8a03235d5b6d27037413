{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1601f2fd_b3c73850",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-01-29T18:15:00Z",
      "side": 1,
      "message": "I should have run tests before sending it for review.\nI did check that FakeNetworkSocket is destroyed and process packets on the same thread, but didn\u0027t noticed FakeNetworkSocket is created on a different thread. \n\nIt seems to me SafetyFlag still should work when created on a different thread.\nTommi, can you confirm?",
      "revId": "6b8b69f2442e6635e12c8a03235d5b6d27037413",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c05bc0e1_6cd5c2cf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-01-30T11:18:56Z",
      "side": 1,
      "message": "TL;DR: The flag needs to be created on the same thread/task queue where the \u0027alive\u0027 state is checked.\n\nThe safety flag has fairly strict (but usually easy to meet) requirements that allow us to avoid synchronization and in the end, the |alive| check is just checking a regular bool thanks to those restrictions.\n\nIn my experience when those requirements can\u0027t be met, it points to an issue that can be (or perhaps _needs to be_) addressed in the code where we\u0027d like to use the SafetyFlag.\n\nCan you point me to the test that fails? Is the problem that the FakeNetworkSocket somehow gets created on a different thread then its destroyed on? Perhaps that\u0027s the problem we could fix? (what is the prod behavior?)",
      "parentUuid": "1601f2fd_b3c73850",
      "revId": "6b8b69f2442e6635e12c8a03235d5b6d27037413",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "499332b8_3ba5f0d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-01-30T13:21:33Z",
      "side": 1,
      "message": "TL;DR: Why?\n\nI understand that using the flag (alive/SetAlive) has to be on the same sequence to avoid extra synchronisation. That normally imply that the object under protection has to be used (check alive) and destroyed (SetAlive(false)) on the same sequence.\n\nWhat I do not understand, is the requirement to create that object on the same sequence. Can you please point me to an explanation why.\n\ni.e. what is wrong with a pattern.\nRTC_DCHECK_RUN_ON(singaling_thread);\nauto object \u003d std::make_unique\u003cClass\u003e(large, parameters, accessed, only, on, signaling, thread);\n\nworker_thread_-\u003ePostTask([object \u003d std::move(object)]() mutable {\n  object-\u003eDoSomthing();\n  object \u003d nullptr;\n});\n\n------\nNetworkEmulationManagerTest.Run test fails without change to the safety flag (patchset#1). \nMay be it is not hard to change the test and create objects on the same thread they are are used. But before starting investigation how hard it is, I want to understand why do it in the first place.",
      "parentUuid": "c05bc0e1_6cd5c2cf",
      "revId": "6b8b69f2442e6635e12c8a03235d5b6d27037413",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9fb2114a_1fa376e7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-01-30T13:52:58Z",
      "side": 1,
      "message": "The constructor is used to capture what context the flag is valid for and as is, that\u0027s done implicitly because we use a SequenceChecker to catch programmer errors and the SequenceChecker goes away in official release builds.\n\nIf we wanted to allow injecting the context information into the flag instance, then that implies SequenceChecker doing that (and ideally that code should also vanish from official builds). However, as SequenceChecker is used, the implicit behavior is relied upon and allowing construction anywhere while requiring use of an instance to be in a specific context, takes away an assumption that a single threaded implementation could otherwise make about the construction context.\n\nSo, concretely to give an example of what could be problematic in the example above:\n\nif Class has a SequenceChecker member variable, it must Detach() that sequence checker in the constructor. At that point the first method call made on that object will \"win\" and be considered the correct thread, whether it is or not. That means that you\u0027ll only catch an error when a call is made following the first call and in a different context. If you then find out that the method call that raised a DCHECK was actually made in the correct context, you\u0027ve lost information about what call was made previously and was incorrectly marked as \"correct\".",
      "parentUuid": "499332b8_3ba5f0d4",
      "revId": "6b8b69f2442e6635e12c8a03235d5b6d27037413",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f1bb2601_0cfb564a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 6337
      },
      "writtenOn": "2021-01-31T02:14:18Z",
      "side": 1,
      "message": "I\u0027m thinking, when creating SequenceChecker can we make it possible to explicitly provide to which thread in should belong in the constructor instead of detaching it from the current thread and allowing to another first come thread to acquire it?",
      "parentUuid": "9fb2114a_1fa376e7",
      "revId": "6b8b69f2442e6635e12c8a03235d5b6d27037413",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}