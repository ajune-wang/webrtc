{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c193ab0a_431dc557",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-10-19T17:09:07Z",
      "side": 1,
      "message": "Don\u0027t +1 this one (yet). Make commentary on the design choices.\n",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9107e77b_da5807c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6720
      },
      "writtenOn": "2021-10-19T18:37:51Z",
      "side": 1,
      "message": "adding danilchap@ too for input",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34f8d75c_a446741e",
        "filename": "api/peer_connection_interface.cc",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-10-20T07:36:09Z",
      "side": 1,
      "message": "remove this default to make sure the method doesn\u0027t compile if someone forgets to update the ToString method after adding to the enum collection.",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca5c4528_c4da0869",
        "filename": "api/peer_connection_interface.cc",
        "patchSetId": 1
      },
      "lineNbr": 64,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-10-20T07:36:09Z",
      "side": 1,
      "message": "same here - this shouldn\u0027t be necessary or the return statement.",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee392018_93a4e795",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 6720
      },
      "writtenOn": "2021-10-19T18:37:51Z",
      "side": 1,
      "message": "returning a std::string\u0026 seems problematic.\nIt implies a globally constructed object (discouraged or banned), an object that requires synchronization (which global objects partially are too) or an object that may have gone out of scope when returned.\n\nInstead, can we use trivially static string_view objects? (as in, that do not require runtime construction)",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76a500ee_ac5d8b30",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-10-19T20:26:14Z",
      "side": 1,
      "message": "Yep, a main point of this review is to settle what the best return type is.\n\nreturn an absl::string_view by value, constructing it from a string?\nor find a way to declare a lookup table of string_view valus without requiring a std::map that has to be destructed on program exit? (I tried with a static std::map\u003cPeerConnectionState, std::string\u003e and was told that this required a destructor on program exit, which was a no-no.)",
      "parentUuid": "ee392018_93a4e795",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c4f097a_f46ec28c",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-10-20T07:02:29Z",
      "side": 1,
      "message": "I think const std::string\u0026 makes sense if\n\n1. It\u0027s convenient for the implementation to back it by a string, e.g.,\n\nstatic const std::string kFoo \u003d \"foo\";  // In local scope\n\nAs far as I\u0027m aware, that kind of globals isn\u0027t discouraged. But not sure if it will be destructed at exit, which we\u0027d like to avoid.\n\n2. Most callers need a std::string, so returning one avoids construction and copy cost.\n\nOtherwise, returning a string_view (with documentation saying that it refers to a data  that lives for ever) is the \"modern\" way.\n\nRegarding avoiding destructors at exit: The standard trick seems to be\n\n// Intentionally leaked\nstatic std::map\u003c...\u003e* map \u003d new std::map\u003c...\u003e ...  // Also in local scope\n\nWill be constructed first time the scope is entered (in a thread-safe way), and never destroyed.",
      "parentUuid": "76a500ee_ac5d8b30",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16b2ded9_fc4a819c",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5087
      },
      "writtenOn": "2021-10-20T07:25:45Z",
      "side": 1,
      "message": "I like the absl::string_view on static storage strings and delegate the conversion to std::string if needed (is it in this case? IIUC this is mostly for logs right?)\n\nI am not sure we should add maps and things that dynamically allocate memory and require a lookup.",
      "parentUuid": "8c4f097a_f46ec28c",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87993063_e99a21a1",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-10-20T07:30:45Z",
      "side": 1,
      "message": "\"static Foo foo\" is a singleton pattern, which is discouraged. Since the type (std::string) is complex, it\u0027s a different thing than if we were talking about char[]. It also adds implicit global locking and atexit code.\n\nSo for this case it\u0027s not necessary (since the data is known at compile time), besides the above, it\u0027s also inefficient because of allocating additional heap memory for data that already exists in the data section. So I think std::string is a no-go.\n\nI also think that constructing a std::map for this is wasteful. A ToString method for constant enums has *all* the data available at compile time so there shouldn\u0027t be any need to construct a map at compile time and take on additional heap allocations (a std::map isn\u0027t cheap).\n\nI suggest we use absl::string_view as the return type, much like danil has already done for rtp header extension constants.\n\nFor converting a collection of enums to a string_view, we can either\n* have a switch statement inside a ToString() method on the enum values and return a literal.\n\n  absl::string_view ToString(FooEnum f) {\n    switch (f) {\n      case kF1:\n        return \"F1\";\n      // no default label.\n    }\n    // no return statement here.\n  }\n\n* or have a simple static array of const char* with the strings.\n\n  namespace {\n  // Assumes contiguous integral enum type Foo with a last kMaxFoo.\n  const char* g_foo_names[kMaxFoo] \u003d {\n    \"Foo\",\n    ...\n  };\n  }\n\n  absl::string_view ToString(FooEnum f) {\n    return g_foo_names[f];\n  }",
      "parentUuid": "8c4f097a_f46ec28c",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6978310d_5cc60e5c",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-10-20T07:47:21Z",
      "side": 1,
      "message": "\u003e   absl::string_view ToString(FooEnum f) {\n\u003e     switch (f) {\n\u003e       case kF1:\n\u003e         return \"F1\";\n\u003e       // no default label.\n\u003e     }\n\u003e     // no return statement here.\n\u003e   }\n\nThat may rightfully trigger compiler warnings (I vaguely remember gcc and clang behaving differently). An enum is just an int + syntactic sugar. I think it\u0027s valid C++ to call ToString(static_cast\u003cFooEnum\u003e(0xdeadbeaf)). That\u0027s clearly misuse of *our* apis, but since it\u0027s valid C++, it deserves at least a DCHECK to back up our api requirements, and make clear to the compiler that ToString returns some value (or aborts) for all inputs. \n\nI agree with no default statement, to get other proper warnings, so it would have to go after the switch, either CHECK(false) (or equivalent) or DCHECK(false); return \"invalid\";\n \n\u003e * or have a simple static array of const char* with the strings.\n\u003e \n\u003e   namespace {\n\u003e   // Assumes contiguous integral enum type Foo with a last kMaxFoo.\n\u003e   const char* g_foo_names[kMaxFoo] \u003d {\n\u003e     \"Foo\",\n\u003e     ...\n\u003e   };\n\u003e   }\n\u003e \n\u003e   absl::string_view ToString(FooEnum f) {\n\u003e     return g_foo_names[f];\n\u003e   }\n\nCan we have an array of string_view, do avoid runtime calls to strlen?",
      "parentUuid": "87993063_e99a21a1",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71d58d3c_8d8e1c2e",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-10-20T07:54:30Z",
      "side": 1,
      "message": "ah yes - array of string_view is better.",
      "parentUuid": "6978310d_5cc60e5c",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13a3901e_747fcf82",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-10-20T08:28:35Z",
      "side": 1,
      "message": "WRT array of string_view - we\u0027re at risk of invoking undefined behavior in C++ here.\n\nhttps://github.com/cplusplus/draft/commit/b416ec442dad103d57661007030bca096bd0fd0f\n\n\"A value of integral or enumeration type can be explicitly converted to\nan enumeration type. The value is unchanged if the original value is\nwithin the range of the enumeration values~(\\ref{dcl.enum}). Otherwise,\nthe behavior is undefined.\"\n\nabsl::string_view returned by value seems like the best choice for return value.\n\n1) Easiest to read:\nswitch(f) {\ncase kF1: return \"f1\"; // dynamically calls string_view constructor and strlen\n}\nRTC_CHECK_NOTREACHED();\n\n2) harder to read, but should force the compiler to do strlen at compile time:\n\nswitch(f) {\ncase kF1: return (constexpr string_view(\"f1\"));\n}\nRTC_CHECK_NOTREACHED();\n\nthe compiler has enough information to turn 1) into 2), but don\u0027t know if it does.\n\n3) dangerous in case of C++ UB, vulnerable to new names in the middle, but seems to certainly avoid runtime strlen:\n\nstatic const string_view[] names \u003d {\"f1\"};\n\nRTC_CHECK(f in names);\nreturn names[f];\n\nSo many choices :-)",
      "parentUuid": "71d58d3c_8d8e1c2e",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "966afd89_42a8bfc7",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-10-20T08:41:11Z",
      "side": 1,
      "message": "https://github.com/cplusplus/draft/commit/b416ec442dad103d57661007030bca096bd0fd0f\n\u003e \n\u003e \"A value of integral or enumeration type can be explicitly converted to\n\u003e an enumeration type. The value is unchanged if the original value is\n\u003e within the range of the enumeration values~(\\ref{dcl.enum}). Otherwise,\n\u003e the behavior is undefined.\"\n\nWhat does \"within the range of\" mean here? Is that the range of the underlying integral type? (The set of values that have assigned enum names isn\u0027t quite a \"range\", and I imagine the use of enums for flag bits to be or:ed together is too widespread to be UB).\n\n\u003e 1) Easiest to read:\n\u003e switch(f) {\n\u003e case kF1: return \"f1\"; // dynamically calls string_view constructor and strlen\n\u003e }\n\nI would be surprised if the compiler doesn\u0027t do constant folding to eliminate run-time call to strlen.",
      "parentUuid": "13a3901e_747fcf82",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f616178f_ece596aa",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-10-20T08:59:23Z",
      "side": 1,
      "message": "\"A value of integral or enumeration type can be explicitly converted to an enumeration type.\"\n\nHm... ignoring \"integral or\"... isn\u0027t that just tautology? 😄 Regardless, we\u0027re talking exclusively about integral types for the purposes of this CL.\n\nFor the second part of the paragraph:\n\n  \"The value is unchanged if the original value is within the range of the enumeration values~(\\ref{dcl.enum}). Otherwise, the behavior is undefined.\"\n\nA couple of things that I think would be helpful for us to consider to avoid over engineering a utility like this. First, can we assume that the caller owns the responsibility of ensuring that the value passed to ToString(), is a legal value? If so, the implementation can just focus on making sure that all legal values are correctly accounted for and we do not have to be concerned with undefined behavior.\n\nSecondly, at this abstraction level, I don\u0027t think that overly defensive programming hold much value (with the exception of static_assert + constexpr functions that e.g. check ranges etc). It could just contribute code bloat and consume cpu cycles and memory but the foot gun is still there since the caller can do all sorts of bad things anyway.",
      "parentUuid": "966afd89_42a8bfc7",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a30a4b5_35efe25e",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-10-20T09:09:28Z",
      "side": 1,
      "message": "The issue of compiler warnings was discussed at some length on https://webrtc-review.googlesource.com/c/src/+/189784. I\u0027d suggest doing the same thing, just adding an RTC_CHECK(false) after the switch statement.\n\nResponsibility of passing legal (according to our apis and conventions) values stays with the caller, we just have to explain that to the compiler.",
      "parentUuid": "f616178f_ece596aa",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3f2af96_0a752abe",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 183,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-10-20T09:17:56Z",
      "side": 1,
      "message": "I\u0027m not convinced that this is the right thing to do in all cases. For frequently used inline utility functions, I\u0027d not want the associated code that comes with RTC_CHECK(false) to be injected for all callers.\n\nAlso the description for that CL states:\n\n  \"In all the reported cases, the end of function is never actually reached. Add RTC_CHECK(false) to ensure the compiler is aware that this path is a dead-end.\"\n\nThat isn\u0027t what the CL does. The first sentence is useful information, but the second sentence is the opposite of what the change does. Before the change, the compiler would know about what paths are legal and which ones should trigger a compiler error. What the change does is take that knowledge away and make it a runtime possibility to execute that RTC_CHECK.",
      "parentUuid": "0a30a4b5_35efe25e",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88ede450_adce8708",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 191,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-10-20T07:36:09Z",
      "side": 1,
      "message": "I don\u0027t see an implementation for these methods actually - is it just for discussion?",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ecac4c98_d5a951e5",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 202,
      "author": {
        "id": 6720
      },
      "writtenOn": "2021-10-19T18:37:51Z",
      "side": 1,
      "message": "it would be nice to be consistent with the return type. const char* works with printf() style formatting, but std::string doesn\u0027t, so they could easily be mixed up, but with potentially bad results.",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c07fe062_f10d0175",
        "filename": "api/peer_connection_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 202,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-10-19T20:26:14Z",
      "side": 1,
      "message": "Consistency will arrive once we decide what we\u0027re consistent on.",
      "parentUuid": "ecac4c98_d5a951e5",
      "revId": "5bf9cbb84a048f9ab937d99d86afa8da3f8c524d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}