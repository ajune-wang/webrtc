{
  "comments": [
    {
      "key": {
        "uuid": "4fae81e6_00941130",
        "filename": "media/engine/webrtcvideoengine.cc",
        "patchSetId": 3
      },
      "lineNbr": 1490,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-09-24T15:10:15Z",
      "side": 1,
      "message": "This spec says \"The browser MUST keep information from RTP packets received in the previous 10 seconds.\" Is there any way that receive_streams_ may be modified such that history is erased? If so, when?",
      "revId": "cc8d4524f44a7c350f60dd12fa3ebef8d7cd5c9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea957b86_641a13f8",
        "filename": "media/engine/webrtcvideoengine.cc",
        "patchSetId": 3
      },
      "lineNbr": 1490,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-09-25T08:35:32Z",
      "side": 1,
      "message": "After a quick search, it seems streams can be destroyed on call to PeerConnection::SetRemoteDescription, and from the logic for unsignalled streams (which I don\u0027t quite understand).\n\nI guess there are a couple of cases:\n\n1. A stream is destroyed and recreated with the same ssrc. In this case, history is lost. Maybe it should be retained in some way, but I wouldn\u0027t expect much of practical problems?\n\n2. Asking for GetSources() on an ssrc that has no associated stream object, but might have had one less than 10s ago. Do the web apis provide a way to do that? Can we have a w3c RtpReceiver without a corresponding stream in webrtcvideoengine?\n\nOr generally, keeping stats for *all* received rtp packets, even if we discard them without passing them on to any stream. We could do that somewhere close to the RTP demuxer, but we\u0027d need some limits to not exhaust memory if we receive evil packets using a huge number of distinct ssrcs.",
      "parentUuid": "4fae81e6_00941130",
      "revId": "cc8d4524f44a7c350f60dd12fa3ebef8d7cd5c9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a2811e38_3568cd31",
        "filename": "media/engine/webrtcvideoengine.cc",
        "patchSetId": 3
      },
      "lineNbr": 1490,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-09-25T08:35:32Z",
      "side": 1,
      "message": "This could also be \"return {}\", right?",
      "range": {
        "startLine": 1490,
        "startChar": 11,
        "endLine": 1490,
        "endChar": 43
      },
      "revId": "cc8d4524f44a7c350f60dd12fa3ebef8d7cd5c9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1081f4c2_a1155271",
        "filename": "media/engine/webrtcvideoengine_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 984,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-09-24T15:10:15Z",
      "side": 1,
      "message": "nit: Should we use rtc::SetClockForTesting() to ensure the source is not removed even if the bot freezes for 10s?",
      "revId": "cc8d4524f44a7c350f60dd12fa3ebef8d7cd5c9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1bf0e502_2c061062",
        "filename": "media/engine/webrtcvideoengine_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 985,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-09-24T15:10:15Z",
      "side": 1,
      "message": "Can we add a test on this layer that tests the case where the SSRC does exist?\n\nRegardless of layers, the following behaviors would be nice to test:\n- Injecting an RTP packet should add a source.\n- Injecting another RTP packet should update the timestamp.\n- Advancing time by 10s should remove the source.\n- Is SSRC switching a valid use case that should be tested? See other comment.",
      "revId": "cc8d4524f44a7c350f60dd12fa3ebef8d7cd5c9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b7ee532_ae16dcd7",
        "filename": "pc/peerconnection_integrationtest.cc",
        "patchSetId": 3
      },
      "lineNbr": 4322,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-09-24T15:10:15Z",
      "side": 1,
      "message": "Nitty but: What do you think about splitting this up into two tests? Avoiding loops and testing audio and video behaviors separately makes test failures more explicit (which media type failed, which actual line). Code reusibility is a lesser concern inside of tests, but you do end up with two almost identical tests.",
      "revId": "cc8d4524f44a7c350f60dd12fa3ebef8d7cd5c9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd03aefa_27b570d7",
        "filename": "pc/peerconnection_integrationtest.cc",
        "patchSetId": 3
      },
      "lineNbr": 4333,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-09-24T13:31:58Z",
      "side": 1,
      "message": "Maybe this part (and the below expectations on |audio_receiver| and |video_receiver|) could be written more clearly with std::any_of.",
      "range": {
        "startLine": 4320,
        "startChar": 0,
        "endLine": 4333,
        "endChar": 5
      },
      "revId": "cc8d4524f44a7c350f60dd12fa3ebef8d7cd5c9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "77b303ee_637f4b87",
        "filename": "video/rtp_video_stream_receiver.cc",
        "patchSetId": 3
      },
      "lineNbr": 685,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-09-24T15:10:15Z",
      "side": 1,
      "message": "This assumes we only ever have one SSRC per receiver. Is this correct? I thought it was possible for multiple SSRCs to go to the same receiver, like special codecs or multiple layers or other magic? +hta\n\nIf so I\u0027m wondering if we need ContributingSources to be a helper class for both SSRCs and CSRCs (renaming it RtpSourcesRecord or something) so that we can do this above where we now only update contributing_sources_:\nsynchronization_sources_.Update(now_ms, {packet.Ssrc()});",
      "revId": "cc8d4524f44a7c350f60dd12fa3ebef8d7cd5c9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}