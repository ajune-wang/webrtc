{
  "comments": [
    {
      "key": {
        "uuid": "cebbac40_0bff819f",
        "filename": "sdk/android/api/org/webrtc/EncodedImage.java",
        "patchSetId": 1
      },
      "lineNbr": 61,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T11:19:11Z",
      "side": 1,
      "message": "I would prefer to have ref counting here that gets called from C++ code. You can use RefCountDelegate",
      "range": {
        "startLine": 61,
        "startChar": 14,
        "endLine": 61,
        "endChar": 21
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62e8410b_965e34ce",
        "filename": "sdk/android/api/org/webrtc/EncodedImage.java",
        "patchSetId": 1
      },
      "lineNbr": 149,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-14T07:11:55Z",
      "side": 1,
      "message": "Is there a more direct way to have an optional argument? I\u0027m not so familiar with java.\n\nI\u0027m thinking that since the buffer and release callback are intimately connected, it makes sense to pass them together to the Builder. But I could change to a separate setReleaseCallback method if you prefer.",
      "range": {
        "startLine": 140,
        "startChar": 0,
        "endLine": 149,
        "endChar": 5
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4f2c836_709bde85",
        "filename": "sdk/android/api/org/webrtc/EncodedImage.java",
        "patchSetId": 1
      },
      "lineNbr": 149,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T11:19:11Z",
      "side": 1,
      "message": "Optional arguments are not a feature in Java. I was expecting setReleaseCallback to be separate but I guess this makes sense also. I would like to have documentation clarifying that if there is no release callback the buffer is expected to be valid indefinitely.",
      "parentUuid": "62e8410b_965e34ce",
      "range": {
        "startLine": 140,
        "startChar": 0,
        "endLine": 149,
        "endChar": 5
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b4390d10_7b75b786",
        "filename": "sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java",
        "patchSetId": 1
      },
      "lineNbr": 494,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T11:19:11Z",
      "side": 1,
      "message": "This invalidates previous buffers:\nAfter calling this method, any ByteBuffers previously returned by an earlier call to this method MUST no longer be used.",
      "range": {
        "startLine": 494,
        "startChar": 43,
        "endLine": 494,
        "endChar": 59
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4955413_75be7ed3",
        "filename": "sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java",
        "patchSetId": 1
      },
      "lineNbr": 494,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-14T12:13:12Z",
      "side": 1,
      "message": "Hmm. I was expecting that we could get ByteBuffer with index 0, pass it to C++ which may hold on to it for some time (eventually calling releaseOutputBuffer(0), and in the mean time get another frame in the buffer with index 1, and start processing it. If that\u0027s not how it works, I\u0027d need to get back to the basics to understand how to do this.",
      "parentUuid": "b4390d10_7b75b786",
      "range": {
        "startLine": 494,
        "startChar": 43,
        "endLine": 494,
        "endChar": 59
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72f879d5_721eaa83",
        "filename": "sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java",
        "patchSetId": 1
      },
      "lineNbr": 494,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T12:24:00Z",
      "side": 1,
      "message": "We should cache the array returned by getOutputBuffers. Additionally we must check for INFO_OUTPUT_BUFFERS_CHANGED events. In this case, we must wait that all output buffers have been released and then call getOutputBuffers again.",
      "parentUuid": "e4955413_75be7ed3",
      "range": {
        "startLine": 494,
        "startChar": 43,
        "endLine": 494,
        "endChar": 59
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8011bb76_5d152604",
        "filename": "sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java",
        "patchSetId": 1
      },
      "lineNbr": 494,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-14T12:34:31Z",
      "side": 1,
      "message": "Is there some code for the old AndroidMediaEncoder that I could look at for caching and refreshing the buffer list? \n\nFor waiting, we\u0027d need a count for buffers in flight and condition variable (with some associated mutex) to block on. Any example on how to do that in java?",
      "parentUuid": "72f879d5_721eaa83",
      "range": {
        "startLine": 494,
        "startChar": 43,
        "endLine": 494,
        "endChar": 59
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df01e57e_36296cf1",
        "filename": "sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java",
        "patchSetId": 1
      },
      "lineNbr": 494,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T12:47:25Z",
      "side": 1,
      "message": "It is handled here:\nhttps://cs.corp.google.com/piper///depot/google3/third_party/webrtc/files/stable/webrtc/sdk/android/api/org/webrtc/MediaCodecVideoEncoder.java?g\u003d0\u0026l\u003d1013\n\nI don\u0027t we\u0027ve ever had a situation where we hold the buffer from indeterminate amount of time so there isn\u0027t code for waiting for them to be released.\n\nFor mutex you can use any plain old Object. It has the necessary method for the implementation (wait, notifyAll).",
      "parentUuid": "8011bb76_5d152604",
      "range": {
        "startLine": 494,
        "startChar": 43,
        "endLine": 494,
        "endChar": 59
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "28805664_525d14fa",
        "filename": "sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java",
        "patchSetId": 1
      },
      "lineNbr": 494,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-14T13:01:08Z",
      "side": 1,
      "message": "https://cs.corp.google.com/piper///depot/google3/third_party/webrtc/files/stable/webrtc/sdk/android/api/org/webrtc/MediaCodecVideoEncoder.java?g\u003d0\u0026l\u003d1013\n\u003e \n\u003e I don\u0027t we\u0027ve ever had a situation where we hold the buffer from indeterminate amount of time so there isn\u0027t code for waiting for them to be released.\n\nHmm, does that mean that this code needs to be fixed to handle that case, before https://webrtc-review.googlesource.com/c/src/+/138820 can be landed? (Or to not have to do that, drop the change to AndroidMediaEncoder, and keep the copying).\n\n\u003e For mutex you can use any plain old Object. It has the necessary method for the implementation (wait, notifyAll).\n\nSo I don\u0027t need the Condition object, https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/locks/Condition.html?",
      "parentUuid": "df01e57e_36296cf1",
      "range": {
        "startLine": 494,
        "startChar": 43,
        "endLine": 494,
        "endChar": 59
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f36d067d_cbc3e0e7",
        "filename": "sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java",
        "patchSetId": 1
      },
      "lineNbr": 547,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T11:19:11Z",
      "side": 1,
      "message": "I think we need to wait for all output buffers to be released here.",
      "range": {
        "startLine": 547,
        "startChar": 12,
        "endLine": 547,
        "endChar": 16
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c340e197_45268424",
        "filename": "sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java",
        "patchSetId": 1
      },
      "lineNbr": 547,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-14T12:13:12Z",
      "side": 1,
      "message": "Why? I would expect the codec to lose interest in the buffers, while the gc will ensure that they are kept alive as long as there are other references to it (C++ object holds a reference to java EncodedImage which holds a reference to the buffer). But I don\u0027t really understand the HW encoder apis.\n\nWe\u0027d have to ensure that the eventual call to releaseOutputBuffer is a no-op, so that we don\u0027t crash trying to call releaseOutputBuffer on a stale codec. Does the spec for android.media.MediaCodec say what happens if one calls releaseOutputBuffer after stop() and release() ? If not, we might need some logic of our own to handle that safely.",
      "parentUuid": "f36d067d_cbc3e0e7",
      "range": {
        "startLine": 547,
        "startChar": 12,
        "endLine": 547,
        "endChar": 16
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed8a88c0_460e898c",
        "filename": "sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java",
        "patchSetId": 1
      },
      "lineNbr": 547,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T12:24:00Z",
      "side": 1,
      "message": "Since output buffers can only be returned after start() has been called. There is no explicit mention what happens when stop() is called but I would not trust various implementations out there all handle this is in a way that the references are still valid.\n\nByteBuffers are special and may be backed by memory that is not handled through GC.",
      "parentUuid": "c340e197_45268424",
      "range": {
        "startLine": 547,
        "startChar": 12,
        "endLine": 547,
        "endChar": 16
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4770fceb_9ff95272",
        "filename": "sdk/android/src/java/org/webrtc/VideoEncoderWrapper.java",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T11:19:11Z",
      "side": 1,
      "message": "I would prefer logic where this is retained if needed and there is no need to release otherwise. Encoder should release the buffer after passing it to the callback.",
      "range": {
        "startLine": 43,
        "startChar": 6,
        "endLine": 45,
        "endChar": 22
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b84c55c_9593d5f1",
        "filename": "sdk/android/src/java/org/webrtc/VideoEncoderWrapper.java",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-14T12:13:12Z",
      "side": 1,
      "message": "Hmm. Are you suggesting that the java object will have it\u0027s own explicit reference count managed with retain() and release() methods, and call releaseCallback when it goes down to zero?",
      "parentUuid": "4770fceb_9ff95272",
      "range": {
        "startLine": 43,
        "startChar": 6,
        "endLine": 45,
        "endChar": 22
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "913380b0_a898657f",
        "filename": "sdk/android/src/java/org/webrtc/VideoEncoderWrapper.java",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T12:24:00Z",
      "side": 1,
      "message": "Yes, this matches how we handle video buffers.",
      "parentUuid": "2b84c55c_9593d5f1",
      "range": {
        "startLine": 43,
        "startChar": 6,
        "endLine": 45,
        "endChar": 22
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "370507bf_e805be57",
        "filename": "sdk/android/src/jni/encoded_image.cc",
        "patchSetId": 1
      },
      "lineNbr": 38,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T11:19:11Z",
      "side": 1,
      "message": "Literal comment and maybe add a comment about optimizing this to remove the unnecessary copy? (We can reference the C++ buffer and release it from Java.)",
      "range": {
        "startLine": 38,
        "startChar": 19,
        "endLine": 38,
        "endChar": 56
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe83934c_6e572a76",
        "filename": "sdk/android/src/jni/encoded_image.cc",
        "patchSetId": 1
      },
      "lineNbr": 38,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-14T12:13:12Z",
      "side": 1,
      "message": "Agree it would be nice to share without copy here too. How would that work? One would create a DirectByteBuffer pointing directly into a refcounted C++ EncodedImageBufferInterface, and let the java code manage a reference to it?",
      "parentUuid": "370507bf_e805be57",
      "range": {
        "startLine": 38,
        "startChar": 19,
        "endLine": 38,
        "endChar": 56
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e683f90_a65cc46b",
        "filename": "sdk/android/src/jni/encoded_image.cc",
        "patchSetId": 1
      },
      "lineNbr": 38,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-14T12:24:00Z",
      "side": 1,
      "message": "Yeah, we would inject a custom callback here that frees the C++ memory.",
      "parentUuid": "fe83934c_6e572a76",
      "range": {
        "startLine": 38,
        "startChar": 19,
        "endLine": 38,
        "endChar": 56
      },
      "revId": "d214340b9857f340a56fedb07c84edfe3cb833cd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}