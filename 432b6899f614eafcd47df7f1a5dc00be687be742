{
  "comments": [
    {
      "key": {
        "uuid": "041bb1c3_62c302b2",
        "filename": "api/video_codecs/builtin_video_encoder_factory.cc",
        "patchSetId": 8
      },
      "lineNbr": 1,
      "author": {
        "id": 5053
      },
      "writtenOn": "2018-04-25T22:35:33Z",
      "side": 1,
      "message": "I don\u0027t have a strong opinion about this, but based on previous discussions and the \"slim and modular\" design doc, I thought the implementation of factory methods was going to live outside of api/? That\u0027s what we did with CreatePeerConnectionFactory. Though apparently not CreateBuiltinAudioDecoderFactory. Looking for someone else to chime in here.",
      "revId": "432b6899f614eafcd47df7f1a5dc00be687be742",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f2d09d6a_f3e11135",
        "filename": "api/video_codecs/builtin_video_encoder_factory.cc",
        "patchSetId": 8
      },
      "lineNbr": 1,
      "author": {
        "id": 5126
      },
      "writtenOn": "2018-04-26T08:30:43Z",
      "side": 1,
      "message": "My position is basically this: (1) If users should call the factory function, it should be declared somewhere in api/. (2) Because https://chromium.googlesource.com/external/webrtc/+/HEAD/style-guide.md#h-cc-pairs, the factory function\u0027s definition will also be in api/. (3) However, it\u0027s nice to not have tons of implementation lines in .cc files in api/, so it can be nice to just have a stub implementation that calls a real implementation that\u0027s outside api/.\n\nThe \"slim and modular\" part of the equation is handled by making sure that only users, not other parts of WebRTC, depend on the factory function\u0027s target (and thus transitively on the perhaps large implementation behind it). The \"poison\" thing I announced recently can help with that; in short, you would tag the large implementation target(s) as poisonous, and then ensure that pretty much no other target except the factory function in api/ has to be made immune to the poison.",
      "parentUuid": "041bb1c3_62c302b2",
      "revId": "432b6899f614eafcd47df7f1a5dc00be687be742",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ebb8a2bd_a3e00c88",
        "filename": "pc/peerconnection_integrationtest.cc",
        "patchSetId": 8
      },
      "lineNbr": 611,
      "author": {
        "id": 5053
      },
      "writtenOn": "2018-04-25T22:35:33Z",
      "side": 1,
      "message": "This fake factory isn\u0027t actually used unless EnableVideoDecoderFactory is called, which only one (disabled) test does.\n\nThis previously was making use of the fact that if you pass in an \"external\" factory, the \"internal\" factory will still be used as a backup. Assuming that functionality will be going away soon (meaning, what you pass into CreatePeerConnectionFactory is all you get), don\u0027t we need some \"combination internal + external factory\" helper class to bridge the gap?\n\nOh, I see... FakeWebRtcVideoDecoderFactory now does that itself. That\u0027s surprising to me, though; I wouldn\u0027t expect a \"fake factory\" to create a \"real\" instance if it can\u0027t create a fake.\n\nHow about adding a \"CombinedWebRtcVideoDecoderFactory\" helper class, that takes \"software\" and \"hardware\" factories as input? It looks like this is what \"EncoderAdapter\"/\"DecoderAdapter\" currently do (also handling the \"software fallback\" and \"simulcast adapter\" part).\n\nBeyond this test, I imagine any application that\u0027s currently injecting an \"external factory\" would want to use that helper class as well, to get the same behavior it\u0027s used to getting. Meaning if they\u0027re currently doing:\n\nCreatePeerConnectionFactory(\n    ...,\n    new MyHardwareEncoderFactory(),\n    ...);\n\nThey can switch to:\n\nCreatePeerConnectionFactory(\n    ...,\n    rtc::MakeUnique\u003cCombinedWebRtcVideoEncoderFactory\u003e(\n        webrtc::CreateBuiltinVideoEncoderFactory(),\n        rtc::MakeUnique\u003cMyHardwareEncoderFactory\u003e()),\n    ...);",
      "revId": "432b6899f614eafcd47df7f1a5dc00be687be742",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9a64adb1_69b1f590",
        "filename": "pc/peerconnection_integrationtest.cc",
        "patchSetId": 8
      },
      "lineNbr": 611,
      "author": {
        "id": 5249
      },
      "writtenOn": "2018-04-26T08:58:50Z",
      "side": 1,
      "message": "Yes you\u0027re completely right. The webrtcvideoengine_unittest.cc use the FakeWebRtcVideoDecoderFactory as an \"external\" factory in the old sense, relying on the fact that the built-in software codecs are appended to the codec factory somewhere on the way after passing the factory to the VideoEngine constructor. Since we now use the new VideoEngine constructor that takes webrtc::VideoDecoderFactory instead of cricket::WebRtcVideoDecoderFactory, we no longer wrap our factories in the adapters, and what we pass in is all we get. To make all the tests pass, I moved this functionality to FakeWebRtcVideoDecoderFactory. So these tests no longer actually test the behaviour of the video engine, but of these fake factories, which is obviously bad (see previous discussion in this CL with magjed). I plan on making a follow-up CL that removes the internal factories from the FakeWebRtcVideoDecoderFactory and changes any tests that rely on this functionality. But I wanted to keep the changes to the tests small in this CL to keep it manageable.\n\nFor clients who want to inject their own codec implementations we generally expect them to create their own video codec factory implementations as well (which makes it up to the client which software codecs they want to support, how to prioritize the codecs, whether they want to wrap encoders in software fallback wrappers, etc). The CombinedWebRtcVideoEncoderFactory sounds like a nice idea for migrating though, not sure how common this case is in the wild? Maybe it can be in its own CL as well?",
      "parentUuid": "ebb8a2bd_a3e00c88",
      "revId": "432b6899f614eafcd47df7f1a5dc00be687be742",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f08b1662_11488109",
        "filename": "pc/peerconnection_integrationtest.cc",
        "patchSetId": 8
      },
      "lineNbr": 611,
      "author": {
        "id": 5053
      },
      "writtenOn": "2018-05-01T18:04:29Z",
      "side": 1,
      "message": "\u003e I plan on making a follow-up CL that removes the internal factories from the FakeWebRtcVideoDecoderFactory and changes any tests that rely on this functionality. But I wanted to keep the changes to the tests small in this CL to keep it manageable.\n\nOk; in that case can you add a TODO in FakeWebRtcVideoDecoderFactory?\n\n\u003e For clients who want to inject their own codec implementations we generally expect them to create their own video codec factory implementations as well (which makes it up to the client which software codecs they want to support, how to prioritize the codecs, whether they want to wrap encoders in software fallback wrappers, etc).\n\nIn my opinion, the documentation in the code doesn\u0027t make this clear enough. There are comments that say things like \"these video factories represents all video codecs\", but it\u0027s not obvious that this also means you don\u0027t get simulcast support or software fallback like the previous CreatePeerConnectionFactory method provides. I\u0027d recommend adding more comments to explain the differences.",
      "parentUuid": "9a64adb1_69b1f590",
      "revId": "432b6899f614eafcd47df7f1a5dc00be687be742",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}