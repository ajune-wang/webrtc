{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "ac80452b_fcc89f3e",
        "filename": "modules/pacing/pacing_controller_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 29,
      "author": {
        "id": 5019
      },
      "writtenOn": "2022-03-16T10:39:29Z",
      "side": 1,
      "message": "These days Invoke helper is rarely useful.",
      "range": {
        "startLine": 29,
        "startChar": 17,
        "endLine": 29,
        "endChar": 23
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c4fc48b9_2c8cc32b",
        "filename": "modules/pacing/pacing_controller_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 457,
      "author": {
        "id": 5019
      },
      "writtenOn": "2022-03-16T10:39:29Z",
      "side": 1,
      "message": "Invoke is not needed: WillOnce can understand lambda directly\n\nif the reason is to avoid parameters, then it is clearer to use testing::WithoutArgs \n\nEXPECT_CALL(...).WillOnce(WithoutArgs([\u0026] { ... }));",
      "range": {
        "startLine": 457,
        "startChar": 46,
        "endLine": 457,
        "endChar": 52
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f37d4bab_b000b800",
        "filename": "modules/pacing/pacing_controller_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 457,
      "author": {
        "id": 5524
      },
      "writtenOn": "2022-03-16T16:41:52Z",
      "side": 1,
      "message": "Ah, yes that\u0027s what I wanted. Thanks!",
      "parentUuid": "c4fc48b9_2c8cc32b",
      "range": {
        "startLine": 457,
        "startChar": 46,
        "endLine": 457,
        "endChar": 52
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93e32c06_884e74d4",
        "filename": "modules/pacing/task_queue_paced_sender.cc",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 5019
      },
      "writtenOn": "2022-03-16T10:39:29Z",
      "side": 1,
      "message": "not needed, destructor would delete this pointer anyway\n\ndid you intent to call task_safety_-\u003eSetNotAlive() instead when owned_task_queue_ \u003d\u003d nullptr? (and thus force destructor to run on the same task_queue_ unless it uses its own)",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 28
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5f383329_2d3c50ad",
        "filename": "modules/pacing/task_queue_paced_sender.cc",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 5524
      },
      "writtenOn": "2022-03-16T16:41:52Z",
      "side": 1,
      "message": "I was thinking I wanted any pending tasks to be destroyed before we start tearing down this class for real. But I guess we don\u0027t really have any with the that member at the end...\n\nI\u0027m having problems with the task safeties in that they are constructed and used on a few different threads. I think it might be better to just document that the task queue used must be destroyed before the pacer is.",
      "parentUuid": "93e32c06_884e74d4",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 28
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9c5e386_1aaa009e",
        "filename": "modules/pacing/task_queue_paced_sender.cc",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 5019
      },
      "writtenOn": "2022-03-16T17:26:50Z",
      "side": 1,
      "message": "Generally I do not like such kind of requirement, normally destruction order should be reverse to the construction order, but here you\u0027re forcing the opposite.\nThat makes this class less flexible (e.g. can\u0027t use long live TQ for the pacer), and less safe (need to manually check that between TQ destruction and PacedSender destruction the latter is not used and thus doesn\u0027t try to post to the destroyed TQ)\n\nIs it possible to ensure TaskQueuedPacedSender is destroyed on the same task_queue_ as passed during construction? [unless it has owned_task_queue_],\ni.e. then destructor might call\n  if (owned_task_queue_ \u003d\u003d nullptr) {\n    task_safety_-\u003eSetNotAlive();\n  }\n  \nalternative pattern is to post destruction of the pacer to the TQ:\n(similar to \nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/rtp_rtcp/source/rtcp_transceiver.cc;l\u003d33)\n\n  class TaskQueuePacedSender {\n   public:\n     // should be used instead of destructor\n     void DeleteMe() {\n       absl::Cleanup delete_me \u003d [this] { delete this; }\n       task_queue_-\u003ePostTask(ToQueuedTask([task_safety_ \u003d task_safety_, delete_me \u003d \nstd::move(delete_me)] {task_safety_-\u003eSetNotAlive();}));\n     }\n   private:\n     ~TaskQueuePacedSender() \u003d default;\n  }\n\nWith such pattern destruction should be correct if TQ destroyed right after the TaskQueuePacedSender and the posted task didn\u0027t had chance to run,\nand it also should be correct if TQ greatly outlives the TaskQueuePacedSender.\n\n(however this pattern put requirement that TQ passed in the constructor must outlive TaskQueuedPacedSender, however such requirement I find natural)\n\n[in this case it seems it would work to put reverse lifetime requirement, however it is almost the same as make TaskQueuedPacedSender own task queue, but less safe]",
      "parentUuid": "5f383329_2d3c50ad",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 28
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "81ddc76a_85daf837",
        "filename": "modules/pacing/task_queue_paced_sender.cc",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 5524
      },
      "writtenOn": "2022-03-17T10:44:52Z",
      "side": 1,
      "message": "Good points. I\u0027ve added the task safety back.\nI faced two problems:\n1. Need to make sure the teardwon task has been run before actually destroying the TaskQueuePacer, didn\u0027t see a way around a sync wait there...\n2. In RtpTransportControllerSend, we now also need a teardown task for the repeating task handles - otherwise they might try to use the pacer before the task queue is stopped. A workaround could be to always just check if pacer() is nullptr before derereferencing, but that\u0027s not very pretty either...\n\nthoughts?",
      "parentUuid": "d9c5e386_1aaa009e",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 28
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6065eae8_021f55db",
        "filename": "modules/pacing/task_queue_paced_sender.cc",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 5019
      },
      "writtenOn": "2022-03-17T11:25:14Z",
      "side": 1,
      "message": "it is far from trivial to properly stop multi-threadred object [since you give out control of the life time of the task queue]\n\nwhen owned_task_queue_ !\u003d nullptr, then there is no need to call task_safety_-\u003eSetNotAlive(); (destructor would delete task queue and block if any task is running.... almost, see next point, but might be ok to keep that edge case because that owned_task_queue_ should disapper soon enough).\n\nwhen destructor called not on the task queue, technically it is already too late to call SetNotAlive: at that point is is already a mistake to use TaskQueuePacedSender. some ongoing task might do that through [this] capture. (when destructor is running, virtual table is already changed, so calling virtual function can easily crash. calling non-virtual functions might work, but still an UB)\n\nwhen destructor called on the task queue, you can be sure no other tasks running same time on the same task queue and thus it is generally safer, but it seems you can\u0027t guarantee that here.\n\none idea is to avoid capturing this, ever, instead capture pointers to individual needed members. Then you can be sure they are still not destroyed while running the destructor. though that is not full solution, but it allowes to implement everything with the destructor.\n\nanother solution is to avoid stopping in destructor, use some other function instead [that\u0027s the pattern I\u0027m using in RtcpTransceiver], thus was proposoal to make destructor private and use dedicated function to delete the TaskQueuePacedSender.\ncaveat there - such destruction is a-synchronous, so after the function returns, TaskQueuePacedSender still might be alive and still may try to use classes it depends on [e.g. PacketSender]\n\n\nOne more solution is to introduce thread-safe safety flag, the one you may call from any thread/task queue (I have a draft: https://webrtc-review.googlesource.com/c/src/+/169341 ), but that one comes with extra cost per task.",
      "parentUuid": "81ddc76a_85daf837",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 28
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4d7b538_8b6bf7fe",
        "filename": "modules/pacing/task_queue_paced_sender.cc",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 5524
      },
      "writtenOn": "2022-03-17T12:20:03Z",
      "side": 1,
      "message": "\u003e it is far from trivial to properly stop multi-threadred object [since you give out control of the life time of the task queue]\n\nIndeed, far harder than I anticipated...\n\n\u003e when owned_task_queue_ !\u003d nullptr, then there is no need to call task_safety_-\u003eSetNotAlive(); (destructor would delete task queue and block if any task is running.... almost, see next point, but might be ok to keep that edge case because that owned_task_queue_ should disapper soon enough).\n\nRight, I thought I\u0027d just keep it since it\u0027s going away and it should not hurt anything.\n \n\u003e when destructor called not on the task queue, technically it is already too late to call SetNotAlive: at that point is is already a mistake to use TaskQueuePacedSender. some ongoing task might do that through [this] capture. (when destructor is running, virtual table is already changed, so calling virtual function can easily crash. calling non-virtual functions might work, but still an UB)\n\nYou\u0027re talking about TaskQueuePacedSender\u0027s destructor, right? We could still add a Stop() method that needs to be called prior to destruction to work around that?\n\n\u003e when destructor called on the task queue, you can be sure no other tasks running same time on the same task queue and thus it is generally safer, but it seems you can\u0027t guarantee that here.\n\n\u003e one idea is to avoid capturing this, ever, instead capture pointers to individual needed members. Then you can be sure they are still not destroyed while running the destructor. though that is not full solution, but it allowes to implement everything with the destructor.\n\nThat\u0027s going to be complex, looking at the code... \n\n\u003e another solution is to avoid stopping in destructor, use some other function instead [that\u0027s the pattern I\u0027m using in RtcpTransceiver], thus was proposoal to make destructor private and use dedicated function to delete the TaskQueuePacedSender.\n\u003e caveat there - such destruction is a-synchronous, so after the function returns, TaskQueuePacedSender still might be alive and still may try to use classes it depends on [e.g. PacketSender]\nThat, and making the destructor private means we can\u0027t allocate it on the stack anymore. Would break downstream code.\n\n\u003e \n\u003e One more solution is to introduce thread-safe safety flag, the one you may call from any thread/task queue (I have a draft: https://webrtc-review.googlesource.com/c/src/+/169341 ), but that one comes with extra cost per task.\n\nHm, that would make things easier for sure...",
      "parentUuid": "6065eae8_021f55db",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 28
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a218eff2_0315ebed",
        "filename": "modules/pacing/task_queue_paced_sender.cc",
        "patchSetId": 5
      },
      "lineNbr": 73,
      "author": {
        "id": 5524
      },
      "writtenOn": "2022-03-17T12:45:30Z",
      "side": 1,
      "message": "I\u0027m giving up (for now) and reducing this CL to just cleaning up the constructor.\nProbably good to do separately anyway.\nWe\u0027ll see if we get back to this - the OnSentPacket() calls have been removed anyway so interaction between theses two threads isn\u0027t as intense as before.",
      "parentUuid": "f4d7b538_8b6bf7fe",
      "range": {
        "startLine": 73,
        "startChar": 0,
        "endLine": 73,
        "endChar": 28
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "72a5a892_46400edf",
        "filename": "modules/pacing/task_queue_paced_sender.h",
        "patchSetId": 5
      },
      "lineNbr": 172,
      "author": {
        "id": 5019
      },
      "writtenOn": "2022-03-16T10:39:29Z",
      "side": 1,
      "message": "can it ever be nullptr?\nif not, may be use reference:\nTaskQueueBase\u0026 task_queue_",
      "range": {
        "startLine": 172,
        "startChar": 15,
        "endLine": 172,
        "endChar": 22
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "890a4bfb_c64b186f",
        "filename": "modules/pacing/task_queue_paced_sender.h",
        "patchSetId": 5
      },
      "lineNbr": 172,
      "author": {
        "id": 5524
      },
      "writtenOn": "2022-03-16T16:41:52Z",
      "side": 1,
      "message": "I cannot, changed to reference.",
      "parentUuid": "72a5a892_46400edf",
      "range": {
        "startLine": 172,
        "startChar": 15,
        "endLine": 172,
        "endChar": 22
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c5af42f_22a1d453",
        "filename": "modules/pacing/task_queue_paced_sender.h",
        "patchSetId": 5
      },
      "lineNbr": 173,
      "author": {
        "id": 5019
      },
      "writtenOn": "2022-03-16T10:39:29Z",
      "side": 1,
      "message": "I see you reference this flag, but I do not see a call to SetNotAlive function, which makes this flag useless.\nDid you intent to use ScopedTaskSafety instead? (that calls SetNotAlive on destruction)",
      "range": {
        "startLine": 173,
        "startChar": 44,
        "endLine": 173,
        "endChar": 56
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d2e3d7ea_38011a3a",
        "filename": "modules/pacing/task_queue_paced_sender.h",
        "patchSetId": 5
      },
      "lineNbr": 173,
      "author": {
        "id": 5524
      },
      "writtenOn": "2022-03-16T16:41:52Z",
      "side": 1,
      "message": "See comment above.",
      "parentUuid": "5c5af42f_22a1d453",
      "range": {
        "startLine": 173,
        "startChar": 44,
        "endLine": 173,
        "endChar": 56
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22de9f66_cf20ceb8",
        "filename": "modules/pacing/task_queue_paced_sender_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 162,
      "author": {
        "id": 5019
      },
      "writtenOn": "2022-03-16T10:39:29Z",
      "side": 1,
      "message": "probably it is cleaner to write \nauto task_queue \u003d time_controller....;\n\n(side note: using auto instead of exact type is questionable here, but I\u0027m ok with the auto. I think exact type is too long and not that important for understanding tests)",
      "range": {
        "startLine": 162,
        "startChar": 17,
        "endLine": 162,
        "endChar": 18
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "df49904e_5897a47f",
        "filename": "modules/pacing/task_queue_paced_sender_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 162,
      "author": {
        "id": 5524
      },
      "writtenOn": "2022-03-16T16:41:52Z",
      "side": 1,
      "message": "Done.\n\nAgree, I think this case is border-line. But the type _is_ quite verbose and it\u0027s repeated quite a lot in this test code, so felt it was ok.",
      "parentUuid": "22de9f66_cf20ceb8",
      "range": {
        "startLine": 162,
        "startChar": 17,
        "endLine": 162,
        "endChar": 18
      },
      "revId": "a03ac82e3180cb35cf2c239ca1617e985cb98322",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}