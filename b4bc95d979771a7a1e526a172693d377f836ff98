{
  "comments": [
    {
      "key": {
        "uuid": "c8711ad9_d61561bc",
        "filename": "p2p/base/p2p_transport_channel.cc",
        "patchSetId": 4
      },
      "lineNbr": 847,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-03T19:49:11Z",
      "side": 1,
      "message": "Does this mean for forking, the IceGatherer never wrappers a pooled session? I am asking because the pooled session is created when creating the pc and happens before CreateGatherer IIUC.",
      "range": {
        "startLine": 847,
        "startChar": 18,
        "endLine": 847,
        "endChar": 31
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e21b56a_1797a599",
        "filename": "p2p/base/p2p_transport_channel.cc",
        "patchSetId": 4
      },
      "lineNbr": 847,
      "author": {
        "id": 5659
      },
      "writtenOn": "2020-01-06T17:08:28Z",
      "side": 1,
      "message": "Correct.  Pooled sessions and gatherers are completely separate.  I doubt anyone would ever use both pooled sessions and gatherers together, though.  If anyone cared about having the gatherer\u0027s start gathering before SLD is called, we could add a Start() method on the IceGatherer (which is something ORTC has).",
      "parentUuid": "c8711ad9_d61561bc",
      "range": {
        "startLine": 847,
        "startChar": 18,
        "endLine": 847,
        "endChar": 31
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0b0cf219_a9d55f8b",
        "filename": "p2p/base/p2p_transport_channel.cc",
        "patchSetId": 4
      },
      "lineNbr": 847,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-06T19:54:30Z",
      "side": 1,
      "message": "Ack. If we add this later, it then seems start() in RTCIceTransport would be delegated if we have gatherer.",
      "parentUuid": "8e21b56a_1797a599",
      "range": {
        "startLine": 847,
        "startChar": 18,
        "endLine": 847,
        "endChar": 31
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2a466f41_66f1cd41",
        "filename": "p2p/base/p2p_transport_channel.cc",
        "patchSetId": 4
      },
      "lineNbr": 878,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-03T19:49:11Z",
      "side": 1,
      "message": "Just want to double check we expect |disable_equivalent| should do the dedup for this call.",
      "range": {
        "startLine": 878,
        "startChar": 11,
        "endLine": 878,
        "endChar": 28
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a996e2e_5af30ddb",
        "filename": "p2p/base/p2p_transport_channel.cc",
        "patchSetId": 4
      },
      "lineNbr": 878,
      "author": {
        "id": 5659
      },
      "writtenOn": "2020-01-06T17:08:28Z",
      "side": 1,
      "message": "Yes, I was relying on StartGettingPorts being a no-op after the first call.  If that\u0027s not true, or we don\u0027t want to rely on it being true, we can put a bool in the IceGatherer object with an IceGatherer::Start() method that checks it and then call IceGatherer-\u003eStart here as well.",
      "parentUuid": "2a466f41_66f1cd41",
      "range": {
        "startLine": 878,
        "startChar": 11,
        "endLine": 878,
        "endChar": 28
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "989987d8_ca5740d5",
        "filename": "p2p/base/p2p_transport_channel.cc",
        "patchSetId": 4
      },
      "lineNbr": 878,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-06T19:54:30Z",
      "side": 1,
      "message": "Ack. |disable_equivalent| should be a no-op ideally and if not we should fix that. IIRC, interface changes should be signaled to the (shared) session and handled correctly on the fly.",
      "parentUuid": "8a996e2e_5af30ddb",
      "range": {
        "startLine": 878,
        "startChar": 11,
        "endLine": 878,
        "endChar": 28
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "54650189_0be586df",
        "filename": "p2p/base/p2p_transport_channel.cc",
        "patchSetId": 4
      },
      "lineNbr": 911,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-03T19:49:11Z",
      "side": 1,
      "message": "A couple of questions related to this line:\n1. For a shared session, which transport should set the role and tie breaker in the first place?\n2. Because of line 878, is there a chance we would have a new port created so that it\u0027s not from a pooled batch?",
      "range": {
        "startLine": 911,
        "startChar": 10,
        "endLine": 911,
        "endChar": 20
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eda61282_b790ff5b",
        "filename": "p2p/base/p2p_transport_channel.cc",
        "patchSetId": 4
      },
      "lineNbr": 911,
      "author": {
        "id": 5659
      },
      "writtenOn": "2020-01-06T17:08:28Z",
      "side": 1,
      "message": "1.  The current code does role/tiebreaker at the port level, which doesn\u0027t work when doing forking.  A wrote a fix for that in https://webrtc-review.googlesource.com/c/src/+/163400.  If that CL works, then each transport would do its own role/tiebreaker.\n\n2.  If you call StartGathering, you are explicitly providing the IceGatherer and ignoring pooled sessions, so yes, we\u0027d ignore pooled sessions if (for some reason) pooled sessions and IceGatherers were used at the same time.",
      "parentUuid": "54650189_0be586df",
      "range": {
        "startLine": 911,
        "startChar": 10,
        "endLine": 911,
        "endChar": 20
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c96a81f_bf3aee60",
        "filename": "p2p/base/p2p_transport_channel.cc",
        "patchSetId": 4
      },
      "lineNbr": 911,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-06T19:54:30Z",
      "side": 1,
      "message": "1. I see. Sorry I missed the other CL.\n2. Ack.",
      "parentUuid": "eda61282_b790ff5b",
      "range": {
        "startLine": 911,
        "startChar": 10,
        "endLine": 911,
        "endChar": 20
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f7be1f25_89b182cb",
        "filename": "p2p/base/p2p_transport_channel_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 5696,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-06T19:54:30Z",
      "side": 1,
      "message": "transport2? Or do we intend to have a transport1.reset()?\n\nIn terms of the tested behavior, IIUC sharing a session would then disable the optimization that stops gathering in |P2PTransportChannel::MaybeStopPortAllocatorSessions| when we have a writable connection, which I think we should.",
      "range": {
        "startLine": 5696,
        "startChar": 30,
        "endLine": 5696,
        "endChar": 40
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e783484_bdbae053",
        "filename": "pc/peer_connection.cc",
        "patchSetId": 4
      },
      "lineNbr": 2608,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-03T19:49:11Z",
      "side": 1,
      "message": "nit: the two methods could be renamed to make the distinction a bit clearer, though I don\u0027t have better names...",
      "range": {
        "startLine": 2608,
        "startChar": 27,
        "endLine": 2608,
        "endChar": 46
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb492b09_b528f2ea",
        "filename": "pc/peer_connection.cc",
        "patchSetId": 4
      },
      "lineNbr": 2608,
      "author": {
        "id": 5659
      },
      "writtenOn": "2020-01-06T17:08:28Z",
      "side": 1,
      "message": "One is definitely gathering with a given IceGatherer and the other is maybe gathering with a new one or a pooled one depending on the latest ICE parameters.  Changing MaybeStartGathering would require a lot of places to be renamed, so I\u0027d rather not rename it.\n\nI\u0027m happy to make StartGathering more explicit though.  Perhaps something like StartGatheringWithSharedGatherer?",
      "parentUuid": "1e783484_bdbae053",
      "range": {
        "startLine": 2608,
        "startChar": 27,
        "endLine": 2608,
        "endChar": 46
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18c6116d_e30bedbf",
        "filename": "pc/peer_connection.cc",
        "patchSetId": 4
      },
      "lineNbr": 2608,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-06T19:54:30Z",
      "side": 1,
      "message": "StartGatheringWithSharedGatherer sgtm.",
      "parentUuid": "bb492b09_b528f2ea",
      "range": {
        "startLine": 2608,
        "startChar": 27,
        "endLine": 2608,
        "endChar": 46
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "15070609_ab217b20",
        "filename": "pc/peer_connection.cc",
        "patchSetId": 4
      },
      "lineNbr": 7381,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-03T19:49:11Z",
      "side": 1,
      "message": "This API is now supposedly called before SLD, but wondering if we consider offering the option to cancel forking by setting it to null? Not sure though if accommodating this case make any practical sense.",
      "range": {
        "startLine": 7381,
        "startChar": 2,
        "endLine": 7381,
        "endChar": 12
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a048db96_e123ed1e",
        "filename": "pc/peer_connection_ice_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 220,
      "author": {
        "id": 6646
      },
      "writtenOn": "2020-01-06T19:54:30Z",
      "side": 1,
      "message": "nit: could have a drive-by clean-up now that we have GetInternalPeerConnection below.",
      "range": {
        "startLine": 220,
        "startChar": 4,
        "endLine": 220,
        "endChar": 20
      },
      "revId": "b4bc95d979771a7a1e526a172693d377f836ff98",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}