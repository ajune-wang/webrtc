{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a1506596_dbba94f2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 10107
      },
      "writtenOn": "2022-03-09T10:08:11Z",
      "side": 1,
      "message": "Mirko, could you take a first look at this? vast majority of the changes from const std::string\u0026 to absl::string_view are straightforward, but in a few cases I had to make a decision about where to convert the to std::string. Let me know what you think.",
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "03b972be_4bdb652f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-03-14T10:21:41Z",
      "side": 1,
      "message": "Adding nisse@ for a second opinion on some places where we are now forced into taking a copy that was not needed before (e.g. when we take a sting\u0026 param, call c_str() on it, while now we need to create a string and potentially heap allocate just to get a c_str().\n\nnisse@: Should we avoid string_view in such cases or change the code to avoid the copy?",
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "820542dc_4ac976b2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-14T10:43:16Z",
      "side": 1,
      "message": "I\u0027ve had a look at the places Mirko pointed out.\n\nI think it would make sense to start with landing cls for the easy cases, where no additional copies are needed. And then we can review remaining cases more carefully.",
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ccd7989_4b863e97",
        "filename": "rtc_base/async_resolver.cc",
        "patchSetId": 4
      },
      "lineNbr": 104,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-03-14T10:21:41Z",
      "side": 1,
      "message": "I haven\u0027t thought too much about this, but I wonder if hostname.data() works here?",
      "range": {
        "startLine": 104,
        "startChar": 18,
        "endLine": 104,
        "endChar": 47
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a65658c0_a14cdf01",
        "filename": "rtc_base/async_resolver.cc",
        "patchSetId": 4
      },
      "lineNbr": 104,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-14T10:43:16Z",
      "side": 1,
      "message": "string_views are by designed not nul-terminated (that\u0027s how you can refer to a substring without copying), so .data() doesn\u0027t work.\n\nI think it\u0027s reasonable to create a copy where needed, when we have to call C api functions that require nul-termination.\n\nExcept in case we know that all callers actually have a nul-terminated string; in that case we could try to avoid the extra copy.",
      "parentUuid": "5ccd7989_4b863e97",
      "range": {
        "startLine": 104,
        "startChar": 18,
        "endLine": 104,
        "endChar": 47
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a84faf0_4f25cda8",
        "filename": "rtc_base/async_resolver.cc",
        "patchSetId": 4
      },
      "lineNbr": 104,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-03-14T10:54:58Z",
      "side": 1,
      "message": "\u003e string_views are by designed not nul-terminated (that\u0027s how you can refer to a substring without copying), so .data() doesn\u0027t work.\n\nRight, thanks. I forgot that.\n\n\u003e I think it\u0027s reasonable to create a copy where needed, when we have to call C api functions that require nul-termination.\n\nIsn\u0027t const string\u0026 better in such case?\n \n\u003e Except in case we know that all callers actually have a nul-terminated string; in that case we could try to avoid the extra copy.\n\nBut we cannot know based on the type, so that would be a risk we take.",
      "parentUuid": "a65658c0_a14cdf01",
      "range": {
        "startLine": 104,
        "startChar": 18,
        "endLine": 104,
        "endChar": 47
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a47dcb2d_6c8aa97a",
        "filename": "rtc_base/async_resolver.cc",
        "patchSetId": 4
      },
      "lineNbr": 104,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-14T11:08:21Z",
      "side": 1,
      "message": "\u003e \u003e I think it\u0027s reasonable to create a copy where needed, when we have to call C api functions that require nul-termination.\n\u003e \n\u003e Isn\u0027t const string\u0026 better in such case?\n\nDepends. If that implies that we just move the copying to (almost) all call sites, I\u0027d prefer to keep absl::string_view in the interface, and keep the copying locally in the implementation.\n  \n\u003e \u003e Except in case we know that all callers actually have a nul-terminated string; in that case we could try to avoid the extra copy.\n\u003e \n\u003e But we cannot know based on the type, so that would be a risk we take.\n\nIn those cases, we shouldn\u0027t use string_view, but either const std::string\u0026, or maybe just const char*.\n\n(In general, I\u0027m not that fond of using .c_str(), I would prefer replacing it with some function that also checks if the given string has embedded nul characters, and fails in that case, i.e., fail whenever s.size() !\u003d strlen(s.c_str()). Such inconsistencies in interpretation have been exploited in the past, see e.g.,  https://it.slashdot.org/story/09/07/30/186228/null-character-hack-allows-ssl-spoofing).",
      "parentUuid": "9a84faf0_4f25cda8",
      "range": {
        "startLine": 104,
        "startChar": 18,
        "endLine": 104,
        "endChar": 47
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4cd6722b_0abeaa7f",
        "filename": "rtc_base/async_resolver.cc",
        "patchSetId": 4
      },
      "lineNbr": 104,
      "author": {
        "id": 10107
      },
      "writtenOn": "2022-03-14T11:37:02Z",
      "side": 1,
      "message": "I think in this case it makes sense to just use a std::string\u0026. I see now that this is an internal helper function only and that it is used in only one place further below, where the caller already has a std::string. So I\u0027ll change this back to std::string. wdyt?",
      "parentUuid": "a65658c0_a14cdf01",
      "range": {
        "startLine": 104,
        "startChar": 18,
        "endLine": 104,
        "endChar": 47
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4451d9f8_2fa16f2c",
        "filename": "rtc_base/async_resolver.cc",
        "patchSetId": 4
      },
      "lineNbr": 104,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-03-14T15:05:18Z",
      "side": 1,
      "message": "Yes, that SGTM.",
      "parentUuid": "4cd6722b_0abeaa7f",
      "range": {
        "startLine": 104,
        "startChar": 18,
        "endLine": 104,
        "endChar": 47
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52a0ebdb_6140e625",
        "filename": "rtc_base/async_resolver.cc",
        "patchSetId": 4
      },
      "lineNbr": 104,
      "author": {
        "id": 10107
      },
      "writtenOn": "2022-03-14T15:30:07Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "4451d9f8_2fa16f2c",
      "range": {
        "startLine": 104,
        "startChar": 18,
        "endLine": 104,
        "endChar": 47
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e10a1441_5b4bb72c",
        "filename": "rtc_base/checks.cc",
        "patchSetId": 4
      },
      "lineNbr": 44,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-03-14T10:21:41Z",
      "side": 1,
      "message": "I wonder if we can avoid this copy here.\n\nWhat do you think about having a std::string param and move it all the way through the calls up to this point (and here just keep the temporary param and take a c_str from it, since nothing in this function will take that pointer anyway).",
      "range": {
        "startLine": 43,
        "startChar": 2,
        "endLine": 44,
        "endChar": 44
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a6f9525_490cc725",
        "filename": "rtc_base/checks.cc",
        "patchSetId": 4
      },
      "lineNbr": 44,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-14T10:43:16Z",
      "side": 1,
      "message": "Don\u0027t think it\u0027s worth much effort to optimize away the copy in this place.\n\nHowever, the fprintf(stderr, \"%s\", output_c) could be replaced with an fwrite with pointer and length. As for _android_log_print, maybe worth checking if there\u0027s some format specifier that lets you pass pointer and length (I think standard printf field width is useless, since that\u0027s essentially minimum field with, and we need amaximum field width).",
      "parentUuid": "e10a1441_5b4bb72c",
      "range": {
        "startLine": 43,
        "startChar": 2,
        "endLine": 44,
        "endChar": 44
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8e075168_59a54806",
        "filename": "rtc_base/checks.cc",
        "patchSetId": 4
      },
      "lineNbr": 44,
      "author": {
        "id": 10107
      },
      "writtenOn": "2022-03-14T11:37:02Z",
      "side": 1,
      "message": "Done. I checked and unfortunately, android/log.h doesn\u0027t provide any functions that take the length of the string.",
      "parentUuid": "e10a1441_5b4bb72c",
      "range": {
        "startLine": 43,
        "startChar": 2,
        "endLine": 44,
        "endChar": 44
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "029a446b_b2fe7835",
        "filename": "rtc_base/experiments/field_trial_parser.cc",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-03-14T10:21:41Z",
      "side": 1,
      "message": "Isn\u0027t it better to have a std::string as a parameter (and just move all the way through)?\n\nI think we might want to keep absl::string_view but maybe avoid the copy and adopt the code in case str.data() is nullptr?",
      "range": {
        "startLine": 128,
        "startChar": 6,
        "endLine": 128,
        "endChar": 37
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "782dffd2_5b0c1a7d",
        "filename": "rtc_base/experiments/field_trial_parser.cc",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-14T10:43:16Z",
      "side": 1,
      "message": "We could perhaps use absl::SimpleAToF. And I wonder if we really need the unit/% feature?",
      "parentUuid": "029a446b_b2fe7835",
      "range": {
        "startLine": 128,
        "startChar": 6,
        "endLine": 128,
        "endChar": 37
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5b6b426_9d6d8893",
        "filename": "rtc_base/experiments/field_trial_parser.cc",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 10107
      },
      "writtenOn": "2022-03-14T11:37:02Z",
      "side": 1,
      "message": "absl::SimpleAToF is not allowed yet according to chromium/webrtc style guides.\n\nI\u0027ve adden an empty() check in the code for now. wdyt?",
      "parentUuid": "029a446b_b2fe7835",
      "range": {
        "startLine": 128,
        "startChar": 6,
        "endLine": 128,
        "endChar": 37
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e7999e1a_c6949466",
        "filename": "rtc_base/experiments/field_trial_parser.cc",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-14T12:47:15Z",
      "side": 1,
      "message": "Don\u0027t know if that\u0027s a case worth optimizing for? Is this often called with empty input?",
      "parentUuid": "b5b6b426_9d6d8893",
      "range": {
        "startLine": 128,
        "startChar": 6,
        "endLine": 128,
        "endChar": 37
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "413ba4d0_f302aaf8",
        "filename": "rtc_base/experiments/field_trial_parser.cc",
        "patchSetId": 4
      },
      "lineNbr": 128,
      "author": {
        "id": 10107
      },
      "writtenOn": "2022-03-14T14:35:14Z",
      "side": 1,
      "message": "Hmm... unclear if empty string is oft-recurring in calls. Looking at the call sites though I don\u0027t think this optimization matters much. So vote for removing it.",
      "parentUuid": "e7999e1a_c6949466",
      "range": {
        "startLine": 128,
        "startChar": 6,
        "endLine": 128,
        "endChar": 37
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0fb1a5d_1bb191c4",
        "filename": "rtc_base/experiments/field_trial_units.cc",
        "patchSetId": 4
      },
      "lineNbr": 41,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-03-14T10:21:41Z",
      "side": 1,
      "message": "Return nullopt in case data() is nullptr and just avoid to create a std::string?",
      "range": {
        "startLine": 41,
        "startChar": 15,
        "endLine": 41,
        "endChar": 39
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e624385b_a49e3541",
        "filename": "rtc_base/experiments/field_trial_units.cc",
        "patchSetId": 4
      },
      "lineNbr": 41,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-14T10:43:16Z",
      "side": 1,
      "message": "Hmm, I don\u0027t get this comment. But since I think the input here us typicalyl a substring with no nul-termination, I think it makes sense to make any required copy at this place, and not higher up.",
      "parentUuid": "c0fb1a5d_1bb191c4",
      "range": {
        "startLine": 41,
        "startChar": 15,
        "endLine": 41,
        "endChar": 39
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac02d0c5_ceb15f4a",
        "filename": "rtc_base/experiments/field_trial_units.cc",
        "patchSetId": 4
      },
      "lineNbr": 41,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-03-14T10:52:10Z",
      "side": 1,
      "message": "Yes, I forgot that .data() doesn\u0027t mean it is nul-terminated. So this is OK.\n\nIn general (but this was true also in the past when we tried to switch to string_view), it looks to me that `const string\u0026` has its advantages in some cases, and string_view reverts some invariants (e.g. knowing it is nul-terminated), forcing us to take copies. In some cases, it is fine (not hot paths) but in other cases it is unclear.\n\nI wonder if we should switch to string_view everywhere % some places where const string\u0026 actually makes sense?",
      "parentUuid": "e624385b_a49e3541",
      "range": {
        "startLine": 41,
        "startChar": 15,
        "endLine": 41,
        "endChar": 39
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6ae151d_2733fa1e",
        "filename": "rtc_base/experiments/field_trial_units.cc",
        "patchSetId": 4
      },
      "lineNbr": 41,
      "author": {
        "id": 10107
      },
      "writtenOn": "2022-03-14T11:37:02Z",
      "side": 1,
      "message": "I agree that it would make sense to keep std::string\u0026 in hot paths, but I haven\u0027t really encountered any in this CL (to my knowledge).",
      "parentUuid": "ac02d0c5_ceb15f4a",
      "range": {
        "startLine": 41,
        "startChar": 15,
        "endLine": 41,
        "endChar": 39
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8a0e1361_c0bc103a",
        "filename": "rtc_base/experiments/field_trial_units.cc",
        "patchSetId": 4
      },
      "lineNbr": 41,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-03-15T08:24:51Z",
      "side": 1,
      "message": "I missed this was a copy in the old diff as well.\n\nLet\u0027s ignore this comment.",
      "parentUuid": "b6ae151d_2733fa1e",
      "range": {
        "startLine": 41,
        "startChar": 15,
        "endLine": 41,
        "endChar": 39
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82745b1e_c919dc58",
        "filename": "rtc_base/experiments/field_trial_units.cc",
        "patchSetId": 4
      },
      "lineNbr": 41,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-15T08:41:43Z",
      "side": 1,
      "message": "In this case too, optimizing for empty case seems a bit questionable. And I\u0027d expect creating an empty temporary std::string is pretty cheap, if std::string has any kind of short-string optimization.\n\nAgree with other comments.",
      "parentUuid": "b6ae151d_2733fa1e",
      "range": {
        "startLine": 41,
        "startChar": 15,
        "endLine": 41,
        "endChar": 39
      },
      "revId": "9221ae294032c4f6bd5a232d64f2369195742c93",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}