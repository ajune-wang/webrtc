{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "11997b2e_aca04dc0",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2.cc",
        "patchSetId": 6
      },
      "lineNbr": 312,
      "author": {
        "id": 5150
      },
      "writtenOn": "2023-03-16T15:07:32Z",
      "side": 1,
      "message": "What happens when we get a low probe result?\nHere, it seems like the best_candidate is set to the probe rate if the state is kIncreasing or kDecreasing. Meanwhile, the delay-based estimate will have started to ramp up again (assuming that the delay is stable). So it seems likely that\n```\nbest_candidate.loss_limited_bandwidth \u003c\u003d probe_bitrate_ \u003c delay_based_estimate_\n```\n\nThen it seems like we\u0027ll always end up in one of the first two branches on lines 316-320, i.e. the state remains in kIncreasing or kDecreasing.\n\nIs this correct?",
      "range": {
        "startLine": 312,
        "startChar": 0,
        "endLine": 312,
        "endChar": 74
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "81993850_660508be",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2.cc",
        "patchSetId": 6
      },
      "lineNbr": 312,
      "author": {
        "id": 19004
      },
      "writtenOn": "2023-03-16T16:10:25Z",
      "side": 1,
      "message": "If probe result is low, then estimate will be low until next probe result comes.\n\nI actually don\u0027t expect the case when network has loss (because its state is kIncreasing or kDecreasing) and delay-based estimate increases. Delay based estimate also relies on probe result. So if both loss based estimate and probe result are low, then delay based estimate should not increase.",
      "parentUuid": "11997b2e_aca04dc0",
      "range": {
        "startLine": 312,
        "startChar": 0,
        "endLine": 312,
        "endChar": 74
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3dd14a8_7a5dbd8a",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2.cc",
        "patchSetId": 6
      },
      "lineNbr": 312,
      "author": {
        "id": 5150
      },
      "writtenOn": "2023-03-17T14:56:23Z",
      "side": 1,
      "message": "But suppose we enter the decreasing state, and current_estimate_.loss_limited_bandwidth\u003d\u003dprobe_bitrate, then iiuc we won\u0027t send any probes? At the same time, best_candidate.loss_limited_bandwidth is also capped to probe_bitrate so IsEstimateIncreasingWhenLossLimited will return false, so the estimator will stay in decreasing state.\n\nI guess this is mitigated by the probe_expiration, but it will still defer recovery from other probes by 10s. Maybe the caps should be applied after the state update?\n\nMore generally, I\u0027d prefer an architecture that minimized the interactions between different parts of the system, or made the interaction explicit if it cannot be avoided. For example, it looks like the kIncreasing and kDecreasing states aren\u0027t used for anything other than being propagated to the probe controller. At the same time, the loss based bwe assumes that the probe_controller responds to the state in a very specific way. Maybe one could remove the loss based states, and instead propagate a new enum\n```\nenum {\n kRequestProbe,\n kAllowButNotRequestProbe,\n kBlockProbe\n}\n```\n?",
      "parentUuid": "81993850_660508be",
      "range": {
        "startLine": 312,
        "startChar": 0,
        "endLine": 312,
        "endChar": 74
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e8865d9c_81f9726e",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2.cc",
        "patchSetId": 6
      },
      "lineNbr": 312,
      "author": {
        "id": 19004
      },
      "writtenOn": "2023-03-17T15:51:22Z",
      "side": 1,
      "message": "\u003e I guess this is mitigated by the probe_expiration, but it will still defer recovery from other probes by 10s. Maybe the caps should be applied after the state update?\n\nYes, you are right. Applying the cap after state update helps.\n\n\u003e At the same time, the loss based bwe assumes that the probe_controller responds to the state in a very specific way. Maybe one could remove the loss based states, and instead propagate a new enum\n\nI agree that makes the states clearer. However, as the state is propagated to goog_cc and used by probe controller in production, I am a bit hesitant to make the refractory in this CL. I will do it in a separate one.",
      "parentUuid": "e3dd14a8_7a5dbd8a",
      "range": {
        "startLine": 312,
        "startChar": 0,
        "endLine": 312,
        "endChar": 74
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af1eb379_34e85274",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2.cc",
        "patchSetId": 6
      },
      "lineNbr": 317,
      "author": {
        "id": 5150
      },
      "writtenOn": "2023-03-16T15:07:32Z",
      "side": 1,
      "message": "nit: This uses the method argument, but the conditions below compare to the member variable. Is this intentional?",
      "range": {
        "startLine": 317,
        "startChar": 46,
        "endLine": 317,
        "endChar": 66
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a3d3ca15_7abcbe5c",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2.cc",
        "patchSetId": 6
      },
      "lineNbr": 317,
      "author": {
        "id": 19004
      },
      "writtenOn": "2023-03-16T16:10:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "af1eb379_34e85274",
      "range": {
        "startLine": 317,
        "startChar": 46,
        "endLine": 317,
        "endChar": 66
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e63952d7_b6eec020",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2.cc",
        "patchSetId": 6
      },
      "lineNbr": 1096,
      "author": {
        "id": 5150
      },
      "writtenOn": "2023-03-16T15:07:32Z",
      "side": 1,
      "message": "Is this functionally the same as IsBandwidthLimitedDueToLoss above?",
      "range": {
        "startLine": 1096,
        "startChar": 27,
        "endLine": 1096,
        "endChar": 55
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "93ef54d1_0a7d0e33",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2.cc",
        "patchSetId": 6
      },
      "lineNbr": 1096,
      "author": {
        "id": 19004
      },
      "writtenOn": "2023-03-16T16:10:25Z",
      "side": 1,
      "message": "Yes. We only request probes when kIncreasing. However, both kIncreasing and kDecreasing require because kDecreasing \u003d\u003d true when \n1. state is kIncreasing \n2. probe result \u003c current estimate, then we bound current estimate to be probe result. This means current estimate decreasing -\u003e new state \u003d kDecreasing",
      "parentUuid": "e63952d7_b6eec020",
      "range": {
        "startLine": 1096,
        "startChar": 27,
        "endLine": 1096,
        "endChar": 55
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6e420d7_e821b780",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2.cc",
        "patchSetId": 6
      },
      "lineNbr": 1096,
      "author": {
        "id": 5150
      },
      "writtenOn": "2023-03-17T14:56:23Z",
      "side": 1,
      "message": "If we\u0027re not actually probing when the current estimate is decreasing, then I don\u0027t think the name is appropriate.",
      "parentUuid": "93ef54d1_0a7d0e33",
      "range": {
        "startLine": 1096,
        "startChar": 27,
        "endLine": 1096,
        "endChar": 55
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6a450df1_b140189e",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2.cc",
        "patchSetId": 6
      },
      "lineNbr": 1096,
      "author": {
        "id": 19004
      },
      "writtenOn": "2023-03-17T15:51:22Z",
      "side": 1,
      "message": "Done.\n\nI realize that moving the cap after state updating helps this IsRequestingProbes. So function name can be the same because current_state_ \u003d\u003d LossBasedState::kIncreasing is enough.",
      "parentUuid": "f6e420d7_e821b780",
      "range": {
        "startLine": 1096,
        "startChar": 27,
        "endLine": 1096,
        "endChar": 55
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5e7a258_b72b9f1c",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2_test.cc",
        "patchSetId": 6
      },
      "lineNbr": 1184,
      "author": {
        "id": 5150
      },
      "writtenOn": "2023-03-16T15:07:32Z",
      "side": 1,
      "message": "I assume that probe_estimate would normally be nullopt except when the results of a probe comes it, right? Then maybe make the test more realistic to only set probe_estimate on the first feedback?",
      "range": {
        "startLine": 1184,
        "startChar": 8,
        "endLine": 1184,
        "endChar": 22
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "14303678_231247d3",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2_test.cc",
        "patchSetId": 6
      },
      "lineNbr": 1184,
      "author": {
        "id": 19004
      },
      "writtenOn": "2023-03-16T16:10:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f5e7a258_b72b9f1c",
      "range": {
        "startLine": 1184,
        "startChar": 8,
        "endLine": 1184,
        "endChar": 22
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5a4f5b4_03a9f5e7",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2_test.cc",
        "patchSetId": 6
      },
      "lineNbr": 1190,
      "author": {
        "id": 5150
      },
      "writtenOn": "2023-03-16T15:07:32Z",
      "side": 1,
      "message": "Maybe move this check into the loop? I assume it\u0027s supposed to hold after every update?",
      "range": {
        "startLine": 1190,
        "startChar": 0,
        "endLine": 1190,
        "endChar": 70
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bb17ac20_d1e67607",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2_test.cc",
        "patchSetId": 6
      },
      "lineNbr": 1190,
      "author": {
        "id": 19004
      },
      "writtenOn": "2023-03-16T16:10:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a5a4f5b4_03a9f5e7",
      "range": {
        "startLine": 1190,
        "startChar": 0,
        "endLine": 1190,
        "endChar": 70
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0c7b2f4_e51722ad",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2_test.cc",
        "patchSetId": 6
      },
      "lineNbr": 1199,
      "author": {
        "id": 5150
      },
      "writtenOn": "2023-03-16T15:07:32Z",
      "side": 1,
      "message": "Should we set ProbeExpiration here since the test depends on the expiration duration?",
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "43b57ef3_8a2da10b",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2_test.cc",
        "patchSetId": 6
      },
      "lineNbr": 1199,
      "author": {
        "id": 19004
      },
      "writtenOn": "2023-03-16T16:10:25Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b0c7b2f4_e51722ad",
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "01e404a9_f646a3f3",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2_test.cc",
        "patchSetId": 6
      },
      "lineNbr": 1228,
      "author": {
        "id": 5150
      },
      "writtenOn": "2023-03-16T15:07:32Z",
      "side": 1,
      "message": "If this test is identical to the one above except that it adds ~10 lines at the end to check that the estimate recovers without probes, then maybe merge the two? I realize that testing multiple things in the same test is contrary to best practice for unit tests, but if we\u0027re doing that anyway, then I think we might just as well eliminate some code duplication. WDYT?",
      "range": {
        "startLine": 1201,
        "startChar": 0,
        "endLine": 1228,
        "endChar": 3
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a7a90b2f_3677a363",
        "filename": "modules/congestion_controller/goog_cc/loss_based_bwe_v2_test.cc",
        "patchSetId": 6
      },
      "lineNbr": 1228,
      "author": {
        "id": 19004
      },
      "writtenOn": "2023-03-16T16:10:25Z",
      "side": 1,
      "message": "Acknowledged.\n\nI quite agree with you. I don\u0027t have a strong opinion on merging/separating two similar tests. However I already modified NotLimitByProbeResultWhenProbeResultIsExpired a bit by adding ProbeExpiration, and because the test itself has already complicated setup, thus separating the tests will be clearer for readers.",
      "parentUuid": "01e404a9_f646a3f3",
      "range": {
        "startLine": 1201,
        "startChar": 0,
        "endLine": 1228,
        "endChar": 3
      },
      "revId": "3a54bf9a4f684dc4032d2dabe6358caf13d58be9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}