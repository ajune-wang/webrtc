{
  "comments": [
    {
      "key": {
        "uuid": "d08a2d45_752bbbe2",
        "filename": "api/task_queue/task_queue_test.h",
        "patchSetId": 9
      },
      "lineNbr": 25,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-22T23:59:29Z",
      "side": 1,
      "message": "Hmmm... so the user supplies a raw factory pointer, which is used by all tests and then leaked at the end?\n\nCould we instead do something like this?\n\n  INSTANTIATE_TEST_SUITE_P(My, TaskQueueTest,\n                           ::testing::Values(absl::make_unique\u003cMyTaskQueueFactory\u003e));\n\nand let the test parameter type be `std::function\u003cstd::unique_ptr\u003cTaskQueueFactory\u003e()\u003e`? Then each test case could instantiate a factory, no factories would be leaked, and world peace and harmony.\n\nAlternative way to document the same thing (probably better, since it doesn\u0027t use make_unique in a funny way that most people haven\u0027t seen before):\n\n  std::unique_ptr\u003cwebrtc::TaskQueueFactory\u003e CreateMyFactory() {\n    return absl::make_unique\u003cMyTaskQueueFactory\u003e();\n  }\n  INSTANTIATE_TEST_SUITE_P(My, TaskQueueTest, ::testing::Values(CreateMyFactory));",
      "revId": "279bce4de6169ac8f366cb0e6fd45aa402e878b0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "363e1933_1c061b08",
        "filename": "api/task_queue/task_queue_test.h",
        "patchSetId": 9
      },
      "lineNbr": 25,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-01-23T09:45:40Z",
      "side": 1,
      "message": "the test verifies TaskQueue implementation, so parameter is TaskQueue factory.\ntaking TaskQueueFactory factory as a parameter seems like unnecessary extra layer.\n\nI do not consider using pointer as parameter something that has to be avoided. gmock do mention raw pointer as an option:\nhttps://github.com/google/googletest/blob/master/googletest/docs/advanced.md#how-to-write-value-parameterized-tests\n\"If it\u0027s a raw pointer, you are responsible for managing the lifespan of the pointed values.\"\n\npointer doesn\u0027t have to leak in the end, but it is up to implementer of MyFactory() to decide lifetime of it. Options are plenty:\ne.g. use static unique_ptr (or static object) like in my first example, object destructed when test program exits.\nor make it leak, but annotate it for leak detector to ignore. (e.g. chromium has NoDestructor helper for such cases)",
      "parentUuid": "d08a2d45_752bbbe2",
      "revId": "279bce4de6169ac8f366cb0e6fd45aa402e878b0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b1cdcec_d6da3578",
        "filename": "api/task_queue/task_queue_test.h",
        "patchSetId": 9
      },
      "lineNbr": 25,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-01-23T09:55:50Z",
      "side": 1,
      "message": "I\u0027m not really a fan of handling the lifetime manually like that, largely because it\u0027s complicated to explain. I would be happy if the parameter type was unique_ptr\u003cTaskQueueFactory\u003e, but I assume it needs to be copyable? And we can\u0027t use shared_ptr\u003cTaskQueueFactory\u003e, so a std::function felt like the next best thing.\n\nBut I won\u0027t veto the raw pointer. Just document that the thing it points to needs to live for the duration of the program.",
      "parentUuid": "363e1933_1c061b08",
      "revId": "279bce4de6169ac8f366cb0e6fd45aa402e878b0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}