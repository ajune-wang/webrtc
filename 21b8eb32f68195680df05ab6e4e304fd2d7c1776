{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c44b8c14_d9600d65",
        "filename": "pc/peer_connection_factory.h",
        "patchSetId": 7
      },
      "lineNbr": 160,
      "author": {
        "id": 9515
      },
      "writtenOn": "2023-12-04T12:01:43Z",
      "side": 1,
      "message": "Can these four fields just become decode_metronome_ and encode_metronome_?",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 160,
        "endChar": 31
      },
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d02665ef_1d11e062",
        "filename": "pc/peer_connection_factory.h",
        "patchSetId": 7
      },
      "lineNbr": 160,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-12-04T16:57:33Z",
      "side": 1,
      "message": "Are we creating one metronome per context, to allow experimenting with replacing one of the metronomes without replacing all of them?\n\nOr do we have multiple metronomes because we want to allow listening from different task queues?\n\nMaybe we do both. Sounds good to me.\n\nAgree that the name of the metronome should reflect the context that it is used, such as encode or decode, rather than when it ticks, given that the metronome is currently limited to a single task queue IIUC. So even if all metronomes ticked at the same time we would still need to have multiple metronomes if they are used on multiple task queues?",
      "parentUuid": "c44b8c14_d9600d65",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 160,
        "endChar": 31
      },
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5d8b971_bc0a4e43",
        "filename": "pc/peer_connection_factory.h",
        "patchSetId": 7
      },
      "lineNbr": 160,
      "author": {
        "id": 9515
      },
      "writtenOn": "2023-12-04T17:06:04Z",
      "side": 1,
      "message": "It\u0027s not about different task queues.\n\nThe nature of the decode metronome (timer or vsync) is controlled by experiment in Chromium, but the way the DecodeSynchronizer uses it is still the same which warrants sourcing from the same field at all times. I don\u0027t see why not to do the same with the encoding?",
      "parentUuid": "d02665ef_1d11e062",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 160,
        "endChar": 31
      },
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a72d8d4_e765e361",
        "filename": "pc/peer_connection_factory.h",
        "patchSetId": 7
      },
      "lineNbr": 160,
      "author": {
        "id": 9741
      },
      "writtenOn": "2023-12-05T06:40:57Z",
      "side": 1,
      "message": "The |metronome_| is going to deprecated with new added two metronome. The |encode_metronome_| is needed because we don\u0027t know if Vsync encoding is on just with the two metronome information. Here if we want to use encode_metronome and decode_metronome, then consider both VSync encode and decode are turned on, we want to trigger them with the same metronome source, so can we change the unique_ptr to shared_ptr? or let them use two metronome source and keep unique_ptr here?",
      "parentUuid": "c5d8b971_bc0a4e43",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 160,
        "endChar": 31
      },
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a92d07b7_189df082",
        "filename": "pc/peer_connection_factory.h",
        "patchSetId": 7
      },
      "lineNbr": 160,
      "author": {
        "id": 9741
      },
      "writtenOn": "2023-12-05T08:02:35Z",
      "side": 1,
      "message": "Ah, sorry, these four fields just become decode_metronome_ and encode_metronome_, I misunderstood with peer_connection_interface.h.",
      "parentUuid": "2a72d8d4_e765e361",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 160,
        "endChar": 31
      },
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ba12a36_ae4b2f04",
        "filename": "pc/peer_connection_factory.h",
        "patchSetId": 7
      },
      "lineNbr": 160,
      "author": {
        "id": 9741
      },
      "writtenOn": "2023-12-05T08:25:39Z",
      "side": 1,
      "message": "Hmm, the unique_ptr still there if both VSync encode and decode on.",
      "parentUuid": "a92d07b7_189df082",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 160,
        "endChar": 31
      },
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00904502_740544fb",
        "filename": "pc/peer_connection_factory.h",
        "patchSetId": 7
      },
      "lineNbr": 160,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-12-05T09:07:38Z",
      "side": 1,
      "message": "Please correct me if I\u0027m going down in a rabbit hole, but I\u0027m still not sure what the conclusion here is. How many metronomes we want or what their names should be.\n\n\u003e It\u0027s not about different task queues.\n\nRegardless which tick implementation is used (VSyncTickProvider[1] orTimerBasedTickProvider[2]), the Chromium MetronomeSource reschedules with a sequence checker[3] and this is what ends up being called by the webrtc::Metronome implementation[4]. As far as I can tell, the primary reason for sequence checking is to make handling of callbacks work without locks and to avoid additional post tasking, but under the hood the actual ticking is implemented using posting tasks of some sort and so the single sequence-ness may be an implementation detail.\n\nEither way as far as I can tell, if we are interested in listening to metronome callbacks on different task queues, we either have to have multiple metronome instances (whether or not driven by the same wakeup signal), or we have to update the metronome implementations to not be single-sequenced.\n\n[1] https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/platform/peerconnection/vsync_tick_provider.cc;l\u003d53;drc\u003d8e78783dc1f7007bad46d657c9f332614e240fd8\n\n[2] https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc_overrides/timer_based_tick_provider.cc;l\u003d20;drc\u003d8e78783dc1f7007bad46d657c9f332614e240fd8\n\n[3] https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc_overrides/metronome_source.cc;l\u003d76;drc\u003d8e78783dc1f7007bad46d657c9f332614e240fd8\n\n[4] https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc_overrides/metronome_source.cc;l\u003d39;drc\u003d8e78783dc1f7007bad46d657c9f332614e240fd8\n\n\u003e Here if we want to use encode_metronome and decode_metronome, then consider both VSync encode and decode are turned on, we want to trigger them with the same metronome source, so can we change the unique_ptr to shared_ptr?\n\nI don\u0027t see any negative consequence in terms of performance of having multiple metronomes, even if they are both \"under the hood\" sources from the same tick. In this case, will the ticking be controlled by an experiment, so the tick source \"may or may not\" be the same for both metronomes?\n\nThat said, it would be less confusing to have a single metronome in the future.",
      "parentUuid": "8ba12a36_ae4b2f04",
      "range": {
        "startLine": 157,
        "startChar": 2,
        "endLine": 160,
        "endChar": 31
      },
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0260a4f_1955190f",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 263,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-12-04T16:57:33Z",
      "side": 1,
      "message": "nit: Can you add an empty line between this method and the previous ones to make it clear that this is not part of the VideoFrameSink overrides?",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c88238eb_7b09bb6a",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 263,
      "author": {
        "id": 9741
      },
      "writtenOn": "2023-12-05T08:25:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b0260a4f_1955190f",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec80b300_90a4e12b",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 301,
      "author": {
        "id": 9515
      },
      "writtenOn": "2023-12-04T12:01:43Z",
      "side": 1,
      "message": "How about just keeping the last received frame? What is the benefit of keeping a queue?",
      "range": {
        "startLine": 301,
        "startChar": 28,
        "endLine": 301,
        "endChar": 40
      },
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "940ad645_b5075d4d",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 301,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-12-04T16:57:33Z",
      "side": 1,
      "message": "I don\u0027t think only last frame is sufficient as it would break high fps use cases, so a queue makes sense to me. Do you disagree Markus?\n\nE.g. you might encode at 60 fps even though vsync signal is capped at 30 Hz. Or you might want to encode \u003e 120 fps and have a fairly standard 60 Hz monitor in case the other endpoint has a 120 Hz monitor. But when the ticking does happen, you should encode several frames back to back to clear the queue.\n\nI hope CPU adaptation can handle back-to-back frames, this may make inter-frame delay look like 0 but on average the inter-frame delay should still be the same since we also delay until next tick for more encodes so I think it should work.",
      "parentUuid": "ec80b300_90a4e12b",
      "range": {
        "startLine": 301,
        "startChar": 28,
        "endLine": 301,
        "endChar": 40
      },
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0666d90e_d8ea51d6",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 301,
      "author": {
        "id": 9515
      },
      "writtenOn": "2023-12-04T17:22:47Z",
      "side": 1,
      "message": "I don\u0027t understand how that escaped me, you\u0027re quite right Henrik. So yes the queue is needed.\nIn that case it\u0027s important to consider the case of giving the VideoStreamEncoder a good `queue_overload` signal.",
      "parentUuid": "940ad645_b5075d4d",
      "range": {
        "startLine": 301,
        "startChar": 28,
        "endLine": 301,
        "endChar": 40
      },
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40138be1_5b681ce9",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 688,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-12-04T16:57:33Z",
      "side": 1,
      "message": "nit: Replace pipes: | with backtics: ` in comments (the style guide changed some time ago but new code should use backsticks)",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b5aaedde_b3151b3a",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 688,
      "author": {
        "id": 9741
      },
      "writtenOn": "2023-12-05T08:25:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "40138be1_5b681ce9",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af2369bf_66859b07",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 710,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-12-04T16:57:33Z",
      "side": 1,
      "message": "Why do we need a callback that just updates an expected next tick, as opposed to encoding everything in the queue on every tick? Whether I have 0, 1 or multiple frames queued up, the tick seems like a good place to encode everything. Or is it more complicated than that?",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a6d1ddc_7f0473ec",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 710,
      "author": {
        "id": 9741
      },
      "writtenOn": "2023-12-05T06:40:57Z",
      "side": 1,
      "message": "This happened only for the first frame, because at first time, we don\u0027t know the next tick time, so we cannot decide whether encode before next tick or wait for tick to do encoding. After the first time, the |expected_next_tick_| is always finite.",
      "parentUuid": "af2369bf_66859b07",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7c78d965_40f5867a",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 710,
      "author": {
        "id": 9741
      },
      "writtenOn": "2023-12-05T08:25:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8a6d1ddc_7f0473ec",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55f06343_4e475633",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 720,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-12-04T16:57:33Z",
      "side": 1,
      "message": "If this is needed, can you add some comments to explain this adjustments to `expected_next_tick_`?",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b0c27aa_bc3c7f21",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 720,
      "author": {
        "id": 9741
      },
      "writtenOn": "2023-12-05T06:40:57Z",
      "side": 1,
      "message": "We adjust the expected next tick if the current time is larger than that tick, this happens when encoding lower fps frames, the next tick is updated with last encoding time plus one metronome interval and maybe smaller than current time, so we manually add several metronome intervals to let that next tick larger than current time. Will added comment later.",
      "parentUuid": "55f06343_4e475633",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "862e9d84_4a25e91a",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 7
      },
      "lineNbr": 720,
      "author": {
        "id": 9741
      },
      "writtenOn": "2023-12-05T08:25:39Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8b0c27aa_bc3c7f21",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "acba91b5_41dc224f",
        "filename": "video/frame_cadence_adapter_unittest.cc",
        "patchSetId": 7
      },
      "lineNbr": 70,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-12-04T16:57:33Z",
      "side": 1,
      "message": "Can we add unit tests with metronomes to ensure the encodes happen when we expect?\n\nIf the metronome for testing uses PostDelayedTask, this file contains tests using GlobalSimulatedTimeController which is pretty neat for advancing a fake clock and ensuring delayed tasks run on time, so you could advance by more or less than a tick and see if encode happened or not using EXPECT_CALL",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7aa7e3ea_8866dbc7",
        "filename": "video/frame_cadence_adapter_unittest.cc",
        "patchSetId": 7
      },
      "lineNbr": 70,
      "author": {
        "id": 9741
      },
      "writtenOn": "2023-12-05T08:25:39Z",
      "side": 1,
      "message": "Yes, will add test later.",
      "parentUuid": "acba91b5_41dc224f",
      "revId": "21b8eb32f68195680df05ab6e4e304fd2d7c1776",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}