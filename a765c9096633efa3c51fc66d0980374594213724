{
  "comments": [
    {
      "key": {
        "uuid": "9da031f9_bc77f510",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-10-05T08:39:07Z",
      "side": 1,
      "message": "Hi, can you explain the usecase? If we have a native frame (typically a gpu texture), and need a frame in main memory for software encoding, why isn\u0027t ToI420() good enough? The implementation I\u0027m aware of should be reasonably efficient, https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/sdk/android/api/org/webrtc/YuvConverter.java;drc\u003df2889bbaf40c37b80fad129dede112107b0af103;l\u003d125",
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e58c4dbe_4bbdd638",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 8683
      },
      "writtenOn": "2020-10-05T08:55:00Z",
      "side": 1,
      "message": "The purpose is to provide a way to avoid conversions where possible. If a frame is captured from a source in NV12, in which case we can provide access to that without requiring conversion to I420. For example, in Chrome a native frame is wrapped to adapt a webrtc buffer. However the backing frame may be in a non-I420 format, like when we capture onto a GPU, the frame is in NV12. This method allows access without an extra conversion or copy.\n\nIn the example above, it could be that the data is not trivially accessible, in which case this method would just return null and ToI420 would be needed.",
      "parentUuid": "9da031f9_bc77f510",
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "59e16368_2670a543",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-10-05T09:58:12Z",
      "side": 1,
      "message": "Ok, so chromium wraps it\u0027s own frame representation in a kNative VideoFrameBuffer, regardless of actual representation. Is this the relevant class:\n https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/webrtc/webrtc_video_frame_adapter.cc;drc\u003da66879efd8bd5cdcd54d5de99245bce9b881df10;l\u003d159\n\n?\n\nThe right way would be for chromium to let WebRtcVideoFrameAdapter::type() return kNV12, if that\u0027s the underlying representation, and implement a cheap GetNV12() method. How difficult is that?\n\nI\u0027m a bit confused about the GPU case you mention, though. In that case, copying seems unavoidable, when processed with a software encoder?\n\nAlternatively (but a bit more complex), mark all relevant chrome encoders as \"supports_native_handle\", pass on the kNative frame as is in videoStreamEncoder, and leave to the chromium encoder to unwrap the WebRtcVideoFrameAdapter to get back its own MediaFrame and do the right thing with it. In general, I\u0027d the expect that any application that passes frames with kNative into webrtc\u0027s pipeline will also inject codecs that understand the application\u0027s kNative format.",
      "parentUuid": "e58c4dbe_4bbdd638",
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "96a40ecb_7a3767d6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-10-05T10:10:48Z",
      "side": 1,
      "message": "Yes, this is the relevant class.\nHowever, it has to return kNative, otherwise the HW encoder in chromium won\u0027t be able to figure out if the passed frame is actually WebrtcVideoFrameAdapter, which holds a media::VideoFrame. They already all \"supports_native_handle\".",
      "parentUuid": "59e16368_2670a543",
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4417c18a_f356725b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-10-05T11:58:14Z",
      "side": 1,
      "message": "I\u0027m still confused. Questions:\n\n1. If the encoders are all \"supports_native_handle\", why would the frame be subject to conversion in VideoStreamEncoder?\n\n2. What are the obstacles to changing WebRtcVideoFrameAdapter::type() to return a different type depending on the type of the underlying media::VideoFrame? For frames in main memory, do the chrome encoders need anything from the MediaFrame, besides the raw pixel data which it could get via webrtc\u0027s VideoFrameBuffer, and related interfaces, and the webrtc VideoFrame metadata?",
      "parentUuid": "96a40ecb_7a3767d6",
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b7dbc48f_f5c9711b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 8683
      },
      "writtenOn": "2020-10-06T07:52:42Z",
      "side": 1,
      "message": "1) I think removing the native handle makes a lot of sense. All software encoders end up converting a frame type they can\u0027t encode using \"ToI420\" eventually anyways. However, there could be a case for supports_native_handle that I don\u0027t know. \n\n2) The Chrome encoders only handle media::VideoFrames, so if a non-kNative frame reaches there it performs a copy from webrtc::VideFrameBuffer into media::VideoFrame, which we want to avoid.",
      "parentUuid": "4417c18a_f356725b",
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "902b22dc_96984c34",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-10-06T08:22:52Z",
      "side": 1,
      "message": "\u003e 1) I think removing the native handle makes a lot of sense. All software encoders end up converting a frame type they can\u0027t encode using \"ToI420\" eventually anyways. \n\nI made a cl to try that out,see https://webrtc-review.googlesource.com/c/src/+/186702\n\n\u003e However, there could be a case for supports_native_handle that I don\u0027t know. \n\nAs far as I\u0027m aware, it\u0027s only used for the conversion logic in VideoStreamEncoder.\n\n\u003e 2) The Chrome encoders only handle media::VideoFrames, so if a non-kNative frame reaches there it performs a copy from webrtc::VideFrameBuffer into media::VideoFrame, which we want to avoid.\n\nOuch. Instead of unwrapping (which depends on kNative), could you wrap a VideoFrameBuffer (I420 or NV12 pixel format) in a media::VideoFrame, without copying (STORAGE_UNOWNED_MEMORY)? For safety, one would need the new media::VideoFrame (or the code that created it) hold on to a reference to the VideoFrameBuffer which in turn will hold a reference to the underlying media::VideoFrame. \n\nThis gets a bit silly, but from a webrtc api point of view, it\u0027s nice and clean. To turn it into something less silly, I guess chromium\u0027s encoder apis would need to be refactored to accept something less heavy weight than a media::VideoFrame. I.e., define an interface providing precisely what encoders need, and let media::VideoFrame implement that interface.",
      "parentUuid": "b7dbc48f_f5c9711b",
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "117e975a_105e9801",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 4
      },
      "lineNbr": 1344,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-10-05T08:57:18Z",
      "side": 1,
      "message": "This looks scary.\n\n|set_video_frame_buffer| accepts scoped_refptr. So that we have here is taking contents of one scoped_refptr and put it into another scoped_refptr. So it seems here that we would get two smart pointers pointing to the same address each with it\u0027s own counter. Then once converted_buffer gets destroyed it should free the memory and we would get use-after-free.\n\nI think it\u0027s not that\u0027s actually happening because rtc::scoped_refptr doesn\u0027t have any counters: the object at the pointed memory holds them.\n\nStill, maybe try to rewrite it by creating a new scoped_refptr and initializing it with converted_buffer.\n\nAlso, I don\u0027t fully understand why the const cast is even needed.\nset_video_frame_buffer() accepts |const rtc::scoped_refptr\u003cVideoFrameBuffer\u003e\u0026|.\nconverted_buffer is |rtc::scoped_refptr\u003cVideoFrameBuffer\u003e|. It should work!",
      "range": {
        "startLine": 1344,
        "startChar": 55,
        "endLine": 1344,
        "endChar": 60
      },
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e263719_6af448ec",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 4
      },
      "lineNbr": 1344,
      "author": {
        "id": 8683
      },
      "writtenOn": "2020-10-05T09:06:04Z",
      "side": 1,
      "message": "It was needed because I rebased and merged wrong... fixed!",
      "parentUuid": "117e975a_105e9801",
      "range": {
        "startLine": 1344,
        "startChar": 55,
        "endLine": 1344,
        "endChar": 60
      },
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}