{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "3ded3c66_9b8e376e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-08-01T20:37:29Z",
      "side": 1,
      "message": "I know hbos is on vacation this week, but I want him to see all stats-related CLs.\n",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8e7da0c5_be963096",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-08-01T21:08:23Z",
      "side": 1,
      "message": "\nQuerying if we can do better. I\u0027m not happy with some of the names, and I\u0027m not happy with some of the structure.\n\nIn particular, I think this CL would be a lot simpler if you just turned on this reporting and left it on consistently; there\u0027s a huge number of lines that are simply concerned with turning it on when I can\u0027t see a reason to have it off.\n\n",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "594cac3d_c6839db4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5607
      },
      "writtenOn": "2021-08-02T15:46:00Z",
      "side": 1,
      "message": "As far as I\u0027m aware this feature (receive-side RTT based on the Receiver Reference Time Report) needs to be negotiated in SDP, which means that some code is necessary for turning it on when needed. The standard says (see https://datatracker.ietf.org/doc/html/rfc3611#section-5.1):\n   \"Round trip time (RTT) measurement is an example of collaborative\n   functionality.  An RTP data packet receiver sends a Receiver\n   Reference Time Report Block (Section 4.4).  A participant that\n   receives this block sends a DLRR Report Block (Section 4.5) in\n   response, allowing the receiver to calculate its RTT to that\n   participant.  As this example illustrates, collaborative\n   functionality may be implemented by two or more different XR blocks.\n   The collaborative functionality of several XR blocks may be governed\n   by a single \"rtcp-xr\" parameter.\"\n\nOur SDP-code seems to have already implemented this as a codec-specific parameter instead of the \"rtcp-xr\" parameter that the standard describes (I don\u0027t know why it was done that way), using the \"rrtr\" parameter, see https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/media/base/media_constants.cc;l\u003d92;drc\u003d48171ec264b01e712e70239ef009403826c3f0ef\n\nHowever, setting that parameter doesn\u0027t do anything at the moment (at least for audio). This CL makes it actually work.",
      "parentUuid": "8e7da0c5_be963096",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0c1918ce_e88bf5df",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-08-09T07:36:34Z",
      "side": 1,
      "message": "My thinking is that we should have a switch for turning on *sending* the RTT measurement in an xr-block. But we shouldn\u0027t need a switch for deciding whether or not we parse the RTT measurement when it\u0027s *incoming* - there\u0027s low overhead in parsing the xr-block, and I can\u0027t see how parsing it could be harmful.",
      "parentUuid": "594cac3d_c6839db4",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cde2d307_1268e1f1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5607
      },
      "writtenOn": "2021-08-09T12:25:56Z",
      "side": 1,
      "message": "The switch that I wired up in this CL does both the sending and the receiving part of this non-sender RTT measurement. This functionality was already previously implemented in the RTP/RTCP module, it was just not wired up. \n\nThe RTP/RTCP module could be changed so that the receive-side functionality would work even without the flag, but I think it would make sense to do that in another CL.",
      "parentUuid": "0c1918ce_e88bf5df",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8b5399bf_220036b6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-08-10T09:55:53Z",
      "side": 1,
      "message": "Simplification is good. It seems a bit odd to add complexity in this CL and then tear it out later, but if that\u0027s what you want to do, go for it.",
      "parentUuid": "cde2d307_1268e1f1",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3329a99_9d15b003",
        "filename": "audio/audio_receive_stream.h",
        "patchSetId": 4
      },
      "lineNbr": 95,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-08-01T21:08:23Z",
      "side": 1,
      "message": "Question: Why does this exist?\nIt seems to be added to multiple objects calling each other, but the only place that seems to call it from something else is apparently WebRtcVoiceMediaChannel::SetSendCodecs (which is a horribly long function already).\n\nDoes it harm anything to always leave it on? Is it ever reasonable to turn it off?",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f26a361f_9c64edad",
        "filename": "audio/audio_receive_stream.h",
        "patchSetId": 4
      },
      "lineNbr": 95,
      "author": {
        "id": 5607
      },
      "writtenOn": "2021-08-02T15:46:00Z",
      "side": 1,
      "message": "See my other response.",
      "parentUuid": "e3329a99_9d15b003",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0f8eefe_7ce75c8d",
        "filename": "audio/test/nack_test.cc",
        "patchSetId": 4
      },
      "lineNbr": 54,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-08-01T21:08:23Z",
      "side": 1,
      "message": "This seems like a really odd check to place into a tst called \"ShoudNackInLossyNetwork\". I recommend placing these statements in a new test, and add the machinery (and ONLY the machinery) needed to get those counters to increment.",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f58808ff_7e7eb592",
        "filename": "audio/test/nack_test.cc",
        "patchSetId": 4
      },
      "lineNbr": 54,
      "author": {
        "id": 5607
      },
      "writtenOn": "2021-08-02T15:46:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "d0f8eefe_7ce75c8d",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d10ef30_6d1db000",
        "filename": "modules/rtp_rtcp/source/rtcp_receiver.cc",
        "patchSetId": 4
      },
      "lineNbr": 875,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-08-01T21:08:23Z",
      "side": 1,
      "message": "I can\u0027t help but think that this is the wrong way of structuring this. You handle all the other XR blocks through a HandleXr.... function, but then for dlrr, you introduce two extra output arguments, and then do the processing at the layer above, in a completely different fashion to every other block.\n\nSince all these methods are member methods on RTCPReceiver, it seems to me that it is possible to do this more elegantly.",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea2d5475_7f0c2756",
        "filename": "modules/rtp_rtcp/source/rtcp_receiver.cc",
        "patchSetId": 4
      },
      "lineNbr": 875,
      "author": {
        "id": 5607
      },
      "writtenOn": "2021-08-02T15:46:00Z",
      "side": 1,
      "message": "I agree that the code is awkward here. My knowledge of this part of the code is limited, this is my current understanding (please let me know if I\u0027m wrong about any of this):\n-According to the standard the RTT metric needs to be reset if we receive a SR but no XR with DLRR (see https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteoutboundrtpstreamstats-roundtriptime).\n-When we receive a compound RTCP packet, it is possible that we get a SR from one SSRC and a XR (with or without DLRR) from another SSRC.\n\nTherefore we need this awkward bookkeeping to keep track of the SSRCs of every SR and every XR in the compound RTCP packet. This motivates adding the code in the layer above the HandleXr() method. Let me know if you can think of a better way to handle this, or if my understanding is wrong.",
      "parentUuid": "6d10ef30_6d1db000",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76c7800c_386791ee",
        "filename": "modules/rtp_rtcp/source/rtcp_receiver.cc",
        "patchSetId": 4
      },
      "lineNbr": 875,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-08-09T07:36:34Z",
      "side": 1,
      "message": "Random thinking: You could clear the table of DLRR mappings every time you see an SR, and populate it when you see an xr with a dlrr. That would achieve the same effect, with less bookkeeping.",
      "parentUuid": "ea2d5475_7f0c2756",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2359c87_78bd037b",
        "filename": "modules/rtp_rtcp/source/rtcp_receiver.cc",
        "patchSetId": 4
      },
      "lineNbr": 875,
      "author": {
        "id": 5607
      },
      "writtenOn": "2021-08-09T12:25:56Z",
      "side": 1,
      "message": "I like your idea, but I don\u0027t think we can make assumptions about the order of the SRs and XRs in the compound RTCP packet, or can we? What if we first see the XR+DLRR (which populates the metric), and then later see the matching SR (which resets the metric)?",
      "parentUuid": "76c7800c_386791ee",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eeffc17a_03f72e01",
        "filename": "modules/rtp_rtcp/source/rtcp_receiver.cc",
        "patchSetId": 4
      },
      "lineNbr": 875,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-08-10T09:55:53Z",
      "side": 1,
      "message": "Hm.\nI\u0027m trying to parse the RFC 3611 text to see if XR blocks can ever be sent in other places than after a SR/RR, but the RFC doesn\u0027t seem to say so.\nI think I\u0027ll leave this alone for now, to be thought about later.",
      "parentUuid": "b2359c87_78bd037b",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba16f465_59c51fda",
        "filename": "modules/rtp_rtcp/source/rtp_rtcp_interface.h",
        "patchSetId": 4
      },
      "lineNbr": 157,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-08-01T21:08:23Z",
      "side": 1,
      "message": "I don\u0027t think I agree with this rename. If it starts out with an SR block, and depends on starting out with an SR block, the presence of additional XR blocks doesn\u0027t make it any less a Sender Report.\n\nRemoteSender isn\u0027t a well known RTP term; SenderReport is.",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "04253311_e4bb5df7",
        "filename": "modules/rtp_rtcp/source/rtp_rtcp_interface.h",
        "patchSetId": 4
      },
      "lineNbr": 157,
      "author": {
        "id": 5607
      },
      "writtenOn": "2021-08-02T15:46:00Z",
      "side": 1,
      "message": "This was one of the suggestions from the other reviewer. \n\nDanil: are you okay with reverting to the previous name, or do you think it would be better to move the new metrics to a new struct?",
      "parentUuid": "ba16f465_59c51fda",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b7dbcf5_aa5dd680",
        "filename": "modules/rtp_rtcp/source/rtp_rtcp_interface.h",
        "patchSetId": 4
      },
      "lineNbr": 157,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-08-03T10:47:04Z",
      "side": 1,
      "message": "it may start with SR block, but it doesn\u0027t depends on starting out with an SR block: XR rtcp packet may be send by itself.\nI\u0027m not sure why XR/DLRR is bound to SR at all, while they often come together, they convey independent pieces of information.\n\nI\u0027m also unsure why spec draft tells \"If the latest SR does not contain the DLRR report block,... the round trip time is left undefined.\":\nIf ReceiverReports (i.e. packets with XR/RRTR) happens to be less frequent than SenderReport (i.e. packets with XR/DLRR reply), there will be SenderReports without the reply. having rtt be undefined in that moments looks counter-intuitive.\n(Harald, where is the right place to discuss that?)\n\nI won\u0027t strongly oppose reverting to the previous name, but would prefer to move new metrics into a new struct.\nIn particular because current metrics describe rtp stream (single ssrc),\nwhile rtt metrics are about the connection rather than the media stream itself.",
      "parentUuid": "04253311_e4bb5df7",
      "revId": "c53f900bc354428795a029062ea14319028419c9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}