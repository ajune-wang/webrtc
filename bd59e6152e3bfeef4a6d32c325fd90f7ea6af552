{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "319496b5_6bb3c7c3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-17T14:38:29Z",
      "side": 1,
      "message": "PTAL, extracted from https://webrtc-review.googlesource.com/c/src/+/252441, to try to get that landed in smaller pieces.",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5b97917b_8504b8bb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2022-03-17T16:27:58Z",
      "side": 1,
      "message": "make_ref_counted already works for RefCountedInterface and in such a case, adds RefCountedObject.\nWhat are the cases where changing make_ref_counted is the right thing to do and not removing the RefCountedObject inheritance from the class?",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "12eea2e1_7d5190fe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2022-03-18T08:27:49Z",
      "side": 1,
      "message": "assuming that removing me from the reviewer list was unintentional ðŸ˜Š",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d9690db9_04d64066",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2022-03-18T08:39:15Z",
      "side": 1,
      "message": "Conditional templates are still somewhat magical to me. But this seems reasonable.\n",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "14273860_157713c2",
        "filename": "rtc_base/ref_counted_object.h",
        "patchSetId": 1
      },
      "lineNbr": 156,
      "author": {
        "id": 5634
      },
      "writtenOn": "2022-03-18T08:39:15Z",
      "side": 1,
      "message": "If I understand it right, this is safe because if the type is abstract for any *other* reason than missing the RefCountInterface, this will not compile.",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "511f231a_cbcb8f2c",
        "filename": "rtc_base/ref_counted_object.h",
        "patchSetId": 1
      },
      "lineNbr": 156,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-18T09:16:45Z",
      "side": 1,
      "message": "That\u0027s my understanding too.",
      "parentUuid": "14273860_157713c2",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b28830ea_f91b6d39",
        "filename": "rtc_base/ref_counted_object.h",
        "patchSetId": 1
      },
      "lineNbr": 163,
      "author": {
        "id": 5508
      },
      "writtenOn": "2022-03-17T16:29:22Z",
      "side": 1,
      "message": "I\u0027m a bit confused by this. \"make ref counted\" should not be needed for classes that already carry a ref count - right?",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "da504ea8_5268cc8a",
        "filename": "rtc_base/ref_counted_object.h",
        "patchSetId": 1
      },
      "lineNbr": 163,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-18T08:21:18Z",
      "side": 1,
      "message": "Depends on what you mean by \"needed\"?\n\n  make_ref_counted\u003cFoo\u003e(...)\n\nlooks clearer to me than\n\n  rtc::scoped_refptr\u003cFoo\u003e(new Foo(...))\n\neven though they\u0027re equivalent in the case that the Foo class already carries a ref count. In this case, it\u0027s a convenience in about the same way as std::make_unique.",
      "parentUuid": "b28830ea_f91b6d39",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fcfeb538_7e218984",
        "filename": "rtc_base/ref_counted_object.h",
        "patchSetId": 1
      },
      "lineNbr": 163,
      "author": {
        "id": 5508
      },
      "writtenOn": "2022-03-18T08:34:30Z",
      "side": 1,
      "message": "My point is that \"make ref counted\" isn\u0027t the same thing as \"construct a scoped_refptr\". The point of this utility is to add an implementation to the contained class, that has state. While similar, it\u0027s not the same thing as std::make_unique\u003c\u003e (or a hypothetical make_scoped_refptr\u003c\u003e).\n\nBut regardless, I think that this change is adding flexibility to allow for something we don\u0027t want to encourage, which is for RefCountedObject to not be the most derived class.",
      "parentUuid": "da504ea8_5268cc8a",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a436203d_485fb182",
        "filename": "rtc_base/ref_counted_object.h",
        "patchSetId": 1
      },
      "lineNbr": 163,
      "author": {
        "id": 5634
      },
      "writtenOn": "2022-03-18T08:39:15Z",
      "side": 1,
      "message": "If my understanding is right, make_ref_counted\u003c\u003e today does three things:\n- Defines a subclass that has the object + a refcount API\n- Creates an object\n- Increments the refcount\n\nIf my understanding of this change is right, it makes it possible to skip the first step, meaning that we can tell people to use make_ref_counted\u003c\u003e on types that have the refcount API already.",
      "parentUuid": "da504ea8_5268cc8a",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e965ae01_9f5d8f5c",
        "filename": "rtc_base/ref_counted_object.h",
        "patchSetId": 1
      },
      "lineNbr": 163,
      "author": {
        "id": 5508
      },
      "writtenOn": "2022-03-18T08:44:03Z",
      "side": 1,
      "message": "The change makes this acceptable:\n\nclass Foo :\n  public RefCountedObject\u003cInterface1\u003e,\n  public RefCountedObject\u003cInterface2\u003e {\n...\n};\n\nThis is a problem, but we do have classes that inherit from RefCountedObject, which I understand we want to get onboard with make_ref_counted. My preference is to fix those classes rather than give the green light to that pattern in general.",
      "parentUuid": "a436203d_485fb182",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88c6aa22_93e81205",
        "filename": "rtc_base/ref_counted_object.h",
        "patchSetId": 1
      },
      "lineNbr": 163,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-03-18T09:16:45Z",
      "side": 1,
      "message": "It\u0027s not clear to me what mechanisms we have to prevent invalid double inheritance of RefCountedObject, either before or after this change (and I\u0027m afraid I don\u0027t have the time right now to experiment).\n\nThe inheritance hierarchy that prompted this change was\n\n  class RtpTranscieverInterface : public rtc::RefCountInterface {...}\n\n  class RtpTransciever final : public rtc::RefCountedObject\u003cRtpTransceiverInterface\u003e ... {...}\n\nThen without this change, rtc:make_ref_counted\u003cRtpTransciever\u003e fails, because it attempts to create an rtc::RefCountedObject\u003cRtpTransciever\u003e, i.e., a type inheriting RefCountedObject twice. And luckily, the `final` keyword above makes it fail at compile time.\n\nSo we\u0027d have to stick to explicit new when creating instances of RtpTransceiver, as is done here: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/pc/peer_connection.cc;drc\u003d88989bcd7983c93c8d294e1472160d0718299f62;l\u003d652\n\nTo me it makes sense to migrate from explicit new to rtc::make_ref_counted, even when it\u0027s just syntactic sugar.\n\nRegarding reviewer selection, since you\u0027ve all lgtm:ed the cl this change was copied from, I figured it was sufficient with owner approval from one of you... But let\u0027s continue discussion if value of this change is still unclear.\n\nThe alternative I see is to change inheritance of RtpTransceiver and all other classes using this pattern, to not inherit RefCountedObject. I have no strong opinion on the right approach. I know it\u0027s a fairly wide spread pattern (which is why my attempts to make the RefCountedObject class final some years ago was never completed). The pattern is also consistent with how the more recent rtc::RefCountedNonVirtual is intended to be used.",
      "parentUuid": "e965ae01_9f5d8f5c",
      "revId": "bd59e6152e3bfeef4a6d32c325fd90f7ea6af552",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}