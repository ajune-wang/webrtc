{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e3a03502_de1cb344",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 10558
      },
      "writtenOn": "2020-11-05T22:00:21Z",
      "side": 1,
      "message": "Thanks for the review.",
      "revId": "adacd15ba99d203a227a611fddfc2338e5078bb9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b90b2ab7_b344dbf5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5126
      },
      "writtenOn": "2020-11-06T01:13:48Z",
      "side": 1,
      "message": "Thanks! I think this is the right thing to do, but as I said in the other CL just now, you should not handle the possibility of !foo if you have just DCHECKed foo. In this CL, the DCHECKs basically mean that these functions must only be used with valid channels; trying to use them with a possibly invalid channel is a bug in the caller.\n\nYou could also take the position that they should be robust against being called with invalid channels; you then need to handle this case, e.g. by returning some sort of error that the caller can distinguish from a good return value. But this is more complex, and if the caller is able to avoid using invalid channels without undue effort, requiring the channel to always be valid is probably better.",
      "revId": "adacd15ba99d203a227a611fddfc2338e5078bb9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9addeed4_c3dcfaf1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5126
      },
      "writtenOn": "2020-11-06T01:15:34Z",
      "side": 1,
      "message": "Oh, and now that the channel being valid is a precondition, please double check that this is mentioned in the interface docs for each method.",
      "revId": "adacd15ba99d203a227a611fddfc2338e5078bb9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bcf7c744_e38a1588",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 10558
      },
      "writtenOn": "2020-11-07T00:05:06Z",
      "side": 1,
      "message": "I actually feel little nervous about this. I like the idea about enforcing validity of ChannelId on debug build but not on production to avoid unfortunate crashes. It\u0027s part due to my mentality from telecom industry that product should never crash.. Maybe this is fine but I do feel this a bit harsh on application developers. Could there be some middle ground that both parties can be happy here?",
      "parentUuid": "b90b2ab7_b344dbf5",
      "revId": "adacd15ba99d203a227a611fddfc2338e5078bb9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5c09641_96469383",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 10558
      },
      "writtenOn": "2020-11-07T00:51:47Z",
      "side": 1,
      "message": "I guess I suppose we could stick to current approach where we left comments on each interface about invalid channel usage leading to no-op instead of using DCHECK to enforce the compliance since the usage intention is different here.",
      "parentUuid": "bcf7c744_e38a1588",
      "revId": "adacd15ba99d203a227a611fddfc2338e5078bb9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d50762e_32190d55",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5126
      },
      "writtenOn": "2020-11-07T18:46:22Z",
      "side": 1,
      "message": "You\u0027ve probably understood this quite well by now :-) but my thinking is mostly around making it as hard as possible to write expensive-to-fix bugs. In this case, that means either (1) using the type system to force the caller to handle the error case, e.g. by returning an optional result, or (2) crashing noisily (at least in debug builds) if the caller forgets to do as the docs say and verify their inputs.\n\nThis general philosophy comes from the fact that in browsers and video calling apps and servers, we generally do not have to avoid crashing at all costs---specifically, we would often rather have simple and maintainable code than convoluted code with myriad poorly-tested error handling paths that prevent all crashes, because that way, when there is a bug, it shows up clearly as a crash in our telemetry instead of as hard-to-debug erroneous behavior because some error handling path prevented the crash but failed to behave properly.\n\nDoes this make sense?\n\nI suspect that the solution that\u0027s easiest for us to compromise on is the optional return value, since that basically allows the library to punt on error handling and force the caller to deal with it, in whatever way makes most sense for the application. WebRTC doesn\u0027t use absl::StatusOr---otherwise that would have been an obvious candidate as well.",
      "parentUuid": "d5c09641_96469383",
      "revId": "adacd15ba99d203a227a611fddfc2338e5078bb9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3c12d00_e3b89873",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 10558
      },
      "writtenOn": "2020-11-09T19:41:33Z",
      "side": 1,
      "message": "Thanks, I think we are in agreement with the issue here. I think another alternatives would be\n\n1) Return new enum class or int code that specifies success or failure and use the parameters to fetch the resulted operation. \n\nThis is traditionally done and straight-forward \u0026 familiar with developers. The reason can also be shown in detail by the comments in return types.\n\n2) Return error asynchronously by using application callback.\n\nI think this has the disadvantage of disconnecting developer on the way they can react to error they encounter but it does punt the responsibility to application to handle the error when it occurs.\n\nI would prefer approach 1) here as it would cover all the scenarios. WDYT?",
      "parentUuid": "7d50762e_32190d55",
      "revId": "adacd15ba99d203a227a611fddfc2338e5078bb9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd0ea5ed_85bb90b1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 10558
      },
      "writtenOn": "2020-11-09T20:27:48Z",
      "side": 1,
      "message": "I just realized my suggestion on alternative 1) wouldn\u0027t work well as it will break the API signature and VoIP API is already started being used in some Google internal project and I suspect there already may be some others in open source community. I guess that would leave us on option 2) here.",
      "parentUuid": "d3c12d00_e3b89873",
      "revId": "adacd15ba99d203a227a611fddfc2338e5078bb9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18b56eba_b9a8bf82",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 10558
      },
      "writtenOn": "2020-11-10T00:17:49Z",
      "side": 1,
      "message": "There is a merge conflict that I would like to wait for https://webrtc-review.googlesource.com/c/src/+/191100 to land first and then will work on adding asynchronous error callback option for such notification. Thanks!",
      "parentUuid": "fd0ea5ed_85bb90b1",
      "revId": "adacd15ba99d203a227a611fddfc2338e5078bb9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}