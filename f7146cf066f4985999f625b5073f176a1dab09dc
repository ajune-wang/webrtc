{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "11aa76b9_53a1891c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 53
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-04-14T06:49:15Z",
      "side": 1,
      "message": "WRT threading: The reason why transceives()-\u003eList() returns a list by value is that there are other places that iterate over the list and can cause changes to the set of transceivers; doing it this way makes the iteration safe, and the fact that it returns a list of scoped_refptr rather than a list of pointers ensures that the transceivers won\u0027t go away while you\u0027re iterating.\n\nThat said, I agree with Henrik that the TransceiverList class needs to have a sequence checker member, which will end up pointing to the signaling thread; we should enumerate before invoking the network thread, not after.\n\nOther comments below.\n\n\n\n",
      "revId": "f7146cf066f4985999f625b5073f176a1dab09dc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5c56ae54_e902a76c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 53
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-04-14T07:23:04Z",
      "side": 1,
      "message": "I understand the thinking behind it there are unfortunately other things beyond the transceiver objects that are not safe so this doesn\u0027t actually make things better - but because of how the interface is, it gives the appearance of that kind of safety.\n\nCreating the copy every time an iteration is done (+ the use of scoped_refptr), is an inefficiency in places where it is guaranteed that the list cannot change (such as on the signaling thread) - which turns out to be most places.\nRelated to how scoped_refptr is used, there\u0027s a similar issue with RTCStatsCollector whereby the class is reference counted for the purposes of running asynchronous tasks, but it\u0027s actually not safe to run those tasks after the PeerConnection instance (that ultimately owns the stats collector instance), has gone out of scope - and it doesn\u0027t necessarily have to do with RTCStatsCollector itself but actually the object that it holds on to related to those async operations. We have other tools now such as weak_ptr and the task flag to cancel pending operations, that we could use to avoid running pending operations and avoid synchronization for teardown (and ideally use unique_ptr for the stats collector).\n\nAs far as the List() method goes, I think it could actually have been better to be more restrictive with how the list is used, make sure it\u0027s consistently used in a way that aligns with the state that the transceiver objects refer to, including pointers to sub objects, such as BaseChannel objects and transports. Exposing a const\u0026 pointer to the member variable is one way, but doing so does give out access to that variable. An alternate thing to offer, and what applies in particular to collections, is a function that does the iteration for you in the way that is supported, and applies all the restrictions and checks every time.",
      "parentUuid": "11aa76b9_53a1891c",
      "revId": "f7146cf066f4985999f625b5073f176a1dab09dc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "42cd7104_034b13e2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 53
      },
      "lineNbr": 0,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-04-14T08:38:04Z",
      "side": 1,
      "message": "I still have some questions",
      "revId": "f7146cf066f4985999f625b5073f176a1dab09dc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd62bad4_f9cd6ad6",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 53
      },
      "lineNbr": 2058,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-04-14T08:38:04Z",
      "side": 1,
      "message": "RtpTransceiver::SetChannel() modifies channel_ on the signaling thread.\n\nCan you add a comment that this is only safe while we are blocking the signaling thread or explain why this is otherwise safe?",
      "revId": "f7146cf066f4985999f625b5073f176a1dab09dc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae5a4c89_dd003ef2",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 53
      },
      "lineNbr": 2058,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-04-18T09:47:00Z",
      "side": 1,
      "message": "This should be addressed now",
      "parentUuid": "fd62bad4_f9cd6ad6",
      "revId": "f7146cf066f4985999f625b5073f176a1dab09dc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d57d344e_47fdc385",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 53
      },
      "lineNbr": 2058,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-04-19T08:05:31Z",
      "side": 1,
      "message": "I see that channel\u0027s transport_name() now has RTC_DCHECK_RUN_ON(network_thread()); and that content_name() accesses a const variable, so that part of it is good.\n\nHowever obtaining the ptr to the channel through transceiver-\u003echannel() means we are accessing the internal variable channel_ of RtpTransceiver. This ptr is set using RtpTransceiver::SetChannel() which is called by SdpOfferAnswerHandler on the signaling thread. So one might consider adding RTC_DCHECK_RUN_ON(signaling_thread()) to RtpTransceiver::channel().\n\nIf channels were reference counted we could have copied the references on the signaling thread to ensure they are still alive by the time we reach the network thread here (just like we did with the transceiver list), but unfortunately they are not ref counted and are explicitly created[1] and destroyed[2] by calls from the signaling thread (in SdpOfferAnswerHandler) doing block-invokes onto the worker thread (inside ChannelManager\u0027s create and destroy).\n\nThis is an unfortunate pattern that I see used in many places in PeerConnection: the lifetime of objects are indirectly managed by signaling thread, but the actual usage of the object happens on worker/network thread, and they aren\u0027t ref counted. In many times this forces us to sync up with the signaling thread - a thread that we should ideally never block (since it blocks JS), but often times have to because of this.\n\nSo while accessing the channel *if it still exists* is safe, using transceiver-\u003echannel() is only safe because we are currently blocking the signaling thread.\n\nYou may want to land this CL as-is but with a comment explaining that this is only safe because we are currently blocking the signaling thread, or you may want to fetch the Channel ptrs on the signaling thread like you do transceivers but the lifetime of them are still only guaranteed because of blocking.\n\nHow to make this non-blocking in a future CL? Maybe we should consider ref counted channels? Then the channel could tell us if it it has been removed without risk of use-after-free.\n\n[1] https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/pc/sdp_offer_answer.cc;l\u003d4581;drc\u003d1aa1254f5b527b89b190837892d5928c8d0f7bfc;bpv\u003d1;bpt\u003d1\n[2] https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/pc/sdp_offer_answer.cc;l\u003d4727;drc\u003d1aa1254f5b527b89b190837892d5928c8d0f7bfc;bpv\u003d1;bpt\u003d1",
      "parentUuid": "ae5a4c89_dd003ef2",
      "revId": "f7146cf066f4985999f625b5073f176a1dab09dc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "344d767f_023e578a",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 53
      },
      "lineNbr": 2058,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-04-19T09:35:41Z",
      "side": 1,
      "message": "Agree.\n\nJust to summarize all these things as they stand:\n* The ChannelManager (CM) to creates the channel objects and owns them (but does not use them).\n* PC uses CM to create the channels and give a pointer to them to the transceiver\n* PC accesses the channel object from the transceivers via channel()\n* PC uses CM to destroy the channel objects after calling SetChannel(nullptr).\n\nI think that this TODO sums up what would simplify these things:\nhttps://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/pc/sdp_offer_answer.cc;drc\u003d1aa1254f5b527b89b190837892d5928c8d0f7bfc;l\u003d4613\n\nSo, taking that a step further, this would mean that:\n* Transceivers create and own the channel objects.\n* ChannelManager doesn\u0027t hold on to ownership or control destruction.\n* Interaction between the transceiver and channel object, moves to transceiver and out of PC.\n\nThere are further benefits that we could get by doing this:\n* The SignalFirstPacketReceived could be replaced with a const, set-at-construction time, function callback to RtpTransceiver.\n* This would be the last dependency on sigslot in Channel (following CLs that I\u0027m working on to simplify MediaChannel/Channel interaction).\n* The Channel\u0027s dependency on the worker thread could be changed to be the signaling thread, which is where RtpTransceiver works. There\u0027s no heavy lift there.\n* This would remove blocking calls to worker from signaling thread and simplify both Channel and RtpTransceiver.\n\nActually, it could be possible to remove dependency on all but network thread from\nthe Channel classes and just take care of signaling thread interaction when that\u0027s\nneeded, in the RtpTransceiver class.",
      "parentUuid": "d57d344e_47fdc385",
      "revId": "f7146cf066f4985999f625b5073f176a1dab09dc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e22cd6dc_398ec8e0",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 53
      },
      "lineNbr": 2058,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-04-19T09:54:28Z",
      "side": 1,
      "message": "Sounds good to me. Making the transceiver responsible seems to simplify things. I do like ref counting to ensure we never do use-after-free (the object could say it has been removed in a thread safe way without necessarily having been deleted yet if someone still references it). But with the future fixes outlined above I don\u0027t know if that will be necessary. In any case, let\u0027s land this CL.",
      "parentUuid": "344d767f_023e578a",
      "revId": "f7146cf066f4985999f625b5073f176a1dab09dc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df0ed734_a64917e4",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 53
      },
      "lineNbr": 2058,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-04-19T09:55:34Z",
      "side": 1,
      "message": "Seems to me that if we do these changes, removing ownership of Channel objects from ChannelManager, ChannelManager should be renamed to ChannelFactory.\n\nMost of the other functions of ChannelManager seem to be a front for the media engine that it gets as a constructor argument.",
      "parentUuid": "344d767f_023e578a",
      "revId": "f7146cf066f4985999f625b5073f176a1dab09dc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}