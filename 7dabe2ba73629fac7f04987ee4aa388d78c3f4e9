{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "da2aebcc_5ee9afba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-10-04T15:50:00Z",
      "side": 1,
      "message": "I haven\u0027t tested this yet, but don\u0027t we need to return a frame in case there is a cursor position change and the FrameAndCursorComposer or how it\u0027s called combines a final frame from both?",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44765e94_3167958f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 18474
      },
      "writtenOn": "2022-10-04T18:06:57Z",
      "side": 1,
      "message": "I think this is right...\n(e.g. that we need the update if the cursor is updated)\n\nShare() also isn\u0027t that expensive: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/desktop_capture/desktop_frame.cc;drc\u003db9539659f98e35ba63b84c1adf299a7a2590e07e;l\u003d129\n\nIn fact; we explicitly have logic to do the opposite of this in the Windows DirectX Capturer (which I\u0027d assume is also used by CRD); because I think the intention with CaptureFrame is that if you\u0027ve asked for a frame we will *always* give you a frame.\n\nWhat I think you *really* want is either:\n1) Damage Regions - Jan had discussed with me that I think this is on his list of things to work on? (Though right now we need to prioritize getting the tests out so we can ship the capturer)\nor\n2) An event-based API surface for DesktopCapturer - This is something I want to do and I\u0027m trying to figure out how to fit it into my roadmap.",
      "parentUuid": "da2aebcc_5ee9afba",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "336a4947_2be7734a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 19629
      },
      "writtenOn": "2022-10-04T18:40:29Z",
      "side": 1,
      "message": "Thanks for bringing it up. PS1 would have likely broken the composition with cursor. I have now added a desktop capture option which by default retains the original behavior.\n\n\u003e if you\u0027ve asked for a frame we will always give you a frame.\n\nIs there an efficient mechanism to determine if the newly captured frame is any different than the one that was captured last time?\n\n\u003e 1) Damage Regions - Jan had discussed with me that I think this is on his list of things to work on\n\u003e 2) An event-based API surface for DesktopCapturer \n\nBoth options sound great. First one can be somewhat imitated by the diff capturer wrapper but running the diff between frames adds few milliseconds latency (for 4k screens) that we can avoid here if we know for sure that the frame hasn\u0027t changed since the last captured frame.\n\nI will still be curious to learn what is the plan for figuring out damage regions (possibly without a pixel to pixel comparison) ðŸ˜Š",
      "parentUuid": "44765e94_3167958f",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "76392d2b_782babe3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 18474
      },
      "writtenOn": "2022-10-04T18:52:34Z",
      "side": 1,
      "message": "If I\u0027m remembering correctly, Jan would you be willing to discuss a bit on Thursday (assuming you\u0027re also free Salman)?\n\nThere might be some way that you could leverage this: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/desktop_capture/shared_desktop_frame.cc;drc\u003db9539659f98e35ba63b84c1adf299a7a2590e07e;l\u003d36\n\nThough there may be a slight risk of the frame getting overwritten if you\u0027re holding a reference to it; so we could look at some strategy if it would overwrite a shared frame.\n(I think there\u0027s enough info that we at least currently log if we\u0027re manipulating a currently shared frame, and I think by-and-large we copy before CaptureFrame returns so that the capturer can re-use it).\n\nThere may also be another/better spot to plumb out that the frame is unchanged from the previous call as an intermediate step to reaching either of those two approaches.\n\nI think it would be too much of a breaking change to add an \"UNCHANGED\" state to the Result enum.",
      "parentUuid": "336a4947_2be7734a",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3af4e2fa_3943213b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-10-05T06:27:42Z",
      "side": 1,
      "message": "Sure, we can discuss this tomorrow. I think we should have both 1) and 2) in the future for the best performance.\n\nRegarding this change. We set updated region here https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/desktop_capture/linux/wayland/shared_screencast_stream.cc;l\u003d831. Can we maybe reset the updated region in case the frame has been consumed already and we would just return the same one? Would that make a difference?",
      "parentUuid": "76392d2b_782babe3",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4c27e2f3_efb1608c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 18474
      },
      "writtenOn": "2022-10-05T16:23:52Z",
      "side": 1,
      "message": "ISTM that tracking the bool Salman has added and using it to determine whether or not to reset that rect would likely give us what we want?\n\nI hesitate to directly clear it after sharing the frame as I believe it\u0027s shared; but I *think* it should be safe to say that we can at least modify the damage rect if a new frame is being asked for.",
      "parentUuid": "3af4e2fa_3943213b",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aa7a9ce0_903d7859",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-10-07T08:34:19Z",
      "side": 1,
      "message": "I think it might be safer not to touch damaged rect, but I\u0027m unsure about this form of this patch, specifically I don\u0027t like passing yet another parameter to StartScreenCastStream() method that is specific to a particular use-case of a capturer. Can we move the logic to the capturer itself and have ScreenCastStream to expose frame_updated_since_last_grab variable so you can use it in the BaseCapturerPipeWire::CaptureFrame() instead?",
      "parentUuid": "4c27e2f3_efb1608c",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f3069625_995de2ff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 18474
      },
      "writtenOn": "2022-10-07T16:12:31Z",
      "side": 1,
      "message": "Ah; sorry, by \"tracking the bool Salman has added\" I meant `frame_updated_since_last_grab_` and using that to clear the damaged rect; I hadn\u0027t looked over the change to DesktopCaptureOptions.\n\nAlternatively, if seeing if the underlying frame is the same could be doable; though there is the risk that the frame is being re-used by the queue.",
      "parentUuid": "aa7a9ce0_903d7859",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dd03dd33_fab3df29",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-10-07T19:17:23Z",
      "side": 1,
      "message": "I know, I was rather worried about consuming a frame with a certain damage region and consuming it again with a different (none) damage region, if it\u0027s something safe to do and if it doesn\u0027t result into unexpected behavior.",
      "parentUuid": "f3069625_995de2ff",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cc9c012d_b7d111f8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 19629
      },
      "writtenOn": "2022-10-10T17:44:24Z",
      "side": 1,
      "message": "I see X11 overwriting the complete (shared) frame at times, so I assume it is safe to clear the damaged region? At any rate, this change will not be needed anyway once we have the video damage reporting coming from compositors. We can keep this change on hold till then if you would like.",
      "parentUuid": "dd03dd33_fab3df29",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cfa4da9d_9031c4a9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-10-10T18:47:38Z",
      "side": 1,
      "message": "If it\u0027s fine to wait a bit I think I can look into implementing damage regions soon as I believe I\u0027m close to have the basic tests done. I \u0027m using KDE where this is implemented so I have a way to test it and hopefully it will convince Jonas to implement it in GNOME.",
      "parentUuid": "cc9c012d_b7d111f8",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}