{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "afefa403_6a5cf286",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-07-22T08:11:52Z",
      "side": 1,
      "message": "Ivo, PTAL at change to the audio processing. Deletes one use of RTC_NO_THREAD_SAFETY_ANALYSIS, and adds a method AudioProcessingImpl::AssertLockedForTest.",
      "revId": "c3e2336e39159e919f7fcfedd148e02326dc4bcf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1f079a48_58466081",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5607
      },
      "writtenOn": "2021-07-22T08:46:22Z",
      "side": 1,
      "message": "audio_processing/ lgtm",
      "revId": "c3e2336e39159e919f7fcfedd148e02326dc4bcf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9da132f3_3dc7b79b",
        "filename": "rtc_base/synchronization/mutex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 5087
      },
      "writtenOn": "2021-07-23T08:14:34Z",
      "side": 1,
      "message": "Ok, after talking with some thread annotations expert I am a bit concerned about this annotation being added by default while the function doesn\u0027t actually always assert.\n\nWhile this should not result in any UB, I am concerned this will become a way to silence the compiler warning without getting a crash.\n\nSo before landing this one we should set up a bot to always run tests with absl::Mutex, but even in that case I am still not sure this is a good thing to do since we open a possibility to lie to the compiler which brings us to the second option of implementing AssertHeld on all the Mutex classes and let the assert happen in all build modes.",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 55
      },
      "revId": "c3e2336e39159e919f7fcfedd148e02326dc4bcf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22f5818b_058022a4",
        "filename": "rtc_base/synchronization/mutex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-07-23T08:28:57Z",
      "side": 1,
      "message": "My intended use cases are (i) replacing RTC_NO_THREAD_SAFETY_ANALYSIS (not sure we currently have other easily replacable uses than the one in this cl), and (ii) untangle locking on call chains that currently depend on recursive locking.\n\nIn most cases RTC_EXCLUSIVE_LOCKS_REQUIRED (strict compile-only check) is a better tool, but we have a few cases where locking assumptions on call chains involving several classes. E.g., a method A::Foo that is always called from class B, with some lock held, which calls back into class B, method B::bar. We can\u0027t easily tell the compiler that calling A::Foo requires that some lock belonging to another class B is held, and therefore B::Foo can\u0027t be annotated with RTC_EXCLUSIVE_LOCKS_REQUIRED. But B::bar can use AssertHeld.\n\nBut I agree it would be great to have a test bot running with absl::Mutex up first.",
      "parentUuid": "9da132f3_3dc7b79b",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 55
      },
      "revId": "c3e2336e39159e919f7fcfedd148e02326dc4bcf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c8f792f_5a205888",
        "filename": "rtc_base/synchronization/mutex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 5087
      },
      "writtenOn": "2021-07-23T08:44:27Z",
      "side": 1,
      "message": "I can do that but I will need some days, on the other hand I am still tempted to say that supporting AssertHeld on all the mutexes is probably a better solution. You looked into it and it sounds non trivial but can we maybe spend more time and achieve this solution?",
      "parentUuid": "22f5818b_058022a4",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 55
      },
      "revId": "c3e2336e39159e919f7fcfedd148e02326dc4bcf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d1ea9ecf_89f47d29",
        "filename": "rtc_base/synchronization/mutex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-07-23T09:53:56Z",
      "side": 1,
      "message": "Given it a try in cl https://webrtc-review.googlesource.com/c/src/+/226860.\n\nI wonder if it is fine to have a data race in the case that AssertHeld fails.",
      "parentUuid": "2c8f792f_5a205888",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 55
      },
      "revId": "c3e2336e39159e919f7fcfedd148e02326dc4bcf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0104d046_fc451053",
        "filename": "rtc_base/synchronization/mutex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 5087
      },
      "writtenOn": "2021-07-23T12:35:51Z",
      "side": 1,
      "message": "\u003e Given it a try in cl https://webrtc-review.googlesource.com/c/src/+/226860.\n\nThanks, that looks nice.\n\n\u003e I wonder if it is fine to have a data race in the case that AssertHeld fails.\n\nHmm, looks like Chromium is doing that as you pointed out in the comment. The data race only happens if not held which results in a CHECK so it is not a real problem since the program is going to terminate. That said, data races are UB. The compiler is probably not able to exploit it to get more optimization but that might happen in the future so I am tempted to say the std::atomic solution is better.\n\nThis code was added 10 years ago in Chromium: https://codereview.chromium.org/2196001 and changed 7 years ago (https://codereview.chromium.org/292873002).",
      "parentUuid": "d1ea9ecf_89f47d29",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 55
      },
      "revId": "c3e2336e39159e919f7fcfedd148e02326dc4bcf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "73908093_1bafe519",
        "filename": "rtc_base/synchronization/mutex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-07-23T12:57:21Z",
      "side": 1,
      "message": "The problem with the atomic solution is that according to posix, there\u0027s no reserved pthread_t value to represent \"no thread\". So to be portable, we\u0027d need a pthread_t + a bool, and then we can\u0027t read both in an atomic and lock-less way (maybe there\u0027s a way to use two separate atomics and read and write in the right order, but those subtleties make my head spin). \n\n(One could add one more mutex for the owner reference, but I think that\u0027s a bit too much overhead).\n\nTo have a race in the failure case only seems easier to reason about; in practice it\u0027s pretty unlikely to do anything other than crashing. In theory, it\u0027s UB, but since the desired behavior is to crash, that\u0027s probably acceptable.",
      "parentUuid": "0104d046_fc451053",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 55
      },
      "revId": "c3e2336e39159e919f7fcfedd148e02326dc4bcf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "626405ee_75ee15f0",
        "filename": "rtc_base/synchronization/mutex.h",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 5087
      },
      "writtenOn": "2021-07-23T13:23:24Z",
      "side": 1,
      "message": "I see, can you duplicate the proposal CL and create a solution with the race condition?",
      "parentUuid": "73908093_1bafe519",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 55
      },
      "revId": "c3e2336e39159e919f7fcfedd148e02326dc4bcf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}