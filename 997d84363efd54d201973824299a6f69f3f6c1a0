{
  "comments": [
    {
      "key": {
        "uuid": "a16f6640_5319856e",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 162,
      "author": {
        "id": 5077
      },
      "writtenOn": "2018-12-05T11:50:40Z",
      "side": 1,
      "message": "This applies to other interfaces as well - should it instead go in a global .md file? \"DESIGN.md\"? Or just move it to the top of this .h if it is considered \"root\" enough.",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e95f9a57_3032855f",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 162,
      "author": {
        "id": 5039
      },
      "writtenOn": "2018-12-05T23:03:57Z",
      "side": 1,
      "message": "This applies to all the PeerConnection-ish API objects (RtpSenderInterface, RtpReceiverInterface, MediaStreamTrackInterface, etc.) I think it could work here since the PeerConnectionInterface is really the entrypoint to all those instances.",
      "parentUuid": "a16f6640_5319856e",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd7ff4b1_784a6a65",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-12-05T09:28:57Z",
      "side": 1,
      "message": "Hang on, this wouldn\u0027t be true if the \"calling thread\" is the e.g. the signaling thread... Can you clarify?",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "752fd7ec_d2a92469",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-05T10:29:25Z",
      "side": 1,
      "message": "If the calling thread is the signalling thread, this still applies. No other task is going to execute on the signalling thread while the function call is in progress.",
      "parentUuid": "dd7ff4b1_784a6a65",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "810d8456_98c53ec5",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-12-05T14:56:37Z",
      "side": 1,
      "message": "Is this the same as saying that all methods are asynchronous?\nSaying \"nothing happens\" sounds like a pretty big promise :)",
      "parentUuid": "752fd7ec_d2a92469",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69d731b4_0be38393",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 5039
      },
      "writtenOn": "2018-12-05T23:03:57Z",
      "side": 1,
      "message": "Another phrasing is that the PeerConnectionInterface methods block the calling thread though the work could happen on other threads. So really it\u0027s closer to synchronous than asynchronous.",
      "parentUuid": "810d8456_98c53ec5",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b68b004f_6aa84d53",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 5126
      },
      "writtenOn": "2018-12-06T03:36:34Z",
      "side": 1,
      "message": "Wait, so if I call a PeerConnectionInterface method Foo(), do the effects of that call happen (1) all before Foo() returns, (2) all after Foo() returns, or (3) both before and after? In my comments this far, I\u0027ve been assuming (2), since that\u0027s how I read Harald\u0027s proposed text.\n\n(2) would conventionally be labeled something like \"nonblocking asynchronous\", and (3) \"(possibly blocking) asynchronous\". (1) would be simply \"synchronous\", and from the perspective of the caller cannot be distinguished from a normal function call that just does all the work on the caller\u0027s thread.",
      "parentUuid": "69d731b4_0be38393",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c8c9efc_74326fc6",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 176,
      "author": {
        "id": 5126
      },
      "writtenOn": "2018-12-05T12:30:49Z",
      "side": 1,
      "message": "This caveat seems scary. Allowing subclasses to impose additional restrictions means that you can\u0027t safely treat them as an instance of the base class, but since this is just a comment, the compiler doesn\u0027t know that. All restrictions should apply to the base class too, so that subclasses don\u0027t have to add restrictions.",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36ca450a_77a2e9ff",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 176,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-05T12:53:00Z",
      "side": 1,
      "message": "But it\u0027s true - the two subclasses of api/peerconnecctioninterface.h are api/peerconnectionproxy (which can be called on any thread, but dispatches) and pc/peerconnection - which can only be invoked on the signalling thread.",
      "parentUuid": "3c8c9efc_74326fc6",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8bd8b921_74a5f46b",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 176,
      "author": {
        "id": 5126
      },
      "writtenOn": "2018-12-05T13:51:18Z",
      "side": 1,
      "message": "This means that if all we know about an object is that it\u0027s an instance of PeerConnectionInterface, we don\u0027t know that it\u0027s safe to call its methods from any thread other than the signaling thread.\n\nIt would be best to document this (that it may only be called from the signaling thread) as part of the contract for PeerConnectionInterface, and then document that the subclass in api/peerconnectionproxy lifts these restrictions. A subclass can safely be made strictly *more* capable, because then it still upholds the base class contract.",
      "parentUuid": "36ca450a_77a2e9ff",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8e437441_8de1119b",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 176,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-12-05T14:56:37Z",
      "side": 1,
      "message": "+1 to Karl\u0027s suggestion",
      "parentUuid": "8bd8b921_74a5f46b",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0f1724ad_3a2b75a3",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 176,
      "author": {
        "id": 5039
      },
      "writtenOn": "2018-12-05T23:03:57Z",
      "side": 1,
      "message": "I think in an ideal world that would make sense, but in practice no one outside of webrtc internal is going to have a PeerConnectionInterface that isn\u0027t a PeerConnectionProxy. So clients should be able to rely on the proxy behavior.",
      "parentUuid": "8e437441_8de1119b",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0760c494_772da742",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 176,
      "author": {
        "id": 5126
      },
      "writtenOn": "2018-12-06T03:36:34Z",
      "side": 1,
      "message": "Mmmm. In that case, I\u0027d say there should be two interfaces, identical in every way except that the internal one requires the callee to be on the signal thread, and the public one has no such restriction. PeerConnectionProxy would be the only instance of the public interface.\n\nI would contend that using a single C++ abstract base class for these two conceptually separate things is hazardous, because now you have two things that must not be conflated and we\u0027re actively telling the compiler \"no, no, you don\u0027t have to help me keep this straight, I\u0027ve got it\". Even if we only expose one of them to our users, we still have the problem in our own tree. Also, such things have a tendency to not stay 100% hidden from users, as evidenced by lines 175-176 in this CL. :-)\n\n(Side note: Once two such interfaces have been de-duplicated, it isn\u0027t uncommon to find that having them 100% identical wasn\u0027t the optimal choice after all. And one of them is internal and easy to change. So there may be other benefits besides increased type safety.)",
      "parentUuid": "0f1724ad_3a2b75a3",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "67e91eeb_b758cec4",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-12-05T09:26:01Z",
      "side": 1,
      "message": "nit: Remove empty line?",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1418fea_35950278",
        "filename": "api/peerconnectioninterface.h",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-05T10:29:25Z",
      "side": 1,
      "message": "when cleaning up :-)",
      "parentUuid": "67e91eeb_b758cec4",
      "revId": "997d84363efd54d201973824299a6f69f3f6c1a0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}