{
  "comments": [
    {
      "key": {
        "uuid": "36f0baf9_4143442d",
        "filename": "call/bitrate_allocator.cc",
        "patchSetId": 5
      },
      "lineNbr": 244,
      "author": {
        "id": 5531
      },
      "writtenOn": "2018-04-26T15:35:57Z",
      "side": 0,
      "message": "Removing this means that we\u0027ll have a change in behavior right? Currently, if we add streams in paused state, we will assign starting bitrate based on this calculation as the last bitrate/stream count. After the change they will all get a starting bitrate of 300 kbps.\n\nIn effect this could mean that we don\u0027t signal the requirement to reduce resolution to the capturer until we resume the stream. This means that we could either end up not adapting down when bw \u003c 300kbps or adapting down even though we shouldn\u0027t if the bw \u003e\u003d 500kbps. Right?\n\nI think it might be worth mentioning something about the expected changes in behavior in the commit message to make triaging easier if it causes issues in downstream projects.",
      "range": {
        "startLine": 244,
        "startChar": 22,
        "endLine": 244,
        "endChar": 37
      },
      "revId": "29a8d10138bc11791fbdf26165623ee6dc044881",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1a0a8be_ad16d451",
        "filename": "call/bitrate_allocator.cc",
        "patchSetId": 5
      },
      "lineNbr": 244,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-04-27T06:49:20Z",
      "side": 0,
      "message": "Agree, I\u0027ll try to formulating something.\n\nDo you think it *only* affects paused streams? E.g., if we add three streams up-front, with the old code I think they\u0027d get start bitrates of 300 kbps, 150 kps and 100kbps, while after the change they\u0027ll all get 300 kbps. Does non-pause make this not matter (because VideoStreamEncoder::OnBitrateUpdated willbe called very soon after)?",
      "parentUuid": "36f0baf9_4143442d",
      "range": {
        "startLine": 244,
        "startChar": 22,
        "endLine": 244,
        "endChar": 37
      },
      "revId": "29a8d10138bc11791fbdf26165623ee6dc044881",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0c3d500_df47c6ed",
        "filename": "call/bitrate_allocator.cc",
        "patchSetId": 5
      },
      "lineNbr": 244,
      "author": {
        "id": 5531
      },
      "writtenOn": "2018-04-27T07:38:24Z",
      "side": 0,
      "message": "Yes, it affects on start as well since the transport is started in a paused state. Although, this depends on how the rest is implemented. With the non-TQ version of SSCC, what should happen is that when the first stream is added, bitrate allocator will get a bitrate from SSCC. With the async SSCC, this is subject to a race condition and it depends on whether the callback from SSCC or the addition of the second stream happens first.",
      "parentUuid": "c1a0a8be_ad16d451",
      "range": {
        "startLine": 244,
        "startChar": 22,
        "endLine": 244,
        "endChar": 37
      },
      "revId": "29a8d10138bc11791fbdf26165623ee6dc044881",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}