{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9aa6b6a7_2606a871",
        "filename": "api/video_codecs/video_encoder_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 5019
      },
      "writtenOn": "2024-05-17T10:42:53Z",
      "side": 1,
      "message": "another idea - take the buffer as input, but also return the same buffer as output:\n```\nclass BufferProviderInterface {\n public:\n  virtual rtc::ArrayView\u003cuint8_t\u003e GiveMeTheBufferToWriteTo(size_t size) \u003d 0;\n  // or maybe, though unlikely.\n  rtc::ArrayView\u003cuint8_t\u003e AppendBuffer(size_t size);\n  \n  virtual rtc::ArrayView\u003cconst uint8_t\u003e GiveMeTheTheSameBufferAsAResult() const \u003d 0;\n};\n\nstruct FrameEncodeSettings {\n  ...\n  // Can be null\n  std::unique_ptr\u003cBufferProviderInterface\u003e output_buffer_provider;\n  ...\n};\n\nstruct FrameEncodedData {\n  // Guaranteed to be the same as in the FrameEncodeSettings if was not null there,\n  // Some own implementation if was null there.\n  std::unique\u003cconst BufferProviderInterface\u003e output_buffer;\n}\n\n\nclass InternalBufferProvider : public BufferProviderInterface  {\n public:\n  rtc::ArrayView\u003cuint8_t\u003e GiveMeTheBufferToWriteTo(size_t size) override {\n    buffer_.emplace(size);\n    return *buffer_;\n  }\n  \n  rtc::ArrayView\u003cconst uint8_t\u003e GiveMeTheTheSameBufferAsAResult() const override {\n    return *buffer_;\n  }\n \n private:\n  absl::optional\u003cabsl::FixedArray\u003cuint8_t\u003e\u003e buffer_;\n}\n```",
      "revId": "529319a2ccf686620366077689979353b9698425",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6fae4404_ba405a89",
        "filename": "api/video_codecs/video_encoder_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 5019
      },
      "writtenOn": "2024-05-17T10:44:51Z",
      "side": 1,
      "message": "Or, to capture some promises with machine readable annotations:\n```\nstruct FrameEncodeSettings {\n  ...\n  absl::Nullable\u003cstd::unique_ptr\u003cBufferProviderInterface\u003e\u003e output_buffer_provider;\n  ...\n};\n\nstruct FrameEncodedData {\n  // Guaranteed to be the same as in the FrameEncodeSettings if was not null there,\n  // Some own implementation if was null there.\n  absl::Nonnull\u003cstd::unique\u003cconst BufferProviderInterface\u003e\u003e output_buffer;\n}\n```",
      "parentUuid": "9aa6b6a7_2606a871",
      "revId": "529319a2ccf686620366077689979353b9698425",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e8a6894a_7a0e9e16",
        "filename": "api/video_codecs/video_encoder_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 5524
      },
      "writtenOn": "2024-05-17T12:00:57Z",
      "side": 1,
      "message": "I\u0027m not sure I understand the benefits of doing it that way?",
      "parentUuid": "6fae4404_ba405a89",
      "revId": "529319a2ccf686620366077689979353b9698425",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d38bd4dd_a11071b0",
        "filename": "api/video_codecs/video_encoder_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 5019
      },
      "writtenOn": "2024-05-17T12:10:25Z",
      "side": 1,
      "message": "this makes it explicit buffer ownership transfer:\n\nCaller of the api may own the buffer and pass it to the encoder with ownership in `FrameEncodeSettings`.\nEncoder fills the buffer, and pass it back the caller via FrameEncodedData\n\nabsl::AnyInvocable solution makes it harder to manage ownership of the buffer, in particular it is harder to capture when buffer is free for reuse or to deallocate\nWith proposed solution destructor of the interface signals when buffer is free to reuse or to deallocate as no longer needed.\n\nWhen Caller doesn\u0027t want to manage ownership, it doesn\u0027t provide buffer, then Encoder creates own buffer using InternalBufferProvider implementation (similar to like it was done previosly with `rtc::scoped_refptr\u003cEncodedImageBufferInterface\u003e bitstream_data` solution). But that latter behavior is less important, you might as well make it a requirement to always provide `output_buffer_provider`:\n```\nstruct FrameEncodeSettings {\n  ...\n  absl::Nonnull\u003cstd::unique_ptr\u003cBufferProviderInterface\u003e\u003e output_buffer_provider;\n  ...\n};\n```",
      "parentUuid": "e8a6894a_7a0e9e16",
      "revId": "529319a2ccf686620366077689979353b9698425",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4e3ea416_0fe137da",
        "filename": "api/video_codecs/video_encoder_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 5524
      },
      "writtenOn": "2024-05-17T12:29:48Z",
      "side": 1,
      "message": "Ack, thanks for the explanation!\n\nYeah that does make some sense. We\u0027re now implicitly requiring the callback to actually take ownership of that memory. If caller and callback are not directly the same component that could be fragile.\n\nI\u0027d prefer the nonnullable way in that case. It does require the caller to set up more things in order to do the call, but in practice that would really only be a bother for tests, and I\u0027m fine with a little extra overhead there.\n\nI\u0027ll leave it up to philip how to actually move forward though.",
      "parentUuid": "d38bd4dd_a11071b0",
      "revId": "529319a2ccf686620366077689979353b9698425",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f78d12c0_1e21b43a",
        "filename": "api/video_codecs/video_encoder_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 5019
      },
      "writtenOn": "2024-05-17T12:39:22Z",
      "side": 1,
      "message": "I like to structure code so that when you want a default behavior, you need to write nothing.\nThat makes it easier to change the default later, or remove/rename the member/function.\n\ni.e.,\neither\n```\nstruct FrameEncodeSettings {\n  absl::Nullable\u003cstd::unique_ptr\u003cBufferProviderInterface\u003e\u003e output_buffer_provider;\n};\n```\nor\n```\nstruct FrameEncodeSettings {\n  absl::Nonnull\u003cstd::unique_ptr\u003cBufferProviderInterface\u003e\u003e output_buffer_provider \u003d CreateDefaultBufferProvider();\n};\n```",
      "parentUuid": "4e3ea416_0fe137da",
      "revId": "529319a2ccf686620366077689979353b9698425",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1f815a39_44c5da2a",
        "filename": "api/video_codecs/video_encoder_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 5527
      },
      "writtenOn": "2024-05-17T12:44:25Z",
      "side": 1,
      "message": "I think this is the best of both worlds:\n\n    class VideoEncoderInterface {\n      ...\n      struct OutputFunctions {\n        virtual rtc::ArrayView\u003cuint8_t\u003e GetOutputBuffer() \u003d 0\n        virtual void EncodeDone(const EncodeResult\u0026 encode_result) \u003d 0;\n      };\n      ...\n      struct FrameEncodeSettings {\n        ...\n        OutputFunctions output_functions;\n      };\n    };\n\nNow it\u0027s trivial to add a `std::vector\u003cuint8_t\u003e` member to the `OutputFunctionsImpl`, and it is accessible to `EncodDone` when it is called.",
      "parentUuid": "4e3ea416_0fe137da",
      "revId": "529319a2ccf686620366077689979353b9698425",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e36a973b_ce53c1f5",
        "filename": "api/video_codecs/video_encoder_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 5019
      },
      "writtenOn": "2024-05-17T12:52:13Z",
      "side": 1,
      "message": "+1\n\nMerging multiple functions into same interface looks like the right approach (AnyInvocable/std::function is a sort of a shortcut for an interface with a single function, but if you have several - proper interface looks cleaner).",
      "parentUuid": "1f815a39_44c5da2a",
      "revId": "529319a2ccf686620366077689979353b9698425",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e12be9e3_0fcc854a",
        "filename": "api/video_codecs/video_encoder_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 5524
      },
      "writtenOn": "2024-05-17T13:02:55Z",
      "side": 1,
      "message": "+1 I like that too",
      "parentUuid": "e36a973b_ce53c1f5",
      "revId": "529319a2ccf686620366077689979353b9698425",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e9acd1be_5076f313",
        "filename": "api/video_codecs/video_encoder_interface.h",
        "patchSetId": 1
      },
      "lineNbr": 77,
      "author": {
        "id": 5527
      },
      "writtenOn": "2024-05-20T11:48:24Z",
      "side": 1,
      "message": "Update now, PTAL.",
      "parentUuid": "e12be9e3_0fcc854a",
      "revId": "529319a2ccf686620366077689979353b9698425",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}