{
  "comments": [
    {
      "key": {
        "uuid": "07f6d131_17bd17c5",
        "filename": "modules/video_coding/packet_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 127,
      "author": {
        "id": 5527
      },
      "writtenOn": "2019-12-10T16:14:48Z",
      "side": 1,
      "message": "This is a good idea, I think we can improve it a bit by checking it this way:\n\n  AheadOrAt(packet-\u003etimestamp, last_received_keyframe_rtp_timestamp_);\n\nThis way we will ignore old re-sent packets belonging to a keyframe.",
      "range": {
        "startLine": 127,
        "startChar": 6,
        "endLine": 127,
        "endChar": 64
      },
      "revId": "03b81c8ae2cea7e6035e17f10c66d80863318e81",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa457ffc_2e6ce920",
        "filename": "modules/video_coding/packet_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 127,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-12-10T16:32:56Z",
      "side": 1,
      "message": "sorry, I do not understand this idea.\nwhat scenario do you want to prevent?\nKF packet1 -\u003e return now\nKF packet3 -\u003e return now\nDF packet1 -\u003e return packet3 arrival time\nKF packet2 -\u003e ??? (do we want to return now or KF packet3 arrival time here? I think now is better, even if packet arrived delayed over rtx channel. otherwise there is a risk of sending FIR instead of NACKing few packets)\nKF packet3 -\u003e resent, discarded earlier in this function (lines 104-105 or lines 92-96)",
      "parentUuid": "07f6d131_17bd17c5",
      "range": {
        "startLine": 127,
        "startChar": 6,
        "endLine": 127,
        "endChar": 64
      },
      "revId": "03b81c8ae2cea7e6035e17f10c66d80863318e81",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c822face_bb182ad5",
        "filename": "modules/video_coding/packet_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 127,
      "author": {
        "id": 5527
      },
      "writtenOn": "2019-12-10T16:48:01Z",
      "side": 1,
      "message": "I was thinking something like:\n\n  packet 1: rtp_ts\u003d0 seq_num\u003d0 (KF)\n  packet 2: rtp_ts\u003d0 seq_num\u003d1 (KF)\n  packet 3: rtp_ts\u003d1 seq_num\u003d3 (KF)\n  packet 4: rtp_ts\u003d0 seq_num\u003d0 (KF) \u003c-- old\n\nWhen we receive the old packet we will |last_received_keyframe_packet_ms_ \u003d now_ms|, but it might have been re-sent because of probing or some other reason. If we use the check I propose we won\u0027t update |last_received_keyframe_packet_ms_|.",
      "parentUuid": "aa457ffc_2e6ce920",
      "range": {
        "startLine": 127,
        "startChar": 6,
        "endLine": 127,
        "endChar": 64
      },
      "revId": "03b81c8ae2cea7e6035e17f10c66d80863318e81",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "232706c0_53d4ee77",
        "filename": "modules/video_coding/packet_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 127,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-12-10T17:01:25Z",
      "side": 1,
      "message": "Packets with the same rtp sequence numbers are discarded earlier in this function.\n\n(packets that already formed a frame discarded lines 92-96, re-transmitted packets that haven\u0027t yet made a frame discarded lines 104-105)",
      "parentUuid": "c822face_bb182ad5",
      "range": {
        "startLine": 127,
        "startChar": 6,
        "endLine": 127,
        "endChar": 64
      },
      "revId": "03b81c8ae2cea7e6035e17f10c66d80863318e81",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb9f71a7_61fdd266",
        "filename": "modules/video_coding/packet_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 127,
      "author": {
        "id": 5527
      },
      "writtenOn": "2019-12-10T17:54:48Z",
      "side": 1,
      "message": "I haven\u0027t looked at this in detail, but I think there is a way for this to happen if we don\u0027t decode frames. Something like:\n\n1) Decode a few frames\n2) Receive a keyframe\n2) Fail to decode it (meaning we don\u0027t call PacketBuffer::ClearTo).\n3) Receive packets of a new keyframe and the keyframe from 2) (probing or whatever reason).\n4) Packets from keyframe 2 will now not be old (line 92) and not be used (line 104), so they will update the |last_received_keyframe_packet_ms_|.\n\nI think this is very unlikely though...",
      "parentUuid": "232706c0_53d4ee77",
      "range": {
        "startLine": 127,
        "startChar": 6,
        "endLine": 127,
        "endChar": 64
      },
      "revId": "03b81c8ae2cea7e6035e17f10c66d80863318e81",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e9c482ed_ae8581cd",
        "filename": "modules/video_coding/packet_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 127,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-12-13T10:28:47Z",
      "side": 1,
      "message": "summary of the offline discussion:\nThat scenarios is possible, but very rare to worry about.\nsuggested solution \u0027AheadOrAt\u0027 would trigger on every [delta] frame after the keyframe, while current solution triggers updating last_key_frame only on every packet of the keyframe\n(it would also trigger on all packets of the same picture in case of spatial layering, but that\u0027s ok.)",
      "parentUuid": "eb9f71a7_61fdd266",
      "range": {
        "startLine": 127,
        "startChar": 6,
        "endLine": 127,
        "endChar": 64
      },
      "revId": "03b81c8ae2cea7e6035e17f10c66d80863318e81",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}