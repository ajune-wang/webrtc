{
  "comments": [
    {
      "key": {
        "uuid": "662b6c79_a56c2b63",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-12-10T14:47:18Z",
      "side": 1,
      "message": "This can be misunderstood to mean free threaded. I would say that the design is closer to a single threaded environment. In practice, it would be running in a sequenced task environment whereby all calls made to the interface, are made from the same sequenced (guaranteed not to conflict with other calls) runtime context.",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd6bc310_5da4cedc",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 3,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-10T15:42:04Z",
      "side": 1,
      "message": "Interesting - do you mean that if I (the client) have two threads that call methods on a single PeerConnection (or other) object, things are likely to go pear-shaped? If so, that should clearly be documented!\n\nAlternative text: \"The design of the API assumes that all methods on an object, including creation and deletion, are carried out from a single thread\". I thought this was not so....",
      "parentUuid": "662b6c79_a56c2b63",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "87e2ec92_bea31344",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 5,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-12-10T14:47:18Z",
      "side": 1,
      "message": "Same here, the notion of \u0027thread\u0027 is being phased out and instead we\u0027re using sequenced task queues (or runners in chromium).  In particular, the API functions are not designed to be called from any thread or task queue.",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "184b5c28_9b742299",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 5,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-10T15:42:04Z",
      "side": 1,
      "message": "The notion of \"thread\" is useful shorthand for \"concurrency-preventing mechanism\" - if we don\u0027t have another single word to use, I suggest we add a sentence \"The term \"thread\" is used here for any concurrency-preventing mechanism, including threads, Chromium task runners and sequenced task queues.\"",
      "parentUuid": "87e2ec92_bea31344",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e781b8c5_1a5673f2",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 6,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-12-10T14:47:18Z",
      "side": 1,
      "message": "I think this is an implementation detail. The implementation could choose to execute work asynchronously on the same thread as the call is made on.",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce90ff0c_4f08bc1a",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 6,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-10T15:42:04Z",
      "side": 1,
      "message": "and I think it sometimes should (thread-hopping is higher overhead than locking). Perhaps say \"can do\" instead of \"will do\"?",
      "parentUuid": "e781b8c5_1a5673f2",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f869050_ad411e85",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 8,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-12-10T14:47:18Z",
      "side": 1,
      "message": "I would even say that \"In general, the functions are designed to be used ...\"",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84312693_a2348a91",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 8,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-10T15:42:04Z",
      "side": 1,
      "message": "It\u0027s the ones that aren\u0027t (such as AddTrack) that give us the most headaches...",
      "parentUuid": "3f869050_ad411e85",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9591b13e_3a3d02b7",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-12-10T14:47:18Z",
      "side": 1,
      "message": "I would also clarify that the callback will be made in the same execution context as the initiating action was made.\n\nE.g. for javascript, this means the same worker, for C++ same sequential task queue.\n\nThis is an important part of the design since it allows for many optimizations that both the interface implementation and its client can assume a certain concurrency model.",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fea11026_16a7ee93",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 10,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-10T15:42:04Z",
      "side": 1,
      "message": "If that\u0027s a guarantee, we should definitely note it.\nDo we have that guarantee for event callbacks, or only for result callbacks? There\u0027s code up in Chrome-land that seems to assume that we can\u0027t trust webrtc about which thread it\u0027s called back on.",
      "parentUuid": "9591b13e_3a3d02b7",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0f37ce4_1b445dc4",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-12-10T14:47:18Z",
      "side": 1,
      "message": "\"even functions\"",
      "range": {
        "startLine": 12,
        "startChar": 16,
        "endLine": 12,
        "endChar": 25
      },
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b36bbf8_a8376683",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-13T15:04:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c0f37ce4_1b445dc4",
      "range": {
        "startLine": 12,
        "startChar": 16,
        "endLine": 12,
        "endChar": 25
      },
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cafdba8b_9cbb7dc8",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 18,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-12-10T14:47:18Z",
      "side": 1,
      "message": "I don\u0027t think this is a part of the interface design. If callbacks happen in a predetermined way, in the same execution context as the call was made, the caller doesn\u0027t have to worry about these details.",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "31b6c424_0fc9b827",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 18,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-10T15:42:04Z",
      "side": 1,
      "message": "Oh yes, the caller will have to worry. \"predetermined\" doesn\u0027t mean \"easy to predict\".\n(I had to abandon multi-character dispatching of DTMF in webrtc because I couldn\u0027t give any guarantees on how many characters had been sent while the callbacks were being scheduled.)",
      "parentUuid": "cafdba8b_9cbb7dc8",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f97701b4_32eb04e2",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 5508
      },
      "writtenOn": "2018-12-10T14:47:18Z",
      "side": 1,
      "message": "I think we should have the discussion around the proxy implementation separately. I can provide some background as the co-author of it.",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b80bb064_e3d5e9e8",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-10T15:42:04Z",
      "side": 1,
      "message": "Only reason for including this text here is to document the current implementation. Whether we want to change it later is a separable discussion.",
      "parentUuid": "f97701b4_32eb04e2",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dfc193b1_99d7f87a",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-12-10T17:15:54Z",
      "side": 1,
      "message": "The \"current implementation\" refers to two separate beasts. The actual peer connection implementation, which is NOT callable from \"any thread\" - and I think it would be a mistake to document this as a requirement of any implementation - and the proxy object, which in my opinion should not be viewed as an implementation of the interface but rather a helper class that allows using the PC from threads other than the one it was *designed for*. The fact that peerconnection.cc synchronously does things on the signaling thread is not an implementation detail, its by-design - just like the spec is clear about when to \"run the following steps\" (i.e. do this now) or when to \"run in parallel\" (i.e. do something in the background, which only ever becomes visible by a subsequent \"queue a task that runs the following steps\"). The fact that the signaling thread is NOT the same thread as the JavaScript thread is an observable bug; \"to be used in a multithreaded environment\" should NOT be viewed as a feature of peer connections properly implemented.\n\nI think the way forward is:\n- Document the interface to describe what an actual implementation should do. That is, all method calls and all callbacks should occur on the same task queue.\n- Document the threading hazards in the PROXY, explaining how these functionalities are an add-on, not an implementation of the interface per-se.\n- With regards to PeerConnection-getters (FooInterfaces being exposed such as RtpTransceiverInterface by GetTransceivers(), or possibly RtpReceiverInterface by ontrack-callbacks) returning interfaces that are implemented as FooProxies: Again, this is a workaround to allow PROXY to work, not a requirement by the interface. We could have isolated this PROXY logic to the PeerConnectionProxy but that would have required more work, documenting this as a bug is better than making this implementation detail part of the interface.\n\nWe should strive towards:\n- Making PeerConnection as similar to the spec as possible, meaning what refers to as the \"main thread\" is the same thing as the spec is referring to - the JavaScript thread. Once we\u0027ve gotten rid of the additional threading layers we can...\n- Remove the PROXY object, meaning we no longer need FooInterfaces, we can just have Foos (unless we want to implement MOCK/FAKE stuff).",
      "parentUuid": "b80bb064_e3d5e9e8",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43df2ad2_016018a9",
        "filename": "api/DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 5634
      },
      "writtenOn": "2018-12-13T15:04:38Z",
      "side": 1,
      "message": "The current implementation of the WebRTC C++ library consists of a bunch of classes, some of which have the 3-element inheritance hierarchy where \"proxy\" and \"implementation\" are subclasses\nof the interface class. I want to document the present state, which is a good basis for discussing what the future state should be, but mixing up the discussion of what the present state is with what the future state should be will get us neither documentation of the present nor a direction for the future.",
      "parentUuid": "dfc193b1_99d7f87a",
      "revId": "d8f25c61a3023e54507101917acb8103bb5fecfe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}