{
  "comments": [
    {
      "key": {
        "uuid": "30f36e75_29fc24ea",
        "filename": "api/transport/media/audio_transport.h",
        "patchSetId": 2
      },
      "lineNbr": 130,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-02-11T08:22:22Z",
      "side": 1,
      "message": "It seems a bit questionable to me use use RTCError here; it seems intended for errors to be propagated to the javascript api. I would suggest either no return value, to make the method fire-and-forget, or a bool (true for success), if there\u0027s any use for reporting early failure, e.g., from packetization. \n\nI expect the typical implementation will at most do packetization before returning, and post the interesting part of the work to some network thread.",
      "range": {
        "startLine": 130,
        "startChar": 10,
        "endLine": 130,
        "endChar": 18
      },
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "747017dd_a00fdfa2",
        "filename": "api/transport/media/audio_transport.h",
        "patchSetId": 2
      },
      "lineNbr": 130,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-02-11T14:33:14Z",
      "side": 1,
      "message": "I think in principle I disagree with having methods that silently drop errors (fire and forget), except for the top-level ones (but even those should log warnings).\n\nIs there a better error type? Worst case we can use \u0027boolean\u0027.",
      "parentUuid": "30f36e75_29fc24ea",
      "range": {
        "startLine": 130,
        "startChar": 10,
        "endLine": 130,
        "endChar": 18
      },
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56876a45_04ae60f8",
        "filename": "api/transport/media/audio_transport.h",
        "patchSetId": 2
      },
      "lineNbr": 130,
      "author": {
        "id": 5599
      },
      "writtenOn": "2019-02-11T18:11:21Z",
      "side": 1,
      "message": "We chose RTCError because it seemed like the cleanest abstraction for an error code (it\u0027s got a nice wrapper class, it lets us specify an error message, and you can have an RTCErrorOr if there\u0027s either a return value or error).\n\nIf the caller is never going to be able to do anything with an error (other than log and continue), we might as well do that in the implementation.  The only issue is that it becomes harder to test the implementation.  If there are incomplete frames we can\u0027t packetize, parameters we need to validate, or other synchronous failure modes, we can no longer test them directly.\n\nWe could return an int/bool, but we lose any error message associated with it.\n\nAnother option would be to define an error callback.  This could be a function pointer that gives full error details for a particular frame, and defaults to nullptr if production code doesn\u0027t need to know about errors.  Something like this:\n\nvoid SendAudioFrame(MediaTransportEncodedAudioFrame frame, void(*on_error)(int, string) \u003d nullptr);\n\nThat would even let us capture and test certain error cases in the async part of media transport.  However, it might be overkill.\n\nDo you think the callee ever needs to know about errors?  Does it ever do anything with them?",
      "parentUuid": "747017dd_a00fdfa2",
      "range": {
        "startLine": 130,
        "startChar": 10,
        "endLine": 130,
        "endChar": 18
      },
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}