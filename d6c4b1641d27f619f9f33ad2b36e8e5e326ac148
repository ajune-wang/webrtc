{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "745734ab_c00f3d40",
        "filename": "pc/peer_connection_end_to_end_unittest.cc",
        "patchSetId": 38
      },
      "lineNbr": 698,
      "author": {
        "id": 5634
      },
      "writtenOn": "2023-03-28T22:49:20Z",
      "side": 0,
      "message": "Hm. This test was added in https://webrtc-review.googlesource.com/c/src/+/79061 - I suspect that there was a real gotcha behind that test being needed.\n\nIf it is now racy, it may be a sign that the conditions that caused the test to be written might have resurfaced.\n\nWhat it is trying to guard against is the case where two channels get the same ID when there\u0027s still a time when both referred to valid (non-closed) channels - in this case, where the first channel is in \"closing\" state when the second channel gets created. Otherwise, an user who\u0027s not using labels might see:\n\nopened(1) (the first channel)\nopened(1) (but this is actually the second channel opening)\nclosed(1) (the first channel is now closed, but the client is confused)\n\nYou might have to block the remote end\u0027s reply to the \"close\" in order to provoke the situation in a stable fashion when you\u0027re multithreaded - but deleting the test seems wrong.",
      "revId": "d6c4b1641d27f619f9f33ad2b36e8e5e326ac148",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "382d29dc_4a6a2e08",
        "filename": "pc/peer_connection_end_to_end_unittest.cc",
        "patchSetId": 38
      },
      "lineNbr": 698,
      "author": {
        "id": 5508
      },
      "writtenOn": "2023-03-29T11:15:03Z",
      "side": 0,
      "message": "I\u0027ll take a stab at restoring it but with awareness of more than one thread.\nSome comments on assumptions below which imho are a bit too implementation-detail specific for an integration test. Maybe there\u0027s a way to do this more generally.",
      "parentUuid": "745734ab_c00f3d40",
      "revId": "d6c4b1641d27f619f9f33ad2b36e8e5e326ac148",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5a48d22_bb8e26f5",
        "filename": "pc/peer_connection_end_to_end_unittest.cc",
        "patchSetId": 38
      },
      "lineNbr": 713,
      "author": {
        "id": 5508
      },
      "writtenOn": "2023-03-29T11:15:03Z",
      "side": 0,
      "message": "After this call (and all the way through the next several lines), there\u0027s an implicit assumption that the state never gets to kClosed.",
      "revId": "d6c4b1641d27f619f9f33ad2b36e8e5e326ac148",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59aa915e_45aa6426",
        "filename": "pc/peer_connection_end_to_end_unittest.cc",
        "patchSetId": 38
      },
      "lineNbr": 716,
      "author": {
        "id": 5508
      },
      "writtenOn": "2023-03-29T11:15:03Z",
      "side": 0,
      "message": "I think that this comment is a bit telling that we try to do one thing fast enough so that we beat another pending operation.",
      "revId": "d6c4b1641d27f619f9f33ad2b36e8e5e326ac148",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "505271cf_282511e0",
        "filename": "pc/peer_connection_end_to_end_unittest.cc",
        "patchSetId": 38
      },
      "lineNbr": 720,
      "author": {
        "id": 5508
      },
      "writtenOn": "2023-03-29T11:15:03Z",
      "side": 0,
      "message": "This assumes an implementation detail that everything is happening on the same thread (this current test thread).\n\nWhen running the test, what \"fails\" is that `caller_dc` gets to `kClosed`. What the test is meant to test, isn\u0027t what breaks, it\u0027s that the signaling thread assumptions behind it, don\u0027t hold.\n\nSo it seems like what the test needs to do is somehow, explicitly, prevent the state transition from closing to closed and create a new data channel inside that gap and test that it doesn\u0027t get the same sid.",
      "revId": "d6c4b1641d27f619f9f33ad2b36e8e5e326ac148",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}