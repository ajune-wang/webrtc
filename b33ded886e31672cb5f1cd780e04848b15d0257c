{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "16e42509_04c3af85",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 20429
      },
      "writtenOn": "2024-04-10T21:25:58Z",
      "side": 1,
      "message": "Ilya, Sergey: I implemented your suggestion. But I am not quite happy with the result. Please see my comments below.",
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6274c557_4efd6a3b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5825
      },
      "writtenOn": "2024-04-11T11:59:40Z",
      "side": 1,
      "message": "I think that knowing chrome subsampling alone is not enough. To crop frames of formats https://www.kernel.org/doc/html/v4.18/media/uapi/v4l/pixfmt-y41p.html , which we do not support yet but it would be better to account for from the very beginning, and avoid displacement or/and re-packing we need something like this https://webrtc-review.googlesource.com/c/src/+/346661",
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8be8609_fd799ea9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5117
      },
      "writtenOn": "2024-04-11T12:59:08Z",
      "side": 1,
      "message": "That will not work, if the incoming buffer is kI410. The buffer has 1x1 samples. But the CropAndScale() would first convert to I420 (because there\u0027s no override for I410BufferInterface), which has 2x2 samples, so it will round the offset implicitly, which is the issue this CL is addressing. \n\nThen, it will also not work for all the native buffers and there the amount of possibilities is even bigger.",
      "parentUuid": "6274c557_4efd6a3b",
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2046975f_e2ddf01f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5825
      },
      "writtenOn": "2024-04-11T14:02:22Z",
      "side": 1,
      "message": "\u003e\u003e he buffer has 1x1 samples. But the CropAndScale() would first convert to I420 (because there\u0027s no override for I410BufferInterface),\n\nWe need to implement propper CropAndScale() for all 10+ bits formats. Or there is something else?\n\n\n\u003e\u003e Then, it will also not work for all the native buffers\n\nCurrent native buffers are excluded from cropping: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/video_stream_encoder.cc;l\u003d1945;drc\u003d19f1297f7fca14311e614f204a85582c3bd12b61\n\nhttps://webrtc-review.googlesource.com/c/src/+/154424\n\nNot sure what this results to on practice.",
      "parentUuid": "c8be8609_fd799ea9",
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed94b76d_5a062645",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5117
      },
      "writtenOn": "2024-04-11T14:17:10Z",
      "side": 1,
      "message": "\u003e We need to implement propper CropAndScale() for all 10+ bits formats. Or there is something else?\n\nYes. It\u0027s not complex, but will require A LOT of grunt work. We currently have 3 buffer implementation classes, which actually store data. We will need to add ~7 more to store the scaled data. And wire up ~7 more libyuv functions in webrtc.\n\n\u003e Current native buffers are excluded from cropping:\n\nThat\u0027s only for external encoders. The code you\u0027ve linked is: \n`VideoFrameBuffer::Type::kNative || !info.supports_native_handle`\n\nNote the second part. For internal software encoders all the buffers will be cropped. \nIn practice, at this point in code every single buffer will be kNative in chrome.\n\nHow these native buffers actually do CropAndScale is a very big question. In chrome it soft-applies crop and scale and postpones it until the actual data is being accessed. What happens in other use cases of webrtc - we can\u0027t even know.\n\nI\u0027m getting more and more convinced, that we should just always round offset to 2 and not try to be very clever here.",
      "parentUuid": "2046975f_e2ddf01f",
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4778f113_201e6bf4",
        "filename": "api/video/video_frame_buffer.cc",
        "patchSetId": 7
      },
      "lineNbr": 21,
      "author": {
        "id": 5117
      },
      "writtenOn": "2024-04-11T09:37:46Z",
      "side": 1,
      "message": "This is a bummer. It\u0027s in theory quite OK to output I420 when cropping is happening from I444 with an odd offset, if the conversion happened at the end, not at the beginning, like it happens now. \n\nOn one hand, it\u0027s safe. All the important formats have CropAndScale overriden.\nAnd in the end I420::CropAndScale will round offsets to nearest even number for you:\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/api/video/i420_buffer.cc;l\u003d199;drc\u003d3f44955ac74c25c15d3fece126fb4d29f9e82d9b\n\nBut that will result in a wrong UpdateRect, though... So the main issue isn\u0027t addressed by this change. \n\nSo we need a completely different approach. Sorry for backing up, but the change proved out to be far tricker than I anticipated.\n\nWe can compensate for any implicit roundings by just adding 1 to the UpdateRect sizes.\n\nOr maybe we are grossly overthinking things here. For the purpose of a small 1-4 pixel crop we can just always make the offset even! Even for I444 or RGB. It doesn\u0027t matter what side of the picture we are shaving a few pixels off.",
      "range": {
        "startLine": 21,
        "startChar": 3,
        "endLine": 21,
        "endChar": 64
      },
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "94bdffa0_e281c8ff",
        "filename": "api/video/video_frame_buffer.cc",
        "patchSetId": 7
      },
      "lineNbr": 26,
      "author": {
        "id": 5117
      },
      "writtenOn": "2024-04-11T09:37:46Z",
      "side": 1,
      "message": "The default implementation should return \"No subsampling\" or sample size \u003d 1x1.\n\nBut that\u0027s won\u0027t fix the issue with implicit offset rounding and UpdateRect being out of sync, you are right. So this makes this all approach very brittle and hacky.",
      "range": {
        "startLine": 26,
        "startChar": 9,
        "endLine": 26,
        "endChar": 10
      },
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e1f9077_13d844ff",
        "filename": "api/video/video_frame_buffer.cc",
        "patchSetId": 7
      },
      "lineNbr": 150,
      "author": {
        "id": 5117
      },
      "writtenOn": "2024-04-11T09:37:46Z",
      "side": 1,
      "message": "If there\u0027s no subsampling, it should return 1.",
      "range": {
        "startLine": 150,
        "startChar": 9,
        "endLine": 150,
        "endChar": 11
      },
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "62df703d_7373ee23",
        "filename": "api/video/video_frame_buffer.h",
        "patchSetId": 7
      },
      "lineNbr": 97,
      "author": {
        "id": 20429
      },
      "writtenOn": "2024-04-10T21:25:58Z",
      "side": 1,
      "message": "I am not happy with the definition of these two methods. In order to fix this bug, their definition must be tied to the `VideoFrameBuffer` subclass returned by `CropAndScale()`, rather than the current `VideoFrameBuffer` subclass (i.e., `this`).",
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8bbeb70b_e0525b00",
        "filename": "api/video/video_frame_buffer.h",
        "patchSetId": 7
      },
      "lineNbr": 270,
      "author": {
        "id": 20429
      },
      "writtenOn": "2024-04-10T21:25:58Z",
      "side": 1,
      "message": "Although the height of the chroma planes in I210 is not subsampled, we cannot override `HeightSubsampling()` to return 0 because this class does not override `CropAndScale()` and the default implementation of `CropAndScale()` converts to I420.",
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ef1fa52b_1a3d12d7",
        "filename": "api/video/video_frame_buffer.h",
        "patchSetId": 7
      },
      "lineNbr": 283,
      "author": {
        "id": 20429
      },
      "writtenOn": "2024-04-10T21:25:58Z",
      "side": 1,
      "message": "Although the width and height of the chroma planes in I410 are not subsampled, we cannot override `WidthSubsampling()` and `HeightSubsampling()` to return 0 because this class does not override `CropAndScale()` and the default implementation of `CropAndScale()` converts to I420.",
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9434d4e8_b7338d3f",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 7
      },
      "lineNbr": 1963,
      "author": {
        "id": 5117
      },
      "writtenOn": "2024-04-11T09:37:46Z",
      "side": 1,
      "message": "This is confusing. Returning alignment 1 or 2 is better. Here you use essentially bool values in bit arithmetic.\n\nLet\u0027s copy the chromium way: https://source.chromium.org/chromium/chromium/src/+/main:media/base/video_frame.cc;l\u003d119;drc\u003d3f44955ac74c25c15d3fece126fb4d29f9e82d9b\n\nName the functions SampleWidth and SampleHight probably.\n\nThen the code is more clear:\n```\noffset_x -\u003d offest_x % video_frame.video_frame_buffer()-\u003eSampleWidth();\n```",
      "range": {
        "startLine": 1963,
        "startChar": 17,
        "endLine": 1963,
        "endChar": 70
      },
      "revId": "b33ded886e31672cb5f1cd780e04848b15d0257c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}