{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "39cab5c5_d5a9cf5e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9405
      },
      "writtenOn": "2021-11-05T01:32:53Z",
      "side": 1,
      "message": "titovartem, this is a minor cleanup about the exit-time destructor run.\nPlease take a look. Thank you.",
      "revId": "b09f2dc9fefd920613c886c65ace28f4bb271153",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "745f8607_d233dbbc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5087
      },
      "writtenOn": "2021-11-05T07:42:38Z",
      "side": 1,
      "message": "Adding Danil as well.",
      "revId": "b09f2dc9fefd920613c886c65ace28f4bb271153",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "368e5d22_312d6ba9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 9405
      },
      "writtenOn": "2021-11-05T08:14:20Z",
      "side": 1,
      "message": "Ah, thanks for suggesting another way.\nIf that\u0027s the preferred method, I\u0027d like to apply it instead of this annotation.",
      "revId": "b09f2dc9fefd920613c886c65ace28f4bb271153",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ff8bf26_ac3a1cbe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 6337
      },
      "writtenOn": "2021-11-12T09:59:19Z",
      "side": 1,
      "message": "Looks good to me from C++ point of view. Danil, can you please take a look from functional point of view. I\u0027m not fully familiar with this part of the code.",
      "revId": "b09f2dc9fefd920613c886c65ace28f4bb271153",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "880a182b_43120127",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-11-12T10:59:47Z",
      "side": 1,
      "message": "Would prefer solution within c++ language over solution that changes behaviour in a  compile-specific way",
      "revId": "b09f2dc9fefd920613c886c65ace28f4bb271153",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ccdd2e79_3d346c0f",
        "filename": "rtc_base/logging.cc",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-11-12T10:59:47Z",
      "side": 1,
      "message": "(fyi)\nusing static function member adds a bit of overhead on each use,\nwhich might be an issue for the variable that used a lot (every time there is a log) but it seems this overhead is negligibly small.\n\nhttps://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables\n“Note: usual implementations of this feature use variants of the double-checked locking pattern, which reduces runtime overhead for already-initialized local statics to a single non-atomic boolean comparison.”",
      "range": {
        "startLine": 78,
        "startChar": 2,
        "endLine": 78,
        "endChar": 8
      },
      "revId": "b09f2dc9fefd920613c886c65ace28f4bb271153",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3f70bdd5_33958798",
        "filename": "rtc_base/logging.cc",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 9405
      },
      "writtenOn": "2021-11-12T15:08:37Z",
      "side": 1,
      "message": "I\u0027ve read libcxxabi\u0027s implementation of __cxa_guard_acquire and it seems to lock the global mutex on all calls, especially on non-linux systems.\nIt\u0027s not good because we are dealing with mutex objects.\n\nInstead, I implemented it using atomic pointers with initialization. At least it won\u0027t acquire a (global) mutex to access (own) mutex. Heavily inspired by [1].\n\n[1] https://source.chromium.org/chromium/chromium/src/+/2aa5286d5f8af257733b44f3fb9d6d35960759b5:third_party/angle/src/libGLESv2/global_state.cpp;l\u003d26",
      "parentUuid": "ccdd2e79_3d346c0f",
      "range": {
        "startLine": 78,
        "startChar": 2,
        "endLine": 78,
        "endChar": 8
      },
      "revId": "b09f2dc9fefd920613c886c65ace28f4bb271153",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d25f0c41_33bd6d15",
        "filename": "rtc_base/system/no_destroy.h",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 5087
      },
      "writtenOn": "2021-11-05T07:42:38Z",
      "side": 1,
      "message": "I am not sure about this part.\n\nWhen I added the -Wno-exit-time-destructors, I think I was trying to make it as local as possible regardless of \"build_with_chromium\".\n\nOn the other hand, this seems to be interesting for cases where it is not possible to heap allocate an object and then just leak it (since it needs to stay around for the whole duration of the program). As mentioned on https://google.github.io/styleguide/cppguide.html: \"If all else fails, you can create an object dynamically and never delete it by using a function-local static pointer or reference (e.g., static const auto\u0026 impl \u003d *new T(args...);).\".\n\nI think this comment should be made such that people don\u0027t use this too frequently but only when needed.",
      "range": {
        "startLine": 16,
        "startChar": 49,
        "endLine": 17,
        "endChar": 47
      },
      "revId": "b09f2dc9fefd920613c886c65ace28f4bb271153",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e5836ec_af8e408c",
        "filename": "rtc_base/system/no_destroy.h",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 9405
      },
      "writtenOn": "2021-11-05T08:14:20Z",
      "side": 1,
      "message": "Ah, thanks for suggesting another way.\nIf that\u0027s the preferred method, I\u0027d like to apply it instead of this annotation.",
      "parentUuid": "d25f0c41_33bd6d15",
      "range": {
        "startLine": 16,
        "startChar": 49,
        "endLine": 17,
        "endChar": 47
      },
      "revId": "b09f2dc9fefd920613c886c65ace28f4bb271153",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d37c389a_13685396",
        "filename": "rtc_base/system/no_destroy.h",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-11-12T10:59:47Z",
      "side": 1,
      "message": "I would prefer function-local static pointer over compiler-specific annotation.\nif you do not like this mutex use dynamic memory, I would recommend porting NoDestructor from chromium:\nhttps://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/no_destructor.h",
      "parentUuid": "9e5836ec_af8e408c",
      "range": {
        "startLine": 16,
        "startChar": 49,
        "endLine": 17,
        "endChar": 47
      },
      "revId": "b09f2dc9fefd920613c886c65ace28f4bb271153",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}