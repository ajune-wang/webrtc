{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "da2aebcc_5ee9afba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-10-04T15:50:00Z",
      "side": 1,
      "message": "I haven\u0027t tested this yet, but don\u0027t we need to return a frame in case there is a cursor position change and the FrameAndCursorComposer or how it\u0027s called combines a final frame from both?",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44765e94_3167958f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 18474
      },
      "writtenOn": "2022-10-04T18:06:57Z",
      "side": 1,
      "message": "I think this is right...\n(e.g. that we need the update if the cursor is updated)\n\nShare() also isn\u0027t that expensive: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/modules/desktop_capture/desktop_frame.cc;drc\u003db9539659f98e35ba63b84c1adf299a7a2590e07e;l\u003d129\n\nIn fact; we explicitly have logic to do the opposite of this in the Windows DirectX Capturer (which I\u0027d assume is also used by CRD); because I think the intention with CaptureFrame is that if you\u0027ve asked for a frame we will *always* give you a frame.\n\nWhat I think you *really* want is either:\n1) Damage Regions - Jan had discussed with me that I think this is on his list of things to work on? (Though right now we need to prioritize getting the tests out so we can ship the capturer)\nor\n2) An event-based API surface for DesktopCapturer - This is something I want to do and I\u0027m trying to figure out how to fit it into my roadmap.",
      "parentUuid": "da2aebcc_5ee9afba",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "336a4947_2be7734a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 19629
      },
      "writtenOn": "2022-10-04T18:40:29Z",
      "side": 1,
      "message": "Thanks for bringing it up. PS1 would have likely broken the composition with cursor. I have now added a desktop capture option which by default retains the original behavior.\n\n\u003e if you\u0027ve asked for a frame we will always give you a frame.\n\nIs there an efficient mechanism to determine if the newly captured frame is any different than the one that was captured last time?\n\n\u003e 1) Damage Regions - Jan had discussed with me that I think this is on his list of things to work on\n\u003e 2) An event-based API surface for DesktopCapturer \n\nBoth options sound great. First one can be somewhat imitated by the diff capturer wrapper but running the diff between frames adds few milliseconds latency (for 4k screens) that we can avoid here if we know for sure that the frame hasn\u0027t changed since the last captured frame.\n\nI will still be curious to learn what is the plan for figuring out damage regions (possibly without a pixel to pixel comparison) ðŸ˜Š",
      "parentUuid": "44765e94_3167958f",
      "revId": "7dabe2ba73629fac7f04987ee4aa388d78c3f4e9",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}