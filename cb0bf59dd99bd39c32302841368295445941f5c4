{
  "comments": [
    {
      "key": {
        "uuid": "322ac35e_9ae429ba",
        "filename": "pc/rtcstatscollector.cc",
        "patchSetId": 2
      },
      "lineNbr": 786,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-03-06T18:06:38Z",
      "side": 1,
      "message": "This does address the iterator being invalidated, but I believe this could change the order of things.\n\n1. callbacks_ \u003d { A, B }\n2. callbacks is swapped, and we begin executing callback A.\n  2.1 In a we do another getStats(), so callbacks_ \u003d { C }. Because there is a cached result,\n      we start doing DeliverCachedReport() recursively.\n  2.2 callbacks is swapped, so we execute callback C.\n3. Continuing from where we left of, we execute callback B.\n\ngetStats()-order: A, B, C\nCallback execution order: A, C, B\n\nHowever, if you always pop the first element then any recursive call to DeliverCachedReport() finishes the work that was started by the first DeliverCachedReport(), and when you re-enter after the recursion you abort because callbacks_ is empty.",
      "revId": "cb0bf59dd99bd39c32302841368295445941f5c4",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ae5c46e_db119559",
        "filename": "pc/rtcstatscollector.cc",
        "patchSetId": 2
      },
      "lineNbr": 786,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-03-07T10:40:45Z",
      "side": 1,
      "message": "Note that this comment was not resolved before merge.",
      "parentUuid": "322ac35e_9ae429ba",
      "revId": "cb0bf59dd99bd39c32302841368295445941f5c4",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2f9c24d1_020774a5",
        "filename": "pc/rtcstatscollector.cc",
        "patchSetId": 2
      },
      "lineNbr": 786,
      "author": {
        "id": 5053
      },
      "writtenOn": "2018-03-07T18:07:35Z",
      "side": 1,
      "message": "Sorry I missed this. I\u0027m not sure it\u0027s a problem, though. Nothing promises the order of \"A, B, C\", per se. And there are things that may be more important than order.\n\nFor one, with the \"pop first element\" approach, the B callback would end up invoked from within the seemingly unrelated A callback. The application may not be prepared for this; it may be in some indeterminate state.\n\nAlso, suppose this happens:\n\n1. Application calls GetStats.\n2. Callback invoked, but for whatever reason it takes longer than 50ms.\n3. Before the callback returns control, GetStats ends up called again. Starts asynchronously producing results.\n4. Callback returns, and the new callback is invoked immediately with the cached report.\n5. Stats collector finishes asynchronously producing results, calls DeliverCachedReport and hits DCHECK(!callbacks_.empty)\n\nMaybe the solution is to AsyncInvoke \"DeliverCachedReport\". I\u0027ll make a proof of concept CL to show what I\u0027m thinking",
      "parentUuid": "3ae5c46e_db119559",
      "revId": "cb0bf59dd99bd39c32302841368295445941f5c4",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ab6e0c9a_17c852bd",
        "filename": "pc/rtcstatscollector.cc",
        "patchSetId": 2
      },
      "lineNbr": 786,
      "author": {
        "id": 5053
      },
      "writtenOn": "2018-03-07T18:28:13Z",
      "side": 1,
      "message": "Here\u0027s a CL: https://webrtc-review.googlesource.com/#/c/src/+/60473",
      "parentUuid": "2f9c24d1_020774a5",
      "revId": "cb0bf59dd99bd39c32302841368295445941f5c4",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "25794878_1720f426",
        "filename": "pc/rtcstatscollector.cc",
        "patchSetId": 2
      },
      "lineNbr": 786,
      "author": {
        "id": 5142
      },
      "writtenOn": "2018-03-08T16:48:42Z",
      "side": 1,
      "message": "Hmmm, you\u0027re right, the unrelated callbacks firing nestedly would be even more unexpected and obscure, and a much more likely candidate for problems. Nothing in the spec guarantees the order, while unexpected if the order only changes in edge-cases it would seem very unlikely that this would matter to any real application.\n\nThis is more complicated than I anticipated. Hmm, \"3. ... Starts asynchronously producing results [again].\" would not happen because we only start collecting if (!num_pending_partial_reports_), otherwise we rely on the pending collection to return the result of the new callback, so we never hit the DCHECK at 5. (This is not racy because callbacks_ and num_pending_partial_reports_ are only touched on the signaling thread.)\n\nI like your solution with the concept CL. It solves the nested callback weirdness nicely.",
      "parentUuid": "ab6e0c9a_17c852bd",
      "revId": "cb0bf59dd99bd39c32302841368295445941f5c4",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0fe21a30_957e5a99",
        "filename": "pc/rtcstatscollector.cc",
        "patchSetId": 2
      },
      "lineNbr": 786,
      "author": {
        "id": 5053
      },
      "writtenOn": "2018-03-08T17:45:14Z",
      "side": 1,
      "message": "\u003e Nothing in the spec guarantees the order...\n\nNote that this only affects the native API, since chromium queues a task to fulfill the getStats promise and thus these reentrant calls are impossible.\n\n\u003e Hmm, \"3. ... Starts asynchronously producing results [again].\" would not happen because we only start collecting if (!num_pending_partial_reports_)\n\nBut num_pending_partial_reports_ is 0 here, that\u0027s why the stats callback is being invoked.\n\n\u003e I like your solution with the concept CL.\n\nAlright, let\u0027s go with it then; thanks for reviewing",
      "parentUuid": "25794878_1720f426",
      "revId": "cb0bf59dd99bd39c32302841368295445941f5c4",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}