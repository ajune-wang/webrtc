{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "975dd3c5_10a6606a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-11-21T15:39:32Z",
      "side": 1,
      "message": "I looked at the weak ptr option. I think it could be a good fit moving forward but right now it\u0027s not a neat fit with the queued tasks since I\u0027d have to add an additional check for the weak pointer inside the lambdas before implicitly accessing \u0027this\u0027. That\u0027s the same as what is done automatically by ToQueuedTask already for the flag, so similar utilities would need to be written for weak ptr. At the moment I\u0027m not sure what those would look like though since we\u0027d ideally need to somehow allow the caller to use the capture section of the lambdas and yet run the check before invoking the lambda.",
      "revId": "921ac1a5ccbf1d17f4425a55b44cb149452f61fb",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c0cc9e32_a0bc0251",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-11-22T06:33:59Z",
      "side": 1,
      "message": "Approved as part of the drive to remove AsyncInvoker.\nBut I do think we need to improve documentation.\n",
      "revId": "921ac1a5ccbf1d17f4425a55b44cb149452f61fb",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bbcc9612_553038fe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-11-22T06:33:59Z",
      "side": 1,
      "message": "The good thing (to me) about the weak pointer is that I think I understand it; it\u0027s easy to explain as \"it\u0027s a pointer that\u0027s null when what it points to is deallocated\". I wouldn\u0027t recommend writing \"automatic\" utilities on top of it; that\u0027s just more concepts to explain.\n\nThe utility functions here (ToQueuedTask and its ScopedTaskSafety argument) are much less obvious. We probably need a g3doc that summarizes recommended tasking, queueing and invoking practice that explains how to use these efficiently.\n\n(I note also that this CL makes binaries bigger, not smaller)",
      "parentUuid": "975dd3c5_10a6606a",
      "revId": "921ac1a5ccbf1d17f4425a55b44cb149452f61fb",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dae7eafe_48984c9a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-11-22T13:43:26Z",
      "side": 1,
      "message": "fixed the binary size issue. I\u0027m not too worried about the previous patch set though (84 bytes) since we currently also have AsyncInvoker in the binary and depending on the code layout, the size may also go down. The bigger impact is that the code path for cleaning up the cancelled tasks is lock free and involves no additional operations besides raising a flag.",
      "parentUuid": "bbcc9612_553038fe",
      "revId": "921ac1a5ccbf1d17f4425a55b44cb149452f61fb",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "994501a5_661ae927",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-11-22T13:43:26Z",
      "side": 1,
      "message": "Since these utilities are relatively new to the code base, I can understand that it takes some time. How to use WeakPtr has also been surprising to many that haven\u0027t been familiar with it and I ended up digging through the implementation back in the day to also understand why it works the way it does (and the benefits of that design). I\u0027d give ScopedTaskSafety and PendingTaskSafetyFlag a shot at understanding, take a look at the documentation that does exist (pending_task_safety_flag.h + the unit tests). They seem to match well with lambdas since lambdas are their own construct, but it would be good to hear how you\u0027d use weak_ptr in a way that would be simpler to understand",
      "parentUuid": "c0cc9e32_a0bc0251",
      "revId": "921ac1a5ccbf1d17f4425a55b44cb149452f61fb",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}