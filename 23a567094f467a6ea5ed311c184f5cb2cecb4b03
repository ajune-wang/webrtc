{
  "comments": [
    {
      "key": {
        "uuid": "4a69266c_eb808b24",
        "filename": "api/rtp_packet_infos.h",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 8392
      },
      "writtenOn": "2019-08-08T15:07:25Z",
      "side": 1,
      "message": "Could you test the perf without the `\u0026\u0026` here and below?\n\nThe regular Google style is very strict on either just using `SomeType` or implementing both `const SomeType\u0026\u0026` and `SomeType\u0026\u0026` together.",
      "range": {
        "startLine": 49,
        "startChar": 37,
        "endLine": 49,
        "endChar": 39
      },
      "revId": "23a567094f467a6ea5ed311c184f5cb2cecb4b03",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "786718b1_9785aac6",
        "filename": "api/rtp_packet_infos.h",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 7015
      },
      "writtenOn": "2019-08-08T19:12:33Z",
      "side": 1,
      "message": "From efficiency point of view, the order is\n1. const vector_type\u0026\n2. vector_type\u0026\u0026\n3. vector_type\n\n1,2 are similar, though.\n\nI don\u0027t think \"const vector_type\u0026\u0026\" makes much sense (I may be wrong). As a temporal variable, \"const vector_type\u0026\u0026\" is similar to \"const vector_type\" in a way that it is detached from the original variable.",
      "parentUuid": "4a69266c_eb808b24",
      "range": {
        "startLine": 49,
        "startChar": 37,
        "endLine": 49,
        "endChar": 39
      },
      "revId": "23a567094f467a6ea5ed311c184f5cb2cecb4b03",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5cd3b18_b0f7c7c9",
        "filename": "api/rtp_packet_infos.h",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 8392
      },
      "writtenOn": "2019-08-08T19:36:49Z",
      "side": 1,
      "message": "I meant the copy constructor. I.e. we either have to do (1) + (2) or (3). See:\n\n    https://google.github.io/styleguide/cppguide.html#Rvalue_references\n\nSpecifically this part:\n\n    You may use rvalue references to define pairs of overloads, one taking Foo\u0026\u0026 and the other taking const Foo\u0026. Usually the preferred solution is just to pass by value, ...",
      "parentUuid": "786718b1_9785aac6",
      "range": {
        "startLine": 49,
        "startChar": 37,
        "endLine": 49,
        "endChar": 39
      },
      "revId": "23a567094f467a6ea5ed311c184f5cb2cecb4b03",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "88a4a9de_481129b9",
        "filename": "api/rtp_packet_infos.h",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 7015
      },
      "writtenOn": "2019-08-08T20:17:04Z",
      "side": 1,
      "message": "I think either 1 or 2 should be good in this case.\n\nAs far as I understand, it does not make sense to define pairs of overloads on ctors. see\nhttps://google.github.io/styleguide/cppguide.html#Copyable_Movable_Types\n\nMove ctor is suppressed by copy ctor (a copiable type must be movable).\n\nWhether we want a copy ctor (or only move ctor) depends on whether we want RtpPacketInfos to be movable-only.\n\nData::Create(), as non-ctor, may worth the pairs of overloads. To me, since it is a nested type, and only use case is with move, a rvalue version can be enough.",
      "parentUuid": "e5cd3b18_b0f7c7c9",
      "range": {
        "startLine": 49,
        "startChar": 37,
        "endLine": 49,
        "endChar": 39
      },
      "revId": "23a567094f467a6ea5ed311c184f5cb2cecb4b03",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "488b0c57_ec9284fd",
        "filename": "api/rtp_packet_infos.h",
        "patchSetId": 2
      },
      "lineNbr": 49,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-08-09T08:05:47Z",
      "side": 1,
      "message": "Some points:\n\n  * Passing by reference is going to be cheaper than passing by value even if the latter moves rather than copies, because temporary objects are created and destroyed; whereas passing by reference is essentially the same as passing a pointer when you look at the compiler output.\n\n  * As the style guide quote above says, if you accept T\u0026\u0026 there should also be a corresponding overload that accepts const T\u0026.\n\n  * There\u0027s no reason not to define a pair of constructors that take T\u0026\u0026 and const T\u0026. So in this particular case, consider defining one that takes vector_type\u0026\u0026 and one that takes const vector_type\u0026, and ensure that Data::Create() (and whatever things *it* end up calling) do the same.",
      "parentUuid": "88a4a9de_481129b9",
      "range": {
        "startLine": 49,
        "startChar": 37,
        "endLine": 49,
        "endChar": 39
      },
      "revId": "23a567094f467a6ea5ed311c184f5cb2cecb4b03",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}