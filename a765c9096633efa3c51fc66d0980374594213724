{
  "comments": [
    {
      "key": {
        "uuid": "9da031f9_bc77f510",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-10-05T08:39:07Z",
      "side": 1,
      "message": "Hi, can you explain the usecase? If we have a native frame (typically a gpu texture), and need a frame in main memory for software encoding, why isn\u0027t ToI420() good enough? The implementation I\u0027m aware of should be reasonably efficient, https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/sdk/android/api/org/webrtc/YuvConverter.java;drc\u003df2889bbaf40c37b80fad129dede112107b0af103;l\u003d125",
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e58c4dbe_4bbdd638",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 8683
      },
      "writtenOn": "2020-10-05T08:55:00Z",
      "side": 1,
      "message": "The purpose is to provide a way to avoid conversions where possible. If a frame is captured from a source in NV12, in which case we can provide access to that without requiring conversion to I420. For example, in Chrome a native frame is wrapped to adapt a webrtc buffer. However the backing frame may be in a non-I420 format, like when we capture onto a GPU, the frame is in NV12. This method allows access without an extra conversion or copy.\n\nIn the example above, it could be that the data is not trivially accessible, in which case this method would just return null and ToI420 would be needed.",
      "parentUuid": "9da031f9_bc77f510",
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "117e975a_105e9801",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 4
      },
      "lineNbr": 1344,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-10-05T08:57:18Z",
      "side": 1,
      "message": "This looks scary.\n\n|set_video_frame_buffer| accepts scoped_refptr. So that we have here is taking contents of one scoped_refptr and put it into another scoped_refptr. So it seems here that we would get two smart pointers pointing to the same address each with it\u0027s own counter. Then once converted_buffer gets destroyed it should free the memory and we would get use-after-free.\n\nI think it\u0027s not that\u0027s actually happening because rtc::scoped_refptr doesn\u0027t have any counters: the object at the pointed memory holds them.\n\nStill, maybe try to rewrite it by creating a new scoped_refptr and initializing it with converted_buffer.\n\nAlso, I don\u0027t fully understand why the const cast is even needed.\nset_video_frame_buffer() accepts |const rtc::scoped_refptr\u003cVideoFrameBuffer\u003e\u0026|.\nconverted_buffer is |rtc::scoped_refptr\u003cVideoFrameBuffer\u003e|. It should work!",
      "range": {
        "startLine": 1344,
        "startChar": 55,
        "endLine": 1344,
        "endChar": 60
      },
      "revId": "a765c9096633efa3c51fc66d0980374594213724",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}