{
  "comments": [
    {
      "key": {
        "uuid": "96d1b7c2_4e4913c8",
        "filename": "rtc_base/logging.h",
        "patchSetId": 8
      },
      "lineNbr": 272,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-04-09T17:31:25Z",
      "side": 1,
      "message": "Why do you need these? Isn\u0027t it enough that trying to call ToLogString on an unsupported type will be an error? That\u0027s how you do it in checks.h.",
      "range": {
        "startLine": 268,
        "startChar": 0,
        "endLine": 272,
        "endChar": 31
      },
      "revId": "abd26f12c2a5ddf4e530f376f76f603469b9d31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f0687683_b32b90b4",
        "filename": "rtc_base/logging.h",
        "patchSetId": 8
      },
      "lineNbr": 272,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-04-10T11:01:47Z",
      "side": 1,
      "message": "In checks we don\u0027t use the ostream \u003c\u003c overload. Here we need to exclude the \u003c\u003c overload that is available in debug builds from types that have the ToLogString overload. This was the way I could find to do this.",
      "parentUuid": "96d1b7c2_4e4913c8",
      "range": {
        "startLine": 268,
        "startChar": 0,
        "endLine": 272,
        "endChar": 31
      },
      "revId": "abd26f12c2a5ddf4e530f376f76f603469b9d31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18447d3b_7ab5e7cf",
        "filename": "rtc_base/logging.h",
        "patchSetId": 8
      },
      "lineNbr": 272,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-04-11T11:52:35Z",
      "side": 1,
      "message": "Oh---so for logging.h you need to define a named trait, has_to_log_string, whereas for checks.h it\u0027s sufficient to use decltype(ToLogString(std::declval\u003cT\u003e())) in a template argument + make sure that it returned std::string?\n\nYou could do this:\n\n  template \u003ctypename T, typename \u003d void\u003e\n  struct has_to_log_string : std::false_type {};\n\n  template \u003ctypename T\u003e\n  struct has_to_log_string\u003cT, typename std::enable_if\u003cstd::is_same\u003c\n    std::string, decltype(ToLogString(std::declval\u003cT\u003e()))\u003e::value\u003e::type\u003e\n      : std::true_type {};\n\nThe specialization is active if and only if\n\n  std::is_same\u003cstd::string, decltype(ToLogString(std::declval\u003cT\u003e()))\u003e::value\n\nis legal and evaluates to true.",
      "parentUuid": "f0687683_b32b90b4",
      "range": {
        "startLine": 268,
        "startChar": 0,
        "endLine": 272,
        "endChar": 31
      },
      "revId": "abd26f12c2a5ddf4e530f376f76f603469b9d31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86cc3863_dd7eabee",
        "filename": "rtc_base/logging.h",
        "patchSetId": 8
      },
      "lineNbr": 272,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-04-11T14:50:32Z",
      "side": 1,
      "message": "Kind of, for logging I need to ensure that the implementation for the ostream \u003c\u003c overload does not match, the matcher in checks.h would be sufficient for the other one, but I prefer to use the special matcher in both for consistency.\n\nThanks! That\u0027s much nicer!",
      "parentUuid": "18447d3b_7ab5e7cf",
      "range": {
        "startLine": 268,
        "startChar": 0,
        "endLine": 272,
        "endChar": 31
      },
      "revId": "abd26f12c2a5ddf4e530f376f76f603469b9d31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d0677888_1f916ab9",
        "filename": "rtc_base/logging.h",
        "patchSetId": 8
      },
      "lineNbr": 272,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-04-12T01:51:19Z",
      "side": 1,
      "message": "I initially thought that this could be a job for absl::void_t, but it turns out that if you need to check that the call compiles *and* that the return type is right, std::enable_if was the right tool.",
      "parentUuid": "86cc3863_dd7eabee",
      "range": {
        "startLine": 268,
        "startChar": 0,
        "endLine": 272,
        "endChar": 31
      },
      "revId": "abd26f12c2a5ddf4e530f376f76f603469b9d31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}