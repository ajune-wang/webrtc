{
  "comments": [
    {
      "key": {
        "uuid": "9b2a5e9d_09e0efd9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-14T15:15:51Z",
      "side": 1,
      "message": "What does this mean? What happens to the queued task? Which thread deletes its resources?",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52b6b60e_cafb695e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T08:02:23Z",
      "side": 1,
      "message": "It\u0027s similar to TaskQueue::PostTask(...): The TaskQueue/MessageQueue takes ownership of the the thing posted. If the task gets to run, it is deleted on the TaskQueue thread. If it doesn\u0027t get to run, it is nevertheless deleted, but that may happen at some unspecified time on some unspecified thread. In the case that caused trouble, I think destruction happens on the main thread, from the AutoThread destructor, invoked just before main returns.",
      "parentUuid": "9b2a5e9d_09e0efd9",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2dc7d093_dbf64829",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-16T09:03:14Z",
      "side": 1,
      "message": "This breaks the contract.\n\n// Posts a task to invoke the functor on |this| thread asynchronously, i.e.\n// without blocking the thread that invoked PostTask(). Ownership of |functor|\n// is passed and destroyed on |this| thread after it is invoked.\n...\n\nWe can change the contract to not hold in the case of thread shutdown, but I\u0027m afraid we would hide real races.\n\nOne of the use cases I want PostTask to support is:\n\n// Delete |foo| on |thread_|.\nvoid DeleteFoo(std::unique_ptr\u003cFoo\u003e foo) {}\nthread_-\u003ePostTask(\n  FROM_HERE,\n  rtc::Bind(\u0026DeleteFoo, std::move(foo));\n\nThis allows Foo to have destructors with DCHECKs that it is destroyed on the right thread, and allows the destructor to have dependency on things that live on the target thread, and so on.\n\nIf the message is deleted (including its arguments) then we can no longer use PostTask to clean things up on the desired thread.",
      "parentUuid": "52b6b60e_cafb695e",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "42fb9ea7_e8e395e5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T09:37:26Z",
      "side": 1,
      "message": "\u003e This breaks the contract.\n\u003e \n\u003e // Posts a task to invoke the functor on |this| thread asynchronously, i.e.\n\u003e // without blocking the thread that invoked PostTask(). Ownership of |functor|\n\u003e // is passed and destroyed on |this| thread after it is invoked.\n\u003e ...\n\nOk, that documentation needs to be updated, if this cl is landed.\n\nI don\u0027t think Thread::PostTask should promise more than TaskQueue::PostTask. Its doc (rtc_base/task_queue.h) says:\n\n// A note on destruction:                                                                                                                                   \n//                                                                                                                                                          \n// When a TaskQueue is deleted, pending tasks will not be executed but they will                                                                            \n// be deleted.  The deletion of tasks may happen asynchronously after the                                                                                   \n// TaskQueue itself has been deleted or it may happen synchronously while the                                                                               \n// TaskQueue instance is being deleted.  This may vary from one OS to the next                                                                              \n// so assumptions about lifetimes of pending tasks should not be made.             \n\n\u003e One of the use cases I want PostTask to support is:\n\u003e \n\u003e // Delete |foo| on |thread_|.\n\u003e void DeleteFoo(std::unique_ptr\u003cFoo\u003e foo) {}\n\u003e thread_-\u003ePostTask(\n\u003e   FROM_HERE,\n\u003e   rtc::Bind(\u0026DeleteFoo, std::move(foo));\n\u003e \n\u003e This allows Foo to have destructors with DCHECKs that it is destroyed on the right thread, and allows the destructor to have dependency on things that live on the target thread, and so on.\n\nTaskQueues don\u0027t guarantee that destructor is called on the TaskQueue. But this pattern should nevertheless be safe in many cases. If some state lives on a particular thread, and the destructor runs after that thread is dead, then the destructor can assume exclusive access to the state. Not sure about the fine details, but I think thread exit and pthread_join include the needed memory barriers for that to work correctly.\n\nThat\u0027s why the compiler allows a destructor (or constructor) without annotations or thread checks, to access members annotated as RTC_GUARDED_BY.",
      "parentUuid": "2dc7d093_dbf64829",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a083879a_ee3a1cf5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-16T09:03:14Z",
      "side": 1,
      "message": "I think I know what the leak is, and that this is a real bug.\n\nRTCStatsCollector::ProducePartialResultsOnNetworkThread posts a task to perform MergeNetworkReport_s on the signaling thread. Normally, we rely on this task being run, and a test would not quit until all pending stats requests have completed.\n\nHowever, when PeerConnection::Close() is called, there is a special code path that triggers completing the task request, without waiting for the posted task to run. Close() calls RTCStatsCollector::WaitForPendingRequest(). This performs the work of MergeNetworkReport_s, and when/if the previously posted MergeNetworkReport_s runs after that it is a NO-OP.\n\nIf we want to be able to shut down the thread after PeerConnection::Close() there are a few options...\n1. Make posted tasks cancellable, and WaitForPendingRequest would cancel the posted task since it is no longer needed.\n2. When a thread is shutting down, make sure it runs all of the tasks in its queue before quitting.\n3. Change the contract of PostTask, and make the caller responsible for either making sure the task has time to run before thread is shut down or be prepared for the message to be deleted on the wrong thread without the task running.",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "580ee8a3_ae9bafc8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-16T09:05:38Z",
      "side": 1,
      "message": "Do we not do 2) already?\nWhat does https://webrtc-review.googlesource.com/c/src/+/39680 change with regards to tasks running?",
      "parentUuid": "a083879a_ee3a1cf5",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96996fbb_0ee496c5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T09:37:26Z",
      "side": 1,
      "message": "\u003e Do we not do 2) already?\n\nI think we may do that on some platforms, and that\u0027s considered a bug. Changing the TaskQueue behavior has been under discussion, but I dont think we\u0027ve had any agreement to change it. I don\u0027t recall the pros and cons off the top of my head.\n\nIn this case, running the task from the main thread as part of AutoThread destruction seems like a risk for use-after-free.\n\n\u003e What does https://webrtc-review.googlesource.com/c/src/+/39680 change with regards to tasks running?\n\nBoth before and after that cl, we create an rtc::Thread object wrapping the main thread. By the time the test ends, that thread has a pending message. As far as I understand, before the cl, that Thread object is never destroyed, but considered unleaked by asan because it is pointed to by the thread local variable backing rtc::Current(). After the cl, the Thread object is destroyed. At destruction, it has a pending message with a MessageHandler allocated by Thread::PostTask, and asan reports that this object is leaked.",
      "parentUuid": "580ee8a3_ae9bafc8",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce2b3017_5ecdbde4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-16T11:22:02Z",
      "side": 1,
      "message": "Can we not execute all pending tasks as part of destroying the thread? I assumed this is how PostTask would operate. It seems premature to delete a thread that still has work to do.",
      "parentUuid": "96996fbb_0ee496c5",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ef690500_6babef66",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T11:43:53Z",
      "side": 1,
      "message": "\u003e Can we not execute all pending tasks as part of destroying the thread? I assumed this is how PostTask would operate. It seems premature to delete a thread that still has work to do.\n\nThat\u0027s not how TaskQueue works. When you destroy a TaskQueue, you only block until any currently running task is finished. Task that are still pending will not be run, but deleted (synchronously or asynchronously, depending on TQ implementation). In any case, by the time the TaskQueue destructor returns, it is safe to destroy any state referenced by tasks posted to that task queue.\n\nWe could perhaps change it, but that would be a big change. I\u0027d need something simpler to unblock https://webrtc-review.googlesource.com/c/src/+/39680.\n\nAnd in the problem case, would it be of any help? The task would be run when AutoThread is destructed, in the main function of the test executable, long after the peerconnections under test have been destroyed. In this case, just deleting the task without running it seems more reasonable to me.\n\nTo make things synchronous, the standard (but somewhat discouraged) trick is to post a task that sets an event, and then block waiting for that event (while making sure that the TaskQueue stays alive). Maybe PeerConnection::Close should do that? It seems dangerous to have related pending tasks on the signal thread, when PeerConnection is closed and later destroyed.\n\nAnd then if Close itself is called from the signal thread, that might make things more complicated; the event trick will immediately deadlock.",
      "parentUuid": "ce2b3017_5ecdbde4",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc2464c3_d7a37a79",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-16T13:46:22Z",
      "side": 1,
      "message": "\u003e When you destroy a TaskQueue, you only block until any currently running task is finished.\n\nDo you know the reasoning behind this?\n\n\u003e In this case, just deleting the task without running it seems more reasonable to me.\n\nDeleting a task without running it is sometimes reasonable, and sometimes not. Cases:\n\n1. We want to execute a task later, but it is not crucial, and it is OK to cancel any such pending task on shutdown, including deleting the rtc::Bind arguments on any(?) thread.\n\n2. We post a task to a thread because it must execute on that thread. If the task doesn\u0027t execute or doesn\u0027t delete the rtc::Bind arguments on that thread then we have an invalid assumption that we need to fix, else we might cause DCHECK crashes or resource leaks. For example, we probably shouldn\u0027t kill the network thread before we\u0027ve cleaned up network resources that are in use.\n\nHaving support for 1) could be handy (and RTCStatsCollector would work with a cancellable task, fixing the ASAN error you see). However this is more of a special case than the desired contract. If our solution is to always delete pending tasks on the wrong thread then we are not supporting use case 2), it might be better to get a DCHECK crash saying \"Attempting to delete a thread that still has pending tasks\" if this happens than to silently not do what you expect.\n\n\u003e We could perhaps change it, but that would be a big change. I\u0027d need something simpler to unblock https://webrtc-review.googlesource.com/c/src/+/39680.\n\nI\u0027m OK with only supporting 1) for now since PostTask is not used elsewhere and we can add a TODO. But I believe 2) is important, and I\u0027m not sure I understand why we couldn\u0027t just execute all pending tasks while disallowing (with DCHECK) tasks to post new tasks during shutdown.",
      "parentUuid": "ef690500_6babef66",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "99fe2742_b9c172ba",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-17T07:17:26Z",
      "side": 1,
      "message": "\u003e 1. We want to execute a task later, but it is not crucial, and it is OK to cancel any such pending task on shutdown, including deleting the rtc::Bind arguments on any(?) thread.\n\nThat TQ abstraction currently has no builtin way to cancel a task; when needed, that has to implemented in the task itself (which may need additional synchronization).\n \n\u003e 2. We post a task to a thread because it must execute on that thread. If the task doesn\u0027t execute or doesn\u0027t delete the rtc::Bind arguments on that thread then we have an invalid assumption that we need to fix, else we might cause DCHECK crashes or resource leaks. For example, we probably shouldn\u0027t kill the network thread before we\u0027ve cleaned up network resources that are in use.\n\nMaybe you can write to the webrtc-core list, and we can discuss this on Monday? I still think that in many cases, destroying stuff on an arbitrary thread is ok, after the thread owning the stuff in question is stopped.\n\n\u003e I\u0027m OK with only supporting 1) for now since PostTask is not used elsewhere and we can add a TODO. \n\nThanks. I\u0027ll try to get this landed, with documentation updated, then.\n\n\u003e But I believe 2) is important, and I\u0027m not sure I understand why we couldn\u0027t just execute all pending tasks while disallowing (with DCHECK) tasks to post new tasks during shutdown.\n\nSilently discarding tasks posted to a TQ being shut down was important for PostTaskAndReply. But that feature has been deleted. So now, I think posting to a TQ being shutdown is more or less the same thing as use-after-free.",
      "parentUuid": "dc2464c3_d7a37a79",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "322e2fdf_82b300e1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-17T08:03:07Z",
      "side": 1,
      "message": "\u003e Maybe you can write to the webrtc-core list, and we can discuss this on Monday?\n\nSGTM",
      "parentUuid": "99fe2742_b9c172ba",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "467d6623_f42f7905",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 264,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-13T16:22:15Z",
      "side": 1,
      "message": "This can be `auto`, I think.",
      "range": {
        "startLine": 264,
        "startChar": 11,
        "endLine": 264,
        "endChar": 54
      },
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73646b6b_70907782",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 264,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T08:02:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "467d6623_f42f7905",
      "range": {
        "startLine": 264,
        "startChar": 11,
        "endLine": 264,
        "endChar": 54
      },
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f631694_e7c577ea",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-13T16:17:04Z",
      "side": 1,
      "message": "Why not just\n\n  static rtc_thread_internal::MessageHandlerWithTask handler;\n\n?",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "650bfcb3_05c308e5",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-13T16:22:15Z",
      "side": 1,
      "message": "Ah, because it has a nontrivial destructor.",
      "parentUuid": "8f631694_e7c577ea",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "264bb51b_8a5c0b12",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T08:02:23Z",
      "side": 1,
      "message": "Exactly. Why it\u0027s \"non-trivial\" isn\u0027t clear to me, maybe because the vtable pointer is supposed to be updated during the destruction sequence? If there\u0027s any reasonable way we could arrange to make constructor and destructor trivial, I\u0027d prefer that.",
      "parentUuid": "650bfcb3_05c308e5",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a66990e_5313a8ee",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-16T08:49:32Z",
      "side": 1,
      "message": "Basically, a trivial destructor is one that is guaranteed to not to have to execute any instructions. But MessageHandlerWithTask has a virtual destructor, which means that the compiler needs to look up the actual destructor in the vtable and then execute that.\n\nIn theory, the compiler could realize that MessageHandlerWithTask is final and that its destructor (and that of its parent, MessageHandler) are both no-ops, but the standard doesn\u0027t work that way. Since destructor triviality is an observable property, there is a need to mandate exactly when it happens---otherwise, code that assumes triviality would work in one compiler and fail in another.",
      "parentUuid": "264bb51b_8a5c0b12",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3cef2bc7_5605db15",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T08:58:40Z",
      "side": 1,
      "message": "Is there a good reason why an abstract interface, like MessageHandler, needs to implement a destructor at all? If it were declared like\n\n  virtual ~MessageHandler() \u003d 0;\n\nthen it should be pretty clear to the compiler that it can\u0027t generate any code to call it.",
      "parentUuid": "6a66990e_5313a8ee",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a1be05e_c1b3970a",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-16T09:15:38Z",
      "side": 1,
      "message": "Subclass destructors need to call their parents\u0027 destructors. They can\u0027t do that if those are pure virtual. (I *think* that the virtualness of the destructor only comes into play at the top level, when you start destroying the object; the call to parents\u0027 destructors is probably direct and not virtual, otherwise all sorts of bad things would happen...)",
      "parentUuid": "3cef2bc7_5605db15",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}