{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "2f66d7d2_d1cd241a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2022-01-27T05:39:21Z",
      "side": 1,
      "message": "Adding hbos@ as reviewer because I\u0027m not sure why this was synchronoous in the first place.\n\nThe thing that can happen when it\u0027s not is that arriving packets get demuxed according to the old instructions after the reconfiguration has finished on the signaling thread but before the new instructions are installed on the network thread. I\u0027m not sure that can really hurt, but needs to be considered.\n",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f4d3576d_f72a92e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 5142
      },
      "writtenOn": "2022-01-27T09:58:39Z",
      "side": 1,
      "message": "If the intent was to invaldiate any in-flight tasks, I think the flag needs to be set to a new instance of the object when it toggles. But if the intent was simply to keep track of whether or not the transport is alive, I would prefer to see a mix of the existing alive_ flag and a plain old boolean",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "340502ef_ead4b28f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 5142
      },
      "writtenOn": "2022-01-27T10:04:34Z",
      "side": 1,
      "message": "I am being mistaken here. See other reply to myself.",
      "parentUuid": "f4d3576d_f72a92e4",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1ae7853c_c0258af4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 5142
      },
      "writtenOn": "2022-01-27T10:23:22Z",
      "side": 1,
      "message": "I don\u0027t remember this exact part of the code, but there were issues with demuxing criteria not being the same on the different threads, leading to unsignalled ssrc stream creation. +Taylor may be another good person to add here.",
      "parentUuid": "2f66d7d2_d1cd241a",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "76f43c10_92753a6a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2022-01-27T10:42:03Z",
      "side": 1,
      "message": "After sleeping on this ... it is not an issue. We dispatch to the network thread, and the network thread will process this before consuming the next packet - it\u0027s the network thread, after all!",
      "parentUuid": "1ae7853c_c0258af4",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9581b05c_a1a17656",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2022-01-27T10:42:03Z",
      "side": 1,
      "message": "No, sync is not an issue.",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e02467a3_ad774ee3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 5686
      },
      "writtenOn": "2022-01-27T22:51:07Z",
      "side": 1,
      "message": "\u003e We dispatch to the network thread, and the network thread will process this before consuming the next packet - it\u0027s the network thread, after all!\n\nNot necessarily, it could be in the middle of processing a packet while all this is happening. So now the problem that `OnDemuxerCriteriaUpdatePending`/`OnDemuxerCriteriaUpdateComplete` is moved up a level to the network thread; a packet demuxed with the old criteria can arrive after its video stream was removed, causing an unsignaled stream to be created, which could be an issue if that stream is later added to a different m\u003d section",
      "parentUuid": "76f43c10_92753a6a",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "215b090e_c46ee30c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 5686
      },
      "writtenOn": "2022-01-27T22:51:07Z",
      "side": 1,
      "message": "This reintroduces the unsignaled SSRC race as described below. Also, it means we can\u0027t use the return value of RegisterRtpDemuxerSink, which began being ignored here (https://webrtc-review.googlesource.com/c/src/+/244700) which I\u0027m not sure was the best decision.\n\nIt may be time to come up with a more elegant solution for this problem. Really the core issue is that we have two RtpDemuxers. The one on the network thread has all knowledge of the demux criteria (SSRCs, MIDs, payload types), so at least in theory it should be able to handle all types of conflicts elegantly. But the one on the worker thread only demuxes by SSRC, so it doesn\u0027t know whether a stream was created due to an \"a\u003dssrc\" or due to the default stream logic; whichever reserved the SSRC first gets priority.\n\nEither we need to move to a point where we only have one RtpDemuxer (probably a long term refactoring project) or we need another way to handle these conflicts. Like providing a way for one media channel to cause another media channel\u0027s default stream to get destroyed if its own demux criteria takes priority.",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4a1df6f_eac0a96c",
        "filename": "pc/channel.cc",
        "patchSetId": 8
      },
      "lineNbr": 231,
      "author": {
        "id": 5142
      },
      "writtenOn": "2022-01-27T09:58:39Z",
      "side": 1,
      "message": "Because this flag is toggled on and off you are not necessarily cancelling in-flight tasks. If SetRtpTransport() is called again and SetAlive() happens, those in-flight tasks would still run.\n\nBecause of this, I think this flag behaves more like a plain old boolean, so I would prefer to see a boolean that is RTC_GUARDED_BY(network_thread()).\n\nAlternatively if the intent was to cancel in-flight tasks, a scoped safety flag can still be used, but then we need to set network_alive_ to a new instance of the safety flag object.",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b96683f_cfa6feee",
        "filename": "pc/channel.cc",
        "patchSetId": 8
      },
      "lineNbr": 231,
      "author": {
        "id": 5142
      },
      "writtenOn": "2022-01-27T10:04:34Z",
      "side": 1,
      "message": "Hang on you do need a safety flag... see other comment.",
      "parentUuid": "b4a1df6f_eac0a96c",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bada45f4_3f6d213d",
        "filename": "pc/channel.cc",
        "patchSetId": 8
      },
      "lineNbr": 465,
      "author": {
        "id": 5142
      },
      "writtenOn": "2022-01-27T09:58:39Z",
      "side": 1,
      "message": "Why are we using a scoped safety flag for this rather than a boolean?\n\nIf you want to protect against use-after-free, there already exists an \"alive_\" safety flag.\n\nBecause network_alive_ is only used on the network thread I would prefer a plain old boolean and to do \"if (!network_alive_) return;\" inside the lambda.\nThe behavior would be the same, but when I see a scoped safety flag, I expect it to be used to cancel in-flight tasks, and this one doesn\u0027t add much more value than alive_ already does.",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1abd530c_e2f528b9",
        "filename": "pc/channel.cc",
        "patchSetId": 8
      },
      "lineNbr": 465,
      "author": {
        "id": 5142
      },
      "writtenOn": "2022-01-27T10:04:34Z",
      "side": 1,
      "message": "On second thought, alive_ is being SetNotAlive() inside the destructor on the worker thread, so that would still be racy with a task running on the network thread.\n\nIn this case I do see the need for this safety flag!\n\nBut can you confirm if it is OK for in-flight tasks not to be invalidated? I.e. you have a criteria update for the old transport, and then you change to a new transport. Is it OK for the old criteria update gets executed on the new transport?",
      "parentUuid": "bada45f4_3f6d213d",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "49b5d955_73d83bd9",
        "filename": "pc/channel.cc",
        "patchSetId": 8
      },
      "lineNbr": 465,
      "author": {
        "id": 5686
      },
      "writtenOn": "2022-01-27T22:51:07Z",
      "side": 1,
      "message": "\u003e alive_ is being SetNotAlive() inside the destructor on the worker thread\nWouldn\u0027t that cause an assert?",
      "parentUuid": "1abd530c_e2f528b9",
      "revId": "2adbba097c78cca520480ec354b7dfb3c78bb0a1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}