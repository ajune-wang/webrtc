{
  "comments": [
    {
      "key": {
        "uuid": "fa484196_35b70ca7",
        "filename": "modules/desktop_capture/mac/desktop_frame_provider.mm",
        "patchSetId": 16
      },
      "lineNbr": 40,
      "author": {
        "id": 6236
      },
      "writtenOn": "2018-03-30T23:02:10Z",
      "side": 1,
      "message": "I suddenly have a doubt here, should I call io_surfaces_[display_id] \u003d nullptr after move ?",
      "range": {
        "startLine": 40,
        "startChar": 47,
        "endLine": 40,
        "endChar": 0
      },
      "revId": "37a902204e12ab9722f96a547badf2e0099eeaff",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80d7a8bd_44c9b424",
        "filename": "modules/desktop_capture/mac/desktop_frame_provider.mm",
        "patchSetId": 16
      },
      "lineNbr": 40,
      "author": {
        "id": 5029
      },
      "writtenOn": "2018-03-30T23:23:06Z",
      "side": 1,
      "message": "It looks like you should return a const DesktopFrame\u0026, rather than a unique_ptr. My bad, I have not considered this at the first place.\n\nYou may want to have a unique_ptr in the DesktopFrameProvider level to store the DesktopFrame returned by DesktopFrameCGImage::CreateForDisplay(). And this io_surfaces_ to store the map between CGDirectDisplayID and DesktopFrameIOSurface. DesktopFrameProvider::Release() clears both the unique_ptr and the map.\n\nThe consumer of this class should not change the DesktopFrame returned by this function and also should not expect its lifetime. The return value is used to copy the pixel to a long-living DesktopFrame, i.e. the SharedDesktopFrame in ScreenCapturerMac.\n\nThis kind of implementation ensures the DesktopFrame returned by DesktopCapturer can outlive the DesktopCapturer itself. Since typically DesktopFrameProvider::Release() or the destructor will release all the instances of DesktopFrameCGImage or DesktopFrameIOSurface.",
      "parentUuid": "fa484196_35b70ca7",
      "range": {
        "startLine": 40,
        "startChar": 47,
        "endLine": 40,
        "endChar": 0
      },
      "revId": "37a902204e12ab9722f96a547badf2e0099eeaff",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3fd8cbcf_edeb442f",
        "filename": "modules/desktop_capture/mac/desktop_frame_provider.mm",
        "patchSetId": 16
      },
      "lineNbr": 40,
      "author": {
        "id": 5029
      },
      "writtenOn": "2018-03-30T23:45:50Z",
      "side": 1,
      "message": "A similar example in DirectX capturer on Windows:\nhttps://cs.chromium.org/chromium/src/third_party/webrtc/modules/desktop_capture/win/dxgi_output_duplicator.cc?rcl\u003d4157936823f72d53e105305a9da34f94dcb0771e\u0026l\u003d191",
      "parentUuid": "80d7a8bd_44c9b424",
      "range": {
        "startLine": 40,
        "startChar": 47,
        "endLine": 40,
        "endChar": 0
      },
      "revId": "37a902204e12ab9722f96a547badf2e0099eeaff",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "36c5dc88_acb4d50a",
        "filename": "modules/desktop_capture/mac/desktop_frame_provider.mm",
        "patchSetId": 16
      },
      "lineNbr": 40,
      "author": {
        "id": 6236
      },
      "writtenOn": "2018-03-31T14:21:49Z",
      "side": 1,
      "message": "Thx for the suggestion but it seems I will need another map then for the CGImage. Not really a problem but just to mention. But then there is a big problem for the io_surfaces case, the returned \"const DesktopFrame\u0026\" can be read while being destroyed since InvalidateIOSurface is called in another thread. The io_surfaces_lock_ just protects the map. I realize this was the same problem in previous solution with SharedDesktopFrame/-\u003eShare, i.e. rtc::scoped_refptr is not thread safe (isn\u0027t it ?).\n\nSo I think current implementation in Patch Set 16 is fine, since the caller of LatestFrameForDisplay takes ownership of the frame and it is removed from the map. I should maybe renamed these 2 functions. And eventually I need to explicitly call io_surfaces_[display_id] \u003d nullptr but maybe even not because the std:move makes the element in the map invalid so the next time this function is called the condition in \"if (io_surfaces_[display_id])\" will be false. Unless I am mistaken.\n\nWhat do you think ? Thx!",
      "parentUuid": "3fd8cbcf_edeb442f",
      "range": {
        "startLine": 40,
        "startChar": 47,
        "endLine": 40,
        "endChar": 0
      },
      "revId": "37a902204e12ab9722f96a547badf2e0099eeaff",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7502c7f3_1ce0ecad",
        "filename": "modules/desktop_capture/mac/desktop_frame_provider.mm",
        "patchSetId": 16
      },
      "lineNbr": 40,
      "author": {
        "id": 5029
      },
      "writtenOn": "2018-04-01T20:49:32Z",
      "side": 1,
      "message": "Interesting. I recall that you have mentioned this problem before: OS callback uses the thread which it has been initialized, i.e. the constructor / Init thread, but CaptureFrame() uses a dedicated thread.\n\nrtc::scoped_refptr itself is thread-safe, but as a pointer, it also requires the implementation of T to be thread-safe. SharedDesktopFrame is thread-safe.\n\nYou do not need to actively call io_surfaces_[display_id], std::move(std::unique_ptr) will erase the reference in the unique_ptr, it becomes nullptr anyway.\n\nSo yes, it looks like the patch #16 should be fine. Please update the name and the comment of the function.\n\nAlso, I am interested by the IOSurfaceIncrementUseCount() and IOSurfaceDecrementUseCount(). So it looks like we can also rely on the OS to help us maintain the lifetime.\nRather than unique_ptr\u003cDesktopFrame\u003e, we can return DesktopFrame\u0026\u0026 from DesktopFrameProvider. By using the default copy constructor, we can keep two references without destructing the IOSurface or CGImageRef and CGDataRef.\nThis is just a random idea; I am OK with current solution.",
      "parentUuid": "36c5dc88_acb4d50a",
      "range": {
        "startLine": 40,
        "startChar": 47,
        "endLine": 40,
        "endChar": 0
      },
      "revId": "37a902204e12ab9722f96a547badf2e0099eeaff",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "98a66607_8100463c",
        "filename": "modules/desktop_capture/mac/desktop_frame_provider.mm",
        "patchSetId": 16
      },
      "lineNbr": 40,
      "author": {
        "id": 6236
      },
      "writtenOn": "2018-04-04T03:42:33Z",
      "side": 1,
      "message": "Done with function rename and comment. Ack for inc/dec.",
      "parentUuid": "7502c7f3_1ce0ecad",
      "range": {
        "startLine": 40,
        "startChar": 47,
        "endLine": 40,
        "endChar": 0
      },
      "revId": "37a902204e12ab9722f96a547badf2e0099eeaff",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}