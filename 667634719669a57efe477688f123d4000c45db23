{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "05cfe90b_dcf74f11",
        "filename": "call/call.cc",
        "patchSetId": 4
      },
      "lineNbr": 1448,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-01-19T08:52:04Z",
      "side": 1,
      "message": "Longer term, I would like to handle unsignalled ssrcs as a callback from the RtpDemuxer. VideoEngine should somehow register video payload types it is willing to handle, and get a callback for packets matching those payload types but not matching any other registered demux criteria, in particular no known ssrc. \n\nAnd Call ideally shouldn\u0027t be on the per-packet path at all.",
      "range": {
        "startLine": 1442,
        "startChar": 0,
        "endLine": 1448,
        "endChar": 9
      },
      "revId": "667634719669a57efe477688f123d4000c45db23",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a07385f_b4c24197",
        "filename": "call/call.cc",
        "patchSetId": 4
      },
      "lineNbr": 1448,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-01-19T11:19:14Z",
      "side": 1,
      "message": "yes that should be possible and hopefully not need to involve thread hopping once this whole stack runs on the network thread. Basically all the way from channel.cc through call and to the demuxer, staying on the network thread. As is, it looks like for rtcp packets that Call does not reliably (or at all?) signal unknown SSRCs back to the caller (see TODO for pbos).",
      "parentUuid": "05cfe90b_dcf74f11",
      "range": {
        "startLine": 1442,
        "startChar": 0,
        "endLine": 1448,
        "endChar": 9
      },
      "revId": "667634719669a57efe477688f123d4000c45db23",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb732a07_5860004d",
        "filename": "call/packet_receiver.h",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-01-19T08:52:04Z",
      "side": 1,
      "message": "Do we have to expose this convenience alias in the public interface of this class? See totw/137. \n\nI would expect users to just pass in a lambda, and rely on implicit conversion to the appropriate std::function type?",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 37,
        "endChar": 21
      },
      "revId": "667634719669a57efe477688f123d4000c45db23",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c0fbfea_e6c7e613",
        "filename": "call/packet_receiver.h",
        "patchSetId": 4
      },
      "lineNbr": 37,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-01-19T11:19:14Z",
      "side": 1,
      "message": "We don\u0027t _have_ to but after going through the code that would be affected by this, then I\u0027m less worried about the callers than I am about the readability of all of the places where we need to pass around the callback variable or implement an in between layer since the packet passes through multiple.\n\nSee this CL (not ready for review yet) for example to see the amount of code that will be affected:\nhttps://webrtc-review.googlesource.com/c/src/+/202248",
      "parentUuid": "cb732a07_5860004d",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 37,
        "endChar": 21
      },
      "revId": "667634719669a57efe477688f123d4000c45db23",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}