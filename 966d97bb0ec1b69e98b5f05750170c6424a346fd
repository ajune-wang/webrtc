{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d1e663df_ca7366f5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 6092
      },
      "writtenOn": "2024-10-09T22:17:36Z",
      "side": 1,
      "message": "To use this Picker in Chrome Remote Desktop, we will need to report the real `SourceId` that is being captured.\n\nIf you need it to be constant, you could maybe clear the `allowsChangingSelectedContent` flag on the `SCContentSharingPickerConfiguration`?\n\nOtherwise, you could maybe call `OnSelection()` on the `DelegatedSourceListController` every time the `SourceId` changes - and then the consumer can get the new ID by calling `GetSourceList()`?\n\nThe selected screen ID is not documented in the SCK API, but Apple told us we can get it from the `display` attribute of the `SCContentFilter` property that\u0027s with the `SCContentSharingPicker`.\n\nI think this CL is fine for now, but we will eventually need to access the actual `SourceId` for Chrome Remote Desktop.\n\nFor now, I\u0027m not too concerned about the value of `allowsChangingSelectedContent`. We could always add a `DesktopCaptureOptions` setting for this later, if we need to change it?",
      "range": {
        "startLine": 15,
        "startChar": 10,
        "endLine": 17,
        "endChar": 53
      },
      "revId": "966d97bb0ec1b69e98b5f05750170c6424a346fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cd0b46ea_9f1e0df4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 8178
      },
      "writtenOn": "2024-10-11T13:03:17Z",
      "side": 1,
      "message": "Note that `GetSourceList` was originally for enumerating all sources to let *the application pick* source with `SelectSource`. This doesn\u0027t make sense with the system picker, since the system picker lets the user change source at will. If `DelegatedSourceListController` is implemented it starts making sense since you can track source selection changes. But then Firefox would have to adapt:\n\nIn Firefox if two clients wants to capture the same source they will share one capturer as an optimization. That wouldn\u0027t work if the selected source can change under your feet, which is why I invented unique SourceIds. This was modeled on `BaseCapturerPipeWire` which does something similar.\n\nShould this change we can adapt, assuming that `GetDelegatedSourceListController` can be used as a check for when `GetSourceList` can be changed by the capturer.\n\nAlso note that the unique `SourceId` generation only kicks in when the system picker is enabled in `ScreenCapturerSck`. `GetSourceList` with the system picker disabled is still unimplemented.\n\nAnother issue with using `GetSourceList` and `DelegatedSourceListController` to expose the real captured source with the system picker, is what to do when the `SCContentFilter` contains more than a plain display. It is always tied to a display but can also contain a list of windows to include or exclude. You might want to introduce a mode through `DesktopCaptureOptions` or a dedicated factory function that exposes the captured display, and locks the picker to single displays only, or as you say, prevents changes with `allowsChangingSelectedContent`. Either option here should be fairly trivial to implement. Ideally `GetSourceList` should function consistently across modes, but it can only go so far I guess.",
      "parentUuid": "d1e663df_ca7366f5",
      "range": {
        "startLine": 15,
        "startChar": 10,
        "endLine": 17,
        "endChar": 53
      },
      "revId": "966d97bb0ec1b69e98b5f05750170c6424a346fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52d4aa52_d7905221",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 17,
      "author": {
        "id": 6092
      },
      "writtenOn": "2024-10-12T00:36:28Z",
      "side": 1,
      "message": "`BaseCapturerPipeWire` is a bit weird, and is maybe not a good example to follow? My understanding is, that capturer itself creates the virtual display that it captures from?\n\nI don\u0027t think it was designed for capturing from real physical displays - it was written when we were implementing Wayland support for Chrome Remote Desktop. I don\u0027t know of anybody else using this code, and it is still very experimental.\n\nWe may change the way it works - I think something else should create the virtual display, and the Wayland capturer should be able to capture from it, or a real display. I have a feeling that the XDG Portal APIs are different for these cases, but I\u0027m no expert! ðŸ˜Š\n\nI\u0027m happy with any combination of DesktopCaptureOptions that lets CRD access the screen ID being captured, without breaking anything that Firefox is doing ðŸ˜Š",
      "parentUuid": "cd0b46ea_9f1e0df4",
      "range": {
        "startLine": 15,
        "startChar": 10,
        "endLine": 17,
        "endChar": 53
      },
      "revId": "966d97bb0ec1b69e98b5f05750170c6424a346fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4a17f134_d562a874",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 6092
      },
      "writtenOn": "2024-10-09T22:17:36Z",
      "side": 1,
      "message": "Thank you for doing this work, it\u0027s much appreciated! ðŸ˜Š",
      "revId": "966d97bb0ec1b69e98b5f05750170c6424a346fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}