{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "003f27c4_81b70950",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2024-03-06T12:55:22Z",
      "side": 1,
      "message": "Commenting on the standards process only.",
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f486500a_16b282f8",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 217,
      "author": {
        "id": 8038
      },
      "writtenOn": "2024-03-06T08:52:20Z",
      "side": 1,
      "message": "Tight latency bounds may have a negative effect on quality (resulting in more time stretching and underruns). Existing users of the playoutDelayHint API may use it to increase quality (at the cost of latency). This change breaks what we originally intended with the spec.\n\nI think it would be more appropriate to have another API, for example where it\u0027s possible to set both the min and max delay, for this use case where a fixed delay is more important than quality.",
      "range": {
        "startLine": 213,
        "startChar": 0,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "180972bc_8944a312",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 217,
      "author": {
        "id": 3281934
      },
      "writtenOn": "2024-03-06T10:22:12Z",
      "side": 1,
      "message": "Another API like proposed in https://github.com/w3c/webrtc-extensions/issues/199 would be ideal, but adding a new web exposed API is a painful process. Here I just came up with a workaround by setting the jitterBufferTarget to same value multiple times in a row, which results in setting precise_jitter_buffer_target_mode_ \u003d true. Rest of the changes are guarded by precise_jitter_buffer_target_mode_.",
      "parentUuid": "f486500a_16b282f8",
      "range": {
        "startLine": 213,
        "startChar": 0,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a75b6b96_9512c22c",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 217,
      "author": {
        "id": 8038
      },
      "writtenOn": "2024-03-06T10:46:50Z",
      "side": 1,
      "message": "I know it\u0027s a painful process but it seems like the right thing in this case :) \n\nChanging the behavior like this seems highly non-obvious for users and is not something that will be approved (sorry).",
      "parentUuid": "180972bc_8944a312",
      "range": {
        "startLine": 213,
        "startChar": 0,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd892e36_d6039ec4",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 217,
      "author": {
        "id": 3281934
      },
      "writtenOn": "2024-03-06T12:25:29Z",
      "side": 1,
      "message": "Ok, I see. What about triggering \"precise_jitter_buffer_target_mode_ \u003d true\" when min and max delay are equal? NetEq already has API to set min and max delay.\nAnd there exists rtp extension https://webrtc.googlesource.com/src/+/refs/heads/main/docs/native-code/rtp-hdrext/playout-delay, which if i am not missing something, is wired only for video. Wiring it for audio too might give the desired control to application layer, and at the same time it is worth to give a try with adding a new web exposed API.",
      "parentUuid": "a75b6b96_9512c22c",
      "range": {
        "startLine": 213,
        "startChar": 0,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "503d9e93_e0878829",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 217,
      "author": {
        "id": 5634
      },
      "writtenOn": "2024-03-06T12:55:22Z",
      "side": 1,
      "message": "Adding new functionality by abusing (\"re-interpreting\") existing APIs is generally frowned upon. If you have an API proposal in a bug / PR in the working group, it is acceptable (and customary) to add it in chromium behind a feature flag, so that it can be experimented with before it is standardized.\n\nI am very much aware that the process of driving through new features is a lot more painful than it seems to have any justification for being - but we haven\u0027t abandoned it yet; if we manage to drive it through, we at least have the hope that the browsers eventually converge on it; with non-standard API hacks, the chances are low-to-zero.",
      "parentUuid": "dd892e36_d6039ec4",
      "range": {
        "startLine": 213,
        "startChar": 0,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a7d026f_e0ec58d5",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 217,
      "author": {
        "id": 3281934
      },
      "writtenOn": "2024-03-07T07:20:13Z",
      "side": 1,
      "message": "Is there a need for new API in NetEq too or can min_delay \u003d\u003d max_delay condition to trigger precise target mode be sufficient and not considered as abuse of existing API? Also what would be the correct course of actions? Does it first need to be implemented in libWebrtc and then add JS API or should I start from intent to implement in blink-dev?",
      "parentUuid": "503d9e93_e0878829",
      "range": {
        "startLine": 213,
        "startChar": 0,
        "endLine": 217,
        "endChar": 3
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f2916f06_43807f39",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 325,
      "author": {
        "id": 8038
      },
      "writtenOn": "2024-03-06T08:52:20Z",
      "side": 1,
      "message": "This will not actually make the adaptation faster, which you described was the problem in the bug? So is this really necessary?",
      "range": {
        "startLine": 325,
        "startChar": 8,
        "endLine": 325,
        "endChar": 42
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "427504e9_c9c05cad",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 325,
      "author": {
        "id": 3281934
      },
      "writtenOn": "2024-03-06T10:22:12Z",
      "side": 1,
      "message": "The bug was initially filed based on just one example where the target was reached very slowly, which later turned out to specific to DTX scenario. In DTX scenario the adaption would be faster after this change. But during active speech the difference is slightly tighter delay tolerance and eliminating dependency on field trial \"config_.enable_stable_delay_mode\"",
      "parentUuid": "f2916f06_43807f39",
      "range": {
        "startLine": 325,
        "startChar": 8,
        "endLine": 325,
        "endChar": 42
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "079780e6_a68aff5b",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 344,
      "author": {
        "id": 8038
      },
      "writtenOn": "2024-03-06T08:52:20Z",
      "side": 1,
      "message": "This max delay is pretty important to avoid accelerating directly after an underrun (i.e. when network delay \u003e playout delay).",
      "range": {
        "startLine": 344,
        "startChar": 33,
        "endLine": 344,
        "endChar": 71
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0fa99c07_bc694707",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 344,
      "author": {
        "id": 3281934
      },
      "writtenOn": "2024-03-06T10:22:12Z",
      "side": 1,
      "message": "This \"low_limit + packet_arrival_history_-\u003eGetMaxDelayMs()\" part i do no quite understand yet, but isn\u0027t it more of a problem when the target delay is influenced by network conditions? With this change the max delay is set equal to min delay and there are no stretching expected unless the externally set jitterBufferTarget hasn\u0027t been reached yet. But once it is reached the delay is expected to be stable.",
      "parentUuid": "079780e6_a68aff5b",
      "range": {
        "startLine": 344,
        "startChar": 33,
        "endLine": 344,
        "endChar": 71
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d5a0fef_0017918b",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 344,
      "author": {
        "id": 8038
      },
      "writtenOn": "2024-03-06T10:46:50Z",
      "side": 1,
      "message": "No. If there is a network delay spike causing an underrun, then the delay will increase (in-order packets are not discarded in NetEq unless the buffer is full).",
      "parentUuid": "0fa99c07_bc694707",
      "range": {
        "startLine": 344,
        "startChar": 33,
        "endLine": 344,
        "endChar": 71
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ad4e503_5a9813c9",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 344,
      "author": {
        "id": 3281934
      },
      "writtenOn": "2024-03-06T12:25:29Z",
      "side": 1,
      "message": "Ok, then discarding the packets which do not fit into target delay is also missing from this CL.",
      "parentUuid": "8d5a0fef_0017918b",
      "range": {
        "startLine": 344,
        "startChar": 33,
        "endLine": 344,
        "endChar": 71
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd6617a4_30701a14",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 386,
      "author": {
        "id": 8038
      },
      "writtenOn": "2024-03-06T08:52:20Z",
      "side": 1,
      "message": "This will cause decoding to wait when there is packet loss until the right delay is achieved. Not sure if this is the correct thing to do. However, I think something similar to this would be appropriate when in DTX. It used to be the case, but it was changed recently, I think an oversight from my side, see `below_target_delay \u0026\u0026 !config_.combine_concealment_decision`.",
      "range": {
        "startLine": 386,
        "startChar": 6,
        "endLine": 386,
        "endChar": 40
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77b12776_47d1c595",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 6
      },
      "lineNbr": 386,
      "author": {
        "id": 3281934
      },
      "writtenOn": "2024-03-06T10:22:12Z",
      "side": 1,
      "message": "As far as I understood taking a future packet would change the playout delay, which is undesired in precise_jitter_buffer_target_mode_, but this change was mostly needed to make the delay adapt to the target in no voice activity periods.",
      "parentUuid": "dd6617a4_30701a14",
      "range": {
        "startLine": 386,
        "startChar": 6,
        "endLine": 386,
        "endChar": 40
      },
      "revId": "cabfadaf23aa545122af71efcefa4146a7127bda",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}