{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1c9d363c_25c168bc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 14134
      },
      "writtenOn": "2022-01-24T17:18:38Z",
      "side": 1,
      "message": "Can you add unit test cases to cover the new queue handling logic?",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "36f6402d_4aeee9d7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-01-24T18:03:20Z",
      "side": 1,
      "message": "I would like to, but haven\u0027t decided yet how to test all the PipeWire code. However, this queue handling logic is pretty trivial.\n\nIt\u0027s like having just two DesktopFrame instances we keep reusing, when one is being used (e.g. displayed by Chromium), we can keep storing new PW buffers to the other, then when someone asks for a new frame, we return the one we were using to store PW buffer and reuse the previous one and so on and so on.",
      "parentUuid": "1c9d363c_25c168bc",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "afa51158_1acbb86b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 14134
      },
      "writtenOn": "2022-01-25T01:05:46Z",
      "side": 1,
      "message": "I still think having tests that the frames are handled properly from the caller\u0027s point of view is a good idea.",
      "parentUuid": "36f6402d_4aeee9d7",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36f77ea1_8e265667",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 14134
      },
      "writtenOn": "2022-01-24T17:18:38Z",
      "side": 1,
      "message": "Should this be named process_frame_lock_?",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c6a8b93_2c9290e2",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-01-24T18:03:20Z",
      "side": 1,
      "message": "Probably something like queue_lock_. I will fix that.",
      "parentUuid": "36f77ea1_8e265667",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "739c2831_9da04263",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-01-25T11:34:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1c6a8b93_2c9290e2",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36d6b476_9d564c6e",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 544,
      "author": {
        "id": 14134
      },
      "writtenOn": "2022-01-24T17:18:38Z",
      "side": 1,
      "message": "Can you use the thread annotations in rtc_base/thread_annotations.h to annotate the code using process_frame_lock?  For example, the frame queue would be declared RTC_GUARDED_BY and this method would be declared RTC_EXCLUSIVE_LOCKS_REQUIRED.",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d5a2052_810fd122",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 544,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-01-25T11:34:57Z",
      "side": 1,
      "message": "I have problem with RTC_EXCLUSIVE_LOCKS_REQUIRED. When I annotate the SharedScreenCastStreamPrivate::CaptureFrame() with it, then when calling the non-private implementation where I just call the private one I get following:\n\n../../third_party/webrtc/modules/desktop_capture/linux/wayland/shared_screencast_stream.cc:723:20: error: calling function \u0027CaptureFrame\u0027 requires holding mutex \u0027private_-\u003equeue_lock_\u0027 exclusively [-Werror,-Wthread-safety-analysis]\n  return private_-\u003eCaptureFrame();\n  \nI don\u0027t know how this can be solved with annotations.",
      "parentUuid": "36d6b476_9d564c6e",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7d23ac3d_eb63b88a",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 544,
      "author": {
        "id": 14134
      },
      "writtenOn": "2022-01-25T17:39:19Z",
      "side": 1,
      "message": "OK, it looks like the annotation is checking that the lock is held before the function is called, which isn\u0027t the case here.",
      "parentUuid": "1d5a2052_810fd122",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47fc57ef_6f4336bf",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 658,
      "author": {
        "id": 14134
      },
      "writtenOn": "2022-01-24T17:18:38Z",
      "side": 1,
      "message": "This can be moved outside the lock.",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b0c9993a_eaf27c48",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 658,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-01-25T11:34:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "47fc57ef_6f4336bf",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "21f68deb_d805d83b",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 665,
      "author": {
        "id": 14134
      },
      "writtenOn": "2022-01-24T17:18:38Z",
      "side": 1,
      "message": "What does it mean when the frame is still shared?  Overwriting its contents may not be safe (especially with a frame of a different size).",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06f34000_3f4f4ee6",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 665,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-01-24T18:03:20Z",
      "side": 1,
      "message": "I don\u0027t think this situation can actually happen, as explained above how the ScreenCaptureFrameQueue works and I took this from the X11 capturer, but I think I can make it to drop the PW buffer in this case.",
      "parentUuid": "21f68deb_d805d83b",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bfaaf6d1_d3466c18",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 6
      },
      "lineNbr": 665,
      "author": {
        "id": 8046
      },
      "writtenOn": "2022-01-25T11:34:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "06f34000_3f4f4ee6",
      "revId": "b69e5929ab182f2a2f447b592c375e739461e665",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}