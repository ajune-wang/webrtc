{
  "comments": [
    {
      "key": {
        "uuid": "75cf409c_f1d057fd",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-29T15:17:35Z",
      "side": 1,
      "message": "is it info, or warning?",
      "range": {
        "startLine": 56,
        "startChar": 12,
        "endLine": 56,
        "endChar": 19
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6e9a82c_22f70719",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:34:15Z",
      "side": 1,
      "message": "I chose info because it would be normal if we supported multiple streams with the current api.",
      "parentUuid": "75cf409c_f1d057fd",
      "range": {
        "startLine": 56,
        "startChar": 12,
        "endLine": 56,
        "endChar": 19
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb83f819_83083939",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-29T08:48:41Z",
      "side": 1,
      "message": "Should we take kMinKeyFrameRequestIntervalMs into account also with MediaTransport?",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6c5909b_1f3f5107",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-29T15:17:35Z",
      "side": 1,
      "message": "My first thought is that this layer should be responsible for throttling key frame requests\nkMinKeyFrameRequestIntervalMs. \n\nAnd transport simply passes the requests to the other side, reliably.\n\nOtherwise, all implementations of media transport would have to repeat this logic? (or we would have to put it in some base class).",
      "parentUuid": "bb83f819_83083939",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "02213789_4bb71cd5",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:34:15Z",
      "side": 1,
      "message": "I agree transports shouldn\u0027t implement throttling. I\u0027m thinking maybe this should move to VideoStreamEncoder; that class also gets RTT estimates, and hence could do better than using a hard-coded constant.\n\nNot clear to me if we need it at the moment, or if it\u0027s good enough for now to always call SendKeyFrame?",
      "parentUuid": "c6c5909b_1f3f5107",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad5357be_004dd331",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:48:20Z",
      "side": 1,
      "message": "\u003e Not clear to me if we need it at the moment, or if it\u0027s good enough for now to always call SendKeyFrame?\n\nPeter, if you think it\u0027s ok as is, feel free to press the submit button for me.",
      "parentUuid": "02213789_4bb71cd5",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e635637c_b355c64d",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-30T16:03:42Z",
      "side": 1,
      "message": "Our downstream implementation won\u0027t repeat a keyframe if there is one in transit already.\nBut if the encoder was requesting keyframe with every frame it gets, it will cause issues -- e.g.\n1) you request a keyframe\n2) the keyframe arrives, but it gets put in the jitter buffer\n3) you request a keyframe again\n4) the keyframe request arrives to the other side, new keyframe is generated and sent\n5) you get the keyframe from the jitter buffer (2), but there is another keyframe in transit again.\n\nIn addition, our existing implementation would cancel all intra frames after the first keyframe to the second keyframe, because you explicitly requested a keyframe.\n\nEncoder should only request a keyframe once, and assume that the keyframe request gets delivered to the other side. And then the other side should guarantee the keyframe is sent.\n\nNo other keyframe requests should be requested after you request one keyframe, until you receive that keyframe.\n\n\nI am going to \u0027submit\u0027, because I think this type of logic could be done in a separate change. But please consider doing something like this sooner rather than later :)",
      "parentUuid": "ad5357be_004dd331",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "872af556_5570b117",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-31T08:55:20Z",
      "side": 1,
      "message": "\u003e Encoder should only request a keyframe once, and assume that the keyframe request gets delivered to the other side. And then the other side should guarantee the keyframe is sent.\n\u003e \n\u003e No other keyframe requests should be requested after you request one keyframe, until you receive that keyframe.\n\nThis sounds reasonable, but it will be difficult to get the needed reliable delivery with rtp/rtcp. There may also be issues with participants joining and leaving a stream.",
      "parentUuid": "e635637c_b355c64d",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "feb0c498_455e9a8a",
        "filename": "video/encoder_key_frame_callback.h",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-29T15:17:35Z",
      "side": 1,
      "message": "this will be removed once rtp media transport is implemented, right?\nCan you add a // TODO ?",
      "range": {
        "startLine": 25,
        "startChar": 39,
        "endLine": 25,
        "endChar": 61
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8a5abf6_5e6c97a1",
        "filename": "video/encoder_key_frame_callback.h",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-29T15:17:35Z",
      "side": 1,
      "message": "please document.",
      "range": {
        "startLine": 25,
        "startChar": 6,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51f8c7fa_24814a30",
        "filename": "video/encoder_key_frame_callback.h",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a8a5abf6_5e6c97a1",
      "range": {
        "startLine": 25,
        "startChar": 6,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "684bc45a_18c8c9ea",
        "filename": "video/encoder_key_frame_callback.h",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "feb0c498_455e9a8a",
      "range": {
        "startLine": 25,
        "startChar": 39,
        "endLine": 25,
        "endChar": 61
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fd50866b_4b697cdd",
        "filename": "video/video_send_stream_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 245,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-29T15:17:35Z",
      "side": 1,
      "message": "note that if we have two video streams, this won\u0027t work and DCHECK.\nShould we allow multiple listeners?",
      "range": {
        "startLine": 245,
        "startChar": 22,
        "endLine": 245,
        "endChar": 48
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b595a34_875a7017",
        "filename": "video/video_send_stream_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 245,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:34:15Z",
      "side": 1,
      "message": "My thinking is that when adding support for multiple streams, we\u0027ll have a VideoSender object here, which would ideally get this callback at construction time.",
      "parentUuid": "fd50866b_4b697cdd",
      "range": {
        "startLine": 245,
        "startChar": 22,
        "endLine": 245,
        "endChar": 48
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}