{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d0b49104_565c9117",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-22T10:54:28Z",
      "side": 1,
      "message": "Isolating ResolverResult in its own class seems like a win. We can retain backwards compatibility by letting the resolver keep a copy of the result and let that be queried, and remove that later.\n\nCurrent callers of the factory function tend to store the reference to the resolver in a table, and then look it up when the resolution completes in order to delete it. That may not be needed if we can let the lambda own the resolver (I take it that would cause destruction on lambda exit?), but old behavior can be emulated by having the lambda take a copy of resolver.get().",
      "revId": "7c2308c0ec28200662abde3d7b67fd069a489923",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3882d1f4_2a1db23b",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-03-22T10:30:39Z",
      "side": 1,
      "message": "Needs resolver\u003dstd::move(resolver), right?\n\nIf we want the ability for the user to stop the resolver before it\u0027s finished (destroying it should be enough, without any Stop() method?) I would suggest instead\n\n  std::unique_ptr\u003c...\u003e \u003d factory-\u003eCreate(name, [](AsyncDnsResolverInterface* resolver){...}\n\nOr maybe even better,\n\n  std::unique_ptr\u003c...\u003e resolver \u003d factory-\u003eResolve(name, [...](std::unique_ptr\u003cResolverAnswer\u003e answer){...]);\n\nlike a function call in continuation-passing style. Destroying the returned resolver would cancel the resolution process.\n\nAs for threading, my initial thoughts are that it\u0027s best to allow the callback on any thread, internal to the resolver machinery, and leave to the callback to, e.g., post the answer and related work to the appropriate task queue.",
      "range": {
        "startLine": 26,
        "startChar": 51,
        "endLine": 26,
        "endChar": 59
      },
      "revId": "7c2308c0ec28200662abde3d7b67fd069a489923",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92eead5b_3d61d8b3",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-22T10:54:28Z",
      "side": 1,
      "message": "Wouldn\u0027t std::move(resolver) mean that the caller loses the reference when the lambda is created?\nI was thinking either resolver.get() or pass-by-reference here, but that\u0027s not what I wrote.",
      "parentUuid": "3882d1f4_2a1db23b",
      "range": {
        "startLine": 26,
        "startChar": 51,
        "endLine": 26,
        "endChar": 59
      },
      "revId": "7c2308c0ec28200662abde3d7b67fd069a489923",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36e04d85_cc887b3d",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-03-23T10:41:18Z",
      "side": 1,
      "message": "Passing on ownership doesn\u0027t seem right. Can we design it so that there\u0027s no need to capture a resolver reference? If the callback is going to need it, it can be passed as an argument to the callback.",
      "parentUuid": "92eead5b_3d61d8b3",
      "range": {
        "startLine": 26,
        "startChar": 51,
        "endLine": 26,
        "endChar": 59
      },
      "revId": "7c2308c0ec28200662abde3d7b67fd069a489923",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03fb106f_64fc3281",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-23T11:38:01Z",
      "side": 1,
      "message": "I rewrote the example to not pass ownership; instead the example shows how one can replicate the way the old API is used (store the unique_ptr, capture a pointer, look up the pointer in the store and use that to delete).\n\nI think we might want to mention explicitly the \"elegant\" solution of making the lambda own the resolver, which gives you the option of automatic destruction, but doesn\u0027t offer a means to deal with resolvers that never complete.",
      "parentUuid": "36e04d85_cc887b3d",
      "range": {
        "startLine": 26,
        "startChar": 51,
        "endLine": 26,
        "endChar": 59
      },
      "revId": "7c2308c0ec28200662abde3d7b67fd069a489923",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "317c9c86_c1de89ee",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-03-23T11:47:38Z",
      "side": 1,
      "message": "\u003e I think we might want to mention explicitly the \"elegant\" solution of making the lambda own the resolver, which gives you the option of automatic destruction.\n\nWon\u0027t work with std::function for the callback, though.",
      "parentUuid": "03fb106f_64fc3281",
      "range": {
        "startLine": 26,
        "startChar": 51,
        "endLine": 26,
        "endChar": 59
      },
      "revId": "7c2308c0ec28200662abde3d7b67fd069a489923",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8584b023_2a61f85c",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-23T12:50:08Z",
      "side": 1,
      "message": "Hm. Can a std::function always be move()d? At the moment my code copies it..... probably shouldn\u0027t.\n\nCapturing a std::unique_ptr makes the lambda move-only, I think. So the current code won\u0027t admit to that anyway.",
      "parentUuid": "317c9c86_c1de89ee",
      "range": {
        "startLine": 26,
        "startChar": 51,
        "endLine": 26,
        "endChar": 59
      },
      "revId": "7c2308c0ec28200662abde3d7b67fd069a489923",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}