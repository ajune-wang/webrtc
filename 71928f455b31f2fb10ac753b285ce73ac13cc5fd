{
  "comments": [
    {
      "key": {
        "uuid": "42ec8c42_f4eb0e15",
        "filename": "api/video/hdr_metadata.h",
        "patchSetId": 4
      },
      "lineNbr": 73,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-10T15:19:47Z",
      "side": 1,
      "message": "Why not plain int?",
      "range": {
        "startLine": 73,
        "startChar": 2,
        "endLine": 73,
        "endChar": 10
      },
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b197e5a_8ee4d119",
        "filename": "api/video/hdr_metadata.h",
        "patchSetId": 4
      },
      "lineNbr": 73,
      "author": {
        "id": 7641
      },
      "writtenOn": "2018-12-10T21:12:53Z",
      "side": 1,
      "message": "The reason was to force the data to be within what\u0027s acceptable to transmit in the RTP header extension, but I guess it\u0027s better to use a plain int as you suggest and add a check before transmitting.",
      "parentUuid": "42ec8c42_f4eb0e15",
      "range": {
        "startLine": 73,
        "startChar": 2,
        "endLine": 73,
        "endChar": 10
      },
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8a1aeea3_f97b4b2d",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 576,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-10T15:19:47Z",
      "side": 1,
      "message": "I don\u0027t think \"join\" is the right verb. Maybe format, combine, make...byte?\n\nIt would also be good with a comment with the bit layout (upper two bits always zero?).",
      "range": {
        "startLine": 576,
        "startChar": 29,
        "endLine": 576,
        "endChar": 53
      },
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed7af707_b3b91f5f",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 576,
      "author": {
        "id": 7641
      },
      "writtenOn": "2018-12-10T21:12:53Z",
      "side": 1,
      "message": "I have changed to Combine, I was choosing between join and combine.",
      "parentUuid": "8a1aeea3_f97b4b2d",
      "range": {
        "startLine": 576,
        "startChar": 29,
        "endLine": 576,
        "endChar": 53
      },
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "28ccb3d5_60cc791b",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 583,
      "author": {
        "id": 5019
      },
      "writtenOn": "2018-12-10T15:05:46Z",
      "side": 1,
      "message": "personally prefer to join different bits with operator \u0027|\u0027 rather than +",
      "range": {
        "startLine": 583,
        "startChar": 44,
        "endLine": 583,
        "endChar": 45
      },
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "965169b0_9861e2b4",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 583,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-10T15:19:47Z",
      "side": 1,
      "message": "Me too. (Using + might make it easier on x86 to make use of the lea instruction, but that type of optimization doesn\u0027t seem relevant here).",
      "parentUuid": "28ccb3d5_60cc791b",
      "range": {
        "startLine": 583,
        "startChar": 44,
        "endLine": 583,
        "endChar": 45
      },
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "40f8d6cc_c6f7ff9d",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 583,
      "author": {
        "id": 7641
      },
      "writtenOn": "2018-12-10T21:12:53Z",
      "side": 1,
      "message": "I prefer that as well, I had that on my list of things to change but forgot about it.\nFixed now!",
      "parentUuid": "965169b0_9861e2b4",
      "range": {
        "startLine": 583,
        "startChar": 44,
        "endLine": 583,
        "endChar": 45
      },
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ffa00f0e_9b883f43",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 596,
      "author": {
        "id": 5019
      },
      "writtenOn": "2018-12-10T15:05:46Z",
      "side": 1,
      "message": "do not (D)CHECK data coming from network.\nIf I read code correctly, incoming packet may be structured so that p-\u003ex \u003e 1.0\nIn that case I guess you should fail the parse rather than return incorrect values or crash the program.",
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8942620_3c8d1bf0",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 596,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-10T15:19:47Z",
      "side": 1,
      "message": "And preferably check the int values before operating on them. I.e.,\n\nif (chromaticity_x_scaled \u003e kChromaticityDenominator) { ... fail ... }\n\n(assuming equality, and ratio 1.0, is valid).",
      "parentUuid": "ffa00f0e_9b883f43",
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed13da5c_7c3b9712",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 596,
      "author": {
        "id": 7641
      },
      "writtenOn": "2018-12-10T21:12:53Z",
      "side": 1,
      "message": "Yes, of course. Adding that check was not well thought out\nWhat do you think about having a SanityCheck function after the data has been decoded? I see the point of checking before operating on the values, but I think the design will be more clear if the sanity check does not have to care about how the data is encoded in the bitstream.",
      "parentUuid": "b8942620_3c8d1bf0",
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3c41e8d6_d00995f1",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 596,
      "author": {
        "id": 5019
      },
      "writtenOn": "2018-12-11T12:04:41Z",
      "side": 1,
      "message": "yes, it looks reasonable to add check after data is decoded,\nbut still it has to be run-time check with fail plan, not a DCHECK.",
      "parentUuid": "ed13da5c_7c3b9712",
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eef54583_fd46de25",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 596,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-11T12:10:25Z",
      "side": 1,
      "message": "I think I\u0027d prefer to have validation of the parsed data close to the wire format.\n\nIf relevant, you could have additional checks or dchecks where the numbers are used (with the intention that failures should catch implementation errors, not a peer sending evil data).",
      "parentUuid": "ed13da5c_7c3b9712",
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "869ce375_635a4e27",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 596,
      "author": {
        "id": 7641
      },
      "writtenOn": "2018-12-11T12:29:19Z",
      "side": 1,
      "message": "I have done the following now:\n1. Added a Validate() function to the HdrMetadata struct. I think that\u0027s where the knowledge of valid values should be.\n2. The assumption is then that the RTP header extension is designed to handle all valid HdrMetadata structs.\n3. Parse() will return false if hdr_metadata.Validate() \u003d\u003d false.\n4. Write() will fail in debug if hdr_metadata.Validate() \u003d\u003d false.\n\nWhat do you think about that?",
      "parentUuid": "eef54583_fd46de25",
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b869779b_cbe4ace4",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 596,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-11T13:15:04Z",
      "side": 1,
      "message": "I guess you have to take consistency with the other code in this file into account. But I\u0027d prefer to have all parser functions return failure on invalid data, and exit early. Something like\n\nColorSpaceExtension::Parse(rtc::ArrayView\u003c...\u003e data, ColorSpace* color_space) {\n  ByteBufferReader buffer(data);\n  return ParseFoo(buffer, \u0026color_space-\u003efoo) \u0026\u0026\n         ParseChromaticity(buffer, \u0026color_space-\u003e...));\n}\n\nI.e., never store invalid data into any instance of HdrMetadata or ColorSpace. And avoid explicit |offset| updates and size checks.\n\nBut if no other parsers in this file follow that convention, this is likely not the right cl to introduce that.\n\nIndependent of that: It might make sense with a helper method or function for parsing HdrMetadata.",
      "parentUuid": "869ce375_635a4e27",
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edbf75b1_300af9e5",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 596,
      "author": {
        "id": 7641
      },
      "writtenOn": "2018-12-11T14:08:51Z",
      "side": 1,
      "message": "I didn\u0027t know about the ByteBufferReader. Will refactor to use that one. Since this extension uses more data than the other extensions I think it make sense to use it here.\nI see your point regarding invalid data. At least HdrMetadata will never be assigned to ColorSpace in the case it\u0027s valid. While doing the refactor I will see if I can also do the validation even earlier.",
      "parentUuid": "b869779b_cbe4ace4",
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "da0d8eea_103e576c",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 596,
      "author": {
        "id": 7641
      },
      "writtenOn": "2018-12-11T14:42:50Z",
      "side": 1,
      "message": "I did an attempt to use ByteBufferReader but I would prefer to keep the current implementation. There were a couple of things that made the code less clear using ByteBufferReader:\n* reinterpret_cast\u003cconst char*\u003e needed when constructing buffer.\n* Temporary objects needed at some places when reading, uint8_t value; buffer.GetUint8(\u0026value); ...set(value).\n* Extra checks of size even though we know what the size is. For each read there would be a if(!buffer.Get...) return false;\n\nSo unless someone complains, I\u0027ll keep the current implementation. I have refactored so that HdrMetadata is parsed/written in a separate function.",
      "parentUuid": "edbf75b1_300af9e5",
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9957a21d_6eb3f7d9",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 596,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-11T14:56:02Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "da0d8eea_103e576c",
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0ab08d9f_0f05dc42",
        "filename": "modules/rtp_rtcp/source/rtp_header_extensions.cc",
        "patchSetId": 4
      },
      "lineNbr": 614,
      "author": {
        "id": 5019
      },
      "writtenOn": "2018-12-10T15:05:46Z",
      "side": 1,
      "message": "DCHECKing data coming from the application is usually ok",
      "range": {
        "startLine": 613,
        "startChar": 27,
        "endLine": 614,
        "endChar": 0
      },
      "revId": "71928f455b31f2fb10ac753b285ce73ac13cc5fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}