{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6b1597d8_258c2b51",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-06-11T14:54:29Z",
      "side": 1,
      "message": "I haven\u0027t taken out the debug statements yet, but it\u0027s worth taking a look at the core change; it\u0027s in pc/jsep_transport_controller.cc.\n",
      "revId": "dc9dfee7a4455b582ae388ef29d97901fbc35c3d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f3af224_9162c088",
        "filename": "pc/jsep_transport_controller.cc",
        "patchSetId": 5
      },
      "lineNbr": 1033,
      "author": {
        "id": 5053
      },
      "writtenOn": "2021-06-11T22:50:02Z",
      "side": 1,
      "message": "I\u0027m not sure this is the right place for this logic; it assumes the transport will be added to the group (and specifically the first group), which may not be true of a remote offer from a non-JSEP endpoint. And it leaves things in a temporarily conflicting state where a MID is sharing a transport despite not being included in a group under the BundleManager.\n\nI\u0027d suggest modifying ShouldUpdateBundleGroup/BundleManager::Update such that bundle group(s) will be updated at offer time if they\u0027re pre-existing. Then things will fall out naturally and MaybeCreateJsepTransport won\u0027t even be called in the first place.\n\nAlso, question for hbos: I know we validate that the answer contains valid bundle groups relative to the offer, but do we validate whether a subsequent offer contains valid groups relative to the last answer? Like going from ((1,2),(3,4)) to ((1,3),(2,4))?",
      "revId": "dc9dfee7a4455b582ae388ef29d97901fbc35c3d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e20c0cff_95cddd1b",
        "filename": "pc/jsep_transport_controller.cc",
        "patchSetId": 5
      },
      "lineNbr": 1033,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-06-14T11:12:44Z",
      "side": 1,
      "message": "Discussed by email; JSEP \u0026 BUNDLE pretty clearly say that new transports shouldn\u0027t be created.",
      "parentUuid": "8f3af224_9162c088",
      "revId": "dc9dfee7a4455b582ae388ef29d97901fbc35c3d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2652b90f_794ad342",
        "filename": "pc/jsep_transport_controller.cc",
        "patchSetId": 5
      },
      "lineNbr": 1033,
      "author": {
        "id": 5053
      },
      "writtenOn": "2021-06-15T00:24:39Z",
      "side": 1,
      "message": "JSEP is clear on what the JSEP-compliant endpoint does. But if the policy is \"max-compat\" (we don\u0027t implement \"balanced\" yet), it\u0027s entirely possible for a non-JSEP endpoint to add a new m\u003d section that\u0027s not part of a BUNDLE group, which would not meet the criteria for rejection described in 5.3.1.\n\nBut regardless of which of our interpretations is correct, I still think this logic would be more appropriate in ShouldUpdateBundleGroup/BundleManager::Update. This code is currently making assumptions about BUNDLE group restrictions that are not actually enforced elsewhere; if the logic in BundleManager::Update were simply \"update all BUNDLE groups if this is an answer or policy is max-bundle, and update pre-existing BUNDLE groups if this is an offer\", it wouldn\u0027t need to make any assumptions.",
      "parentUuid": "e20c0cff_95cddd1b",
      "revId": "dc9dfee7a4455b582ae388ef29d97901fbc35c3d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e242d48_a467b033",
        "filename": "pc/jsep_transport_controller.cc",
        "patchSetId": 5
      },
      "lineNbr": 1033,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-06-15T05:47:38Z",
      "side": 1,
      "message": "Yes, but that\u0027s the remote end\u0027s business, and has to come in an incoming offer.\nWe don\u0027t add m-sections through this logic with incoming offers.\n\nI do agree that this code is not the most elegant way to do it. A much more elegant way would be to nuke every variable that keeps track of bundles and MIDs in this code and move all that logic to BundleManager.\n\nI\u0027m thinking that I should do that in a follow-up CL. But now I have managed to fix the base case I was hunting for, and want to submit that. Refactoring comes afterwards.",
      "parentUuid": "2652b90f_794ad342",
      "revId": "dc9dfee7a4455b582ae388ef29d97901fbc35c3d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cbf0d418_b9296a4c",
        "filename": "pc/jsep_transport_controller.cc",
        "patchSetId": 5
      },
      "lineNbr": 1033,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-06-15T09:33:55Z",
      "side": 1,
      "message": "I\u0027m OK with refactoring later.\n\n\u003e Also, question for hbos: I know we validate that the answer contains valid bundle groups relative to the offer, but do we validate whether a subsequent offer contains valid groups relative to the last answer? Like going from ((1,2),(3,4)) to ((1,3),(2,4))?\n\nMost of the verification logic is here:\nhttps://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/pc/jsep_transport_controller.cc;l\u003d723;drc\u003de1142208ee20f9c35b3da51008d0991b0e10fa14;bpv\u003d0;bpt\u003d1\n\nMostly logic about being consistent with itself and answer being consistent with offer, not sure about making sure follow-up offers are consistent with stable state.\n\nIn fact in my demo page (https://jsfiddle.net/henbos/to89L6ce/59/) I think the offer generated still assumes one BUNDLE group and munging is required to make it consistent with the past stable state...\n\nMultiple BUNDLE groups + renegotiation has not been very well tested.",
      "parentUuid": "8e242d48_a467b033",
      "revId": "dc9dfee7a4455b582ae388ef29d97901fbc35c3d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "06cd85ee_55d05385",
        "filename": "pc/jsep_transport_controller.cc",
        "patchSetId": 5
      },
      "lineNbr": 1033,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-06-15T09:40:32Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "cbf0d418_b9296a4c",
      "revId": "dc9dfee7a4455b582ae388ef29d97901fbc35c3d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a836f80_0b000785",
        "filename": "pc/jsep_transport_controller.cc",
        "patchSetId": 5
      },
      "lineNbr": 1033,
      "author": {
        "id": 5053
      },
      "writtenOn": "2021-06-15T22:03:22Z",
      "side": 1,
      "message": "\u003e We don\u0027t add m-sections through this logic with incoming offers.\n\nWe do, that\u0027s why I\u0027m concerned. This is silently breaking cases that previously worked.",
      "parentUuid": "06cd85ee_55d05385",
      "revId": "dc9dfee7a4455b582ae388ef29d97901fbc35c3d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ce7c46b_e8867b33",
        "filename": "pc/jsep_transport_controller.cc",
        "patchSetId": 5
      },
      "lineNbr": 1033,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-06-21T05:44:59Z",
      "side": 1,
      "message": "Can you provide a test that does? I\u0027d like to verify that.\n\n(The logic is still more convoluted than I like. The groups from the proposed offer should in all cases be the same as what we get by deleting rejected sections and adding new sections to the currently standing grouping, so we just shouldn\u0027t have to do that. But this CL fixed the important bug case.)",
      "parentUuid": "5a836f80_0b000785",
      "revId": "dc9dfee7a4455b582ae388ef29d97901fbc35c3d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7a36419_bbbd339e",
        "filename": "pc/jsep_transport_controller.cc",
        "patchSetId": 5
      },
      "lineNbr": 1033,
      "author": {
        "id": 5053
      },
      "writtenOn": "2021-06-21T20:35:23Z",
      "side": 1,
      "message": "\u003e The groups from the proposed offer should in all cases be the same as what we get by deleting rejected sections and adding new sections to the currently standing grouping\n\nIn a proposed offer *from a JSEP-compliant endpoint*, yes. But I\u0027m talking about a non-JSEP endpoint, which doesn\u0027t even need to support BUNDLE, and if it does, is not required to bundle everything.\n\nIt\u0027s difficult to provide a test, since after this change, both the offerer and answerer will behave in the same way. But I did reproduce the problem by making a call between M91 and Chrome Canary, where M91 is re-offering, adding a video m\u003d section not in the BUNDLE group (allowed via SDP munging). M91 keeps waiting for candidates that never come.\n\nOf course, ideally I\u0027d be testing between a non-WebRTC endpoint, but Chrome + SDP munging is usually good enough to simulate one.",
      "parentUuid": "4ce7c46b_e8867b33",
      "revId": "dc9dfee7a4455b582ae388ef29d97901fbc35c3d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}