{
  "comments": [
    {
      "key": {
        "uuid": "bbbb6ebb_e8abc072",
        "filename": "api/array_view.h",
        "patchSetId": 2
      },
      "lineNbr": 275,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-03-20T04:37:42Z",
      "side": 1,
      "message": "Why this restriction? And don\u0027t you need to check that the types have the same alignment requirements too (or rather, that T\u0027s requirements are at least as strict as U\u0027s)?",
      "revId": "8da6306c041f39c7972b127a0d9ff449d77115fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6ad12fc2_dd355c5a",
        "filename": "api/array_view.h",
        "patchSetId": 2
      },
      "lineNbr": 275,
      "author": {
        "id": 8244
      },
      "writtenOn": "2019-03-20T17:06:15Z",
      "side": 1,
      "message": "The restriction is to protect against misuse. it makes sense for data buffers etc. to reinterpret cast them, but for \u0027complex\u0027 objects, it doesn\u0027t really make sense.\nIf users want to do that, they can reinterpret cast the pointers themselves and be very explicit about it.\ni do not follow about alignment requirements, please elaborate more. i understand this class to be a wrapper for c-style buffers with pointer to data and length. i see no notion of alignment, only that of indexing and pointer arithmetic. ex: view[i] \u003d\u003d\u003d *(pointer + i).",
      "parentUuid": "bbbb6ebb_e8abc072",
      "revId": "8da6306c041f39c7972b127a0d9ff449d77115fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "871f4873_a3ff67f9",
        "filename": "api/array_view.h",
        "patchSetId": 2
      },
      "lineNbr": 275,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-03-21T10:45:24Z",
      "side": 1,
      "message": "Different types have different alignment. For example, alignof(char) is 1 and alignof(int) is usually 4. Structs are aligned as their most demanding member, so a struct with four chars is going to have alignment 1. For that reason, if you allow struct types, you need to somehow prevent the user from casting an ArrayView of such structs to an ArrayView of ints.\n\nIf the standard guarantees that fundamental types of the same size also have the same alignment, checking the alignment manually here is superfluous if you only allow fundamental types. But if you can\u0027t point to such a guarantee, or don\u0027t expect readers of this code to be able to find it, it\u0027s probably better to just static_assert that alignof(U) \u003c\u003d alignof(T). (The less-than check is sufficient; we don\u0027t have to also check divisibility, since alignment is always a power of two.)",
      "parentUuid": "6ad12fc2_dd355c5a",
      "revId": "8da6306c041f39c7972b127a0d9ff449d77115fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bbf433d4_da254608",
        "filename": "api/array_view.h",
        "patchSetId": 2
      },
      "lineNbr": 275,
      "author": {
        "id": 8244
      },
      "writtenOn": "2019-03-21T17:16:26Z",
      "side": 1,
      "message": "thanks for clarifying.\ni found this relevant answer: https://stackoverflow.com/a/38916812\nit suggests that for fundamental types sizeof(T) \u003d\u003d alignof(T) in most implementations but it is not a guarantee of the standard.\nI am still not convinced of the need to check alignment, as it\u0027s not normally checked in reinterpret cast, but I see nothing wrong with adding another static assert for this. better safe than sorry.\nregarding the required condition -\nthe purpose of the static asserts in the reinterpret cast is to make sure that you are \u0027casting\u0027 to a memory chunk of the same size.\ni understand ArrayView::size() to be the number of elements because ArrayView::operator[](idx) DCHECKS(idx \u003c size()).\nIf i were to look at the array view as a chunk of memory, then the size of the buffer (in bytes) is how many bytes would be incremented by: data() + size().\ni will enforce that the aligment is the same in both types.",
      "parentUuid": "871f4873_a3ff67f9",
      "revId": "8da6306c041f39c7972b127a0d9ff449d77115fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "30173be6_adb36604",
        "filename": "api/array_view.h",
        "patchSetId": 2
      },
      "lineNbr": 277,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-03-20T04:37:42Z",
      "side": 1,
      "message": "Adding a method that std::span doesn\u0027t have is going to make it more difficult to retire ArrayView in favor of std::span when the time comes. But I can see how this one could be handy---so can you make a free function instead?",
      "revId": "8da6306c041f39c7972b127a0d9ff449d77115fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5c335d07_bad64b80",
        "filename": "api/array_view.h",
        "patchSetId": 2
      },
      "lineNbr": 277,
      "author": {
        "id": 8244
      },
      "writtenOn": "2019-03-20T17:06:15Z",
      "side": 1,
      "message": "i will try a free function. hopefully users don\u0027t need to specify all template parameters.\ni would like to get this usage \nauto buffer_of_char \u003d reinterpret\u003cchar\u003e(buffer_of_uchar)\nand not\nauto buffer_of_char \u003d reinterpret\u003cuchar, size, char\u003e(buffer_of_uchar)",
      "parentUuid": "30173be6_adb36604",
      "revId": "8da6306c041f39c7972b127a0d9ff449d77115fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7d932594_91cc0845",
        "filename": "api/array_view.h",
        "patchSetId": 2
      },
      "lineNbr": 277,
      "author": {
        "id": 8244
      },
      "writtenOn": "2019-03-20T17:06:50Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5c335d07_bad64b80",
      "revId": "8da6306c041f39c7972b127a0d9ff449d77115fd",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}