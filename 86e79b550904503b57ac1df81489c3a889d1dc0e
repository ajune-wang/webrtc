{
  "comments": [
    {
      "key": {
        "uuid": "6ac010a7_cb630e7d",
        "filename": "system_wrappers/source/metrics.cc",
        "patchSetId": 4
      },
      "lineNbr": 193,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-05-29T11:08:31Z",
      "side": 1,
      "message": "It would be nice to replace this logic with\n\nRtcHistogramMap* GetMap()\n{\n  static RtcHistogramMap* const map \u003d new RtcHistogramMap();\n  return map;\n}\n\nand rely on C++ (was it C++11?) to make this thread safe for us. Not sure what changes that implies for what this cl tries to do. I agree we shouldn\u0027t have DCHECKs for conditions that the release code attempts to handle.",
      "range": {
        "startLine": 189,
        "startChar": 0,
        "endLine": 193,
        "endChar": 18
      },
      "revId": "86e79b550904503b57ac1df81489c3a889d1dc0e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6cd38188_ef8921d0",
        "filename": "system_wrappers/source/metrics.cc",
        "patchSetId": 4
      },
      "lineNbr": 193,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-05-29T14:01:03Z",
      "side": 1,
      "message": "Is this something that should be done as part of this CL?\n\nNote also that to fully replicate the ability to log that there is repeated calling of the Enable() method we\u0027d need to do something along.\n\nRtcHistogramMap* GetMap()\n{\n  static RtcHistogramMap* const map \u003d new RtcHistogramMap();\n\n#if RTC_DCHECK_IS_ON\n  if (rtc::AtomicOps::AcquireLoad(\u0026g_rtc_histogram_called) !\u003d 0) {\n    RTC_LOG(LS_ERROR)\n        \u003c\u003c \"Histogram data was reported before metrics were enabled.\";\n  }\n#endif\n\n  return map;\n}\n\nvoid Enable() \n{\n  static bool called_before \u003d false;\n  if (called_before) {\n    RTC_LOG(LS_ERROR) \u003c\u003c \"Enabling histograms more than once.\"; \n  }\n  called_before \u003d true;\n  GetMap();\n}\n\n\nFrom what I can see, the construct in the Enable() call is not thread-safe, but that is maybe fine.",
      "parentUuid": "6ac010a7_cb630e7d",
      "range": {
        "startLine": 189,
        "startChar": 0,
        "endLine": 193,
        "endChar": 18
      },
      "revId": "86e79b550904503b57ac1df81489c3a889d1dc0e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a4f45b85_2a3b05ea",
        "filename": "system_wrappers/source/metrics.cc",
        "patchSetId": 4
      },
      "lineNbr": 193,
      "author": {
        "id": 5126
      },
      "writtenOn": "2020-05-30T14:34:24Z",
      "side": 1,
      "message": "I agree with Nisse; that way is much less error-prone. But perhaps in another CL.\n\nIf you for some reason need to check whether some code is executed more than once, you could do e.g.\n\n  ABSL_CONST_INIT static std::atomic\u003cbool\u003e been_here{false};\n  bool been_here_already \u003d std::atomic_exchange_explicit(\n      \u0026been_here, true, std::memory_order::relaxed);\n  if (been_here_already) {\n    LOG \u003c\u003c \"Called more than once!\";\n  }",
      "parentUuid": "6cd38188_ef8921d0",
      "range": {
        "startLine": 189,
        "startChar": 0,
        "endLine": 193,
        "endChar": 18
      },
      "revId": "86e79b550904503b57ac1df81489c3a889d1dc0e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24f9fe5d_1f462a77",
        "filename": "system_wrappers/source/metrics.cc",
        "patchSetId": 4
      },
      "lineNbr": 193,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-06-01T07:10:25Z",
      "side": 1,
      "message": "I don\u0027t have the full context, but I\u0027d suggest to simplify using a C++ static initializer in a separate cl, first, and then reevaluate if this change is still needed, and if so, what\u0027s the best way to do it.",
      "parentUuid": "a4f45b85_2a3b05ea",
      "range": {
        "startLine": 189,
        "startChar": 0,
        "endLine": 193,
        "endChar": 18
      },
      "revId": "86e79b550904503b57ac1df81489c3a889d1dc0e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "728a85c2_3a3363d1",
        "filename": "system_wrappers/source/metrics.cc",
        "patchSetId": 4
      },
      "lineNbr": 193,
      "author": {
        "id": 5126
      },
      "writtenOn": "2020-06-01T10:48:11Z",
      "side": 1,
      "message": "SGTM",
      "parentUuid": "24f9fe5d_1f462a77",
      "range": {
        "startLine": 189,
        "startChar": 0,
        "endLine": 193,
        "endChar": 18
      },
      "revId": "86e79b550904503b57ac1df81489c3a889d1dc0e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43631bd8_bfdd7dac",
        "filename": "system_wrappers/source/metrics.cc",
        "patchSetId": 4
      },
      "lineNbr": 203,
      "author": {
        "id": 5126
      },
      "writtenOn": "2020-05-30T14:34:24Z",
      "side": 1,
      "message": "Why do you care if this function is called more than once? It\u0027s specifically written to handle that.",
      "revId": "86e79b550904503b57ac1df81489c3a889d1dc0e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d78e5314_26b237db",
        "filename": "system_wrappers/source/metrics.cc",
        "patchSetId": 4
      },
      "lineNbr": 293,
      "author": {
        "id": 5126
      },
      "writtenOn": "2020-05-30T14:34:24Z",
      "side": 1,
      "message": "Should this #if still be here? This code doesn\u0027t appear to still have anything to do with DCHECK.",
      "revId": "86e79b550904503b57ac1df81489c3a889d1dc0e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}