{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "f9cc9de0_f1f0fbbe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-05-02T09:29:04Z",
      "side": 1,
      "message": "This wasn\u0027t as easy as I thought: There\u0027s a subtle difference in when observer is called between new and old signatures, and a couple of tests fail. Advice needed.",
      "revId": "e79fb389ec52e19dca3db3200602b548540347e7",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "012403bd_a5dbca2c",
        "filename": "pc/test/integration_test_helpers.h",
        "patchSetId": 5
      },
      "lineNbr": 926,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-05-02T09:29:04Z",
      "side": 1,
      "message": "It sounds like this depends on the deprecated behavior implemented by SdpOfferAnswerHandler::SetSessionDescriptionObserverAdapter (see https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/pc/sdp_offer_answer.cc;drc\u003d3af79d17686a37341fa93570f8d32c7ffad644f1;l\u003d1099) which avoids calling the observer immediately (instead posting a message to do it after control returns to the message handler loop).\n\nExact timing is a bit unclear to me (I think we also have a proxy in between, so all that happens on a different thread). Anyway, by changing to the other SetLocalDescription signature (and similarly below for SetRemoteDescription), that delay no longer happens, and a couple of tests break.",
      "range": {
        "startLine": 922,
        "startChar": 0,
        "endLine": 926,
        "endChar": 35
      },
      "revId": "e79fb389ec52e19dca3db3200602b548540347e7",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "113b05a5_9140d429",
        "filename": "pc/test/integration_test_helpers.h",
        "patchSetId": 5
      },
      "lineNbr": 926,
      "author": {
        "id": 5142
      },
      "writtenOn": "2022-05-02T14:51:32Z",
      "side": 1,
      "message": "Some methods run on the Operations Chain (https://w3c.github.io/webrtc-pc/#dfn-operations-chain), including CreateOffer, CreateAnswer, SetLocalDescription and SetRemoteDescription. The operation chain is basically just a queue of operations that ensures if you call an operation while a previous operation is still pending, the second operation is queued to be executed as soon as the pending operation has completed.\n\nThe non-deprecated versions of SLD/SRD invoke the callback as early as possible which is necessary to ensure the state of the peer connection accurately reflects the state that caused the callback to fire. However by the time this callback fires, the operation chain has not yet marked the current SLD/SRD operation as \"completed\". A consequence of this is that if the callback triggers another operation to run it, it will be queued onto the Operations Chain rather than be executed immediately. This prevents SLD/SRD operations from being executed recursively, which is probably a good thing.\n\nThen deprecated versions of SLD/SRD prevent recursion in another way: by delaying the invocation of the callback with a Post. This is good if you want to call SLD/SRD again inside of the callback and have that be executed immediately (because the operations chain will no longer be blocked)... but this is bad if you want to inspect the peer connection\u0027s state and have the state reflect why the event fired. The delay means by the time the callback happens, other API calls could have changed the peer connection\u0027s state in-betweeen the Post and the invocation.\n\nThere was a downstream usage that incorrectly assumed that SLD/SRD operations, which are supposed to be asynchronous, were in fact synchronous. This use case broke when I tried to change it from the old SLD/SRD versions to the new SLD/SRD versions, because that use cases assumed that if SLD/SRD was called inside of the callback then the SLD/SRD would instantly be completed. True with the old API, false with the new API.",
      "parentUuid": "012403bd_a5dbca2c",
      "range": {
        "startLine": 922,
        "startChar": 0,
        "endLine": 926,
        "endChar": 35
      },
      "revId": "e79fb389ec52e19dca3db3200602b548540347e7",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1464f831_010eaa31",
        "filename": "pc/test/integration_test_helpers.h",
        "patchSetId": 5
      },
      "lineNbr": 926,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-05-02T15:05:03Z",
      "side": 1,
      "message": "Thanks for the explanation. Do you have any suggestion on how to fix the tests?\n\nI don\u0027t quite understand the how it breaks (and I may be off track, it\u0027s just that the observer timing is the only change in behavior I\u0027ve spotted). The FakeSetLocalDescriptionObserver\u0027s callback just stores the result in it\u0027s `error_` member, with no recursive peerconnection calls. And not used until the EXPECT_TRUE_WAIT below. So not at all clear to me why exact timing of the observer call would matter.",
      "parentUuid": "113b05a5_9140d429",
      "range": {
        "startLine": 922,
        "startChar": 0,
        "endLine": 926,
        "endChar": 35
      },
      "revId": "e79fb389ec52e19dca3db3200602b548540347e7",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e74feaee_c89fd8f7",
        "filename": "pc/test/integration_test_helpers.h",
        "patchSetId": 5
      },
      "lineNbr": 926,
      "author": {
        "id": 5142
      },
      "writtenOn": "2022-05-02T15:43:57Z",
      "side": 1,
      "message": "Could there be a difference with the timing of ICE candidates?\n\nICE candidates would cause OnIceCandidate() to fire, which might get added to the other peer connection with AddIceCandidate().\n\nThe old versus new API might change how time you have until you proceed to the next negotiation step? Maybe that would be the difference between creating an answer before or after ICE candidates had been added?\n\nWhat\u0027s an example of a failing test and how does it fail?",
      "parentUuid": "1464f831_010eaa31",
      "range": {
        "startLine": 922,
        "startChar": 0,
        "endLine": 926,
        "endChar": 35
      },
      "revId": "e79fb389ec52e19dca3db3200602b548540347e7",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}