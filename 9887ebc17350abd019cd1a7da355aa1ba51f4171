{
  "comments": [
    {
      "key": {
        "uuid": "ff4e7436_5fc7777f",
        "filename": "rtc_base/critical_section.cc",
        "patchSetId": 1
      },
      "lineNbr": 225,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-11-15T16:39:58Z",
      "side": 1,
      "message": "I think memory_order things always need a comment motivating the choice. Here and below.",
      "range": {
        "startLine": 223,
        "startChar": 0,
        "endLine": 225,
        "endChar": 79
      },
      "revId": "9887ebc17350abd019cd1a7da355aa1ba51f4171",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b936f7a_455ac5bf",
        "filename": "rtc_base/critical_section.cc",
        "patchSetId": 1
      },
      "lineNbr": 225,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-11-18T09:50:28Z",
      "side": 1,
      "message": "added few relaxed comments.\n\nand after exploring api a bit more, found other (simpler) ways to implement spin lock.\n(also tried std::atomic_flag, but that one I didn\u0027t found how to initialize as member (patchset#2))\n\nSo I\u0027m not longer sure what is appropriate way to replace AtomicOps here. Will leave this CL as is for now until get more confidence this works, or until there is more activity on the \"removing atomicops\" bug.",
      "parentUuid": "ff4e7436_5fc7777f",
      "range": {
        "startLine": 223,
        "startChar": 0,
        "endLine": 225,
        "endChar": 79
      },
      "revId": "9887ebc17350abd019cd1a7da355aa1ba51f4171",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9c810a05_ed23ac5d",
        "filename": "rtc_base/critical_section.cc",
        "patchSetId": 1
      },
      "lineNbr": 235,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-11-15T16:39:58Z",
      "side": 1,
      "message": "Would be good to encapsulate the system-dependent things in an rtc::yield. I think I\u0027ve seen similar code in other places in webrtc.",
      "range": {
        "startLine": 228,
        "startChar": 0,
        "endLine": 235,
        "endChar": 6
      },
      "revId": "9887ebc17350abd019cd1a7da355aa1ba51f4171",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c27a41ca_d6ef5bcf",
        "filename": "rtc_base/critical_section.cc",
        "patchSetId": 1
      },
      "lineNbr": 235,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-11-18T09:50:28Z",
      "side": 1,
      "message": "Can you explain why yield is good? is it relevant to the atomic migration?\n\n(though moving the struct from above to below is unrelated too... prefer me to undon that?)",
      "parentUuid": "9c810a05_ed23ac5d",
      "range": {
        "startLine": 228,
        "startChar": 0,
        "endLine": 235,
        "endChar": 6
      },
      "revId": "9887ebc17350abd019cd1a7da355aa1ba51f4171",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "999ecb74_246dd58b",
        "filename": "rtc_base/critical_section.cc",
        "patchSetId": 1
      },
      "lineNbr": 235,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-11-18T11:32:44Z",
      "side": 1,
      "message": "Just want to avoid duplicating the logic to select the appropriate system call to yield current thread. Or is this now the only place we do that?\n\nMoving the struct is fine.",
      "parentUuid": "c27a41ca_d6ef5bcf",
      "range": {
        "startLine": 228,
        "startChar": 0,
        "endLine": 235,
        "endChar": 6
      },
      "revId": "9887ebc17350abd019cd1a7da355aa1ba51f4171",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "83d2c1be_4d3cd4a3",
        "filename": "rtc_base/critical_section.cc",
        "patchSetId": 1
      },
      "lineNbr": 242,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-11-15T16:39:58Z",
      "side": 1,
      "message": "And here too.",
      "range": {
        "startLine": 242,
        "startChar": 50,
        "endLine": 242,
        "endChar": 75
      },
      "revId": "9887ebc17350abd019cd1a7da355aa1ba51f4171",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "23c74ed2_066690b5",
        "filename": "rtc_base/critical_section.cc",
        "patchSetId": 1
      },
      "lineNbr": 242,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-11-18T09:50:28Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "83d2c1be_4d3cd4a3",
      "range": {
        "startLine": 242,
        "startChar": 50,
        "endLine": 242,
        "endChar": 75
      },
      "revId": "9887ebc17350abd019cd1a7da355aa1ba51f4171",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ffd6202b_64d7e169",
        "filename": "rtc_base/critical_section.h",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-11-15T16:39:58Z",
      "side": 1,
      "message": "This comment isn\u0027t that clear. In what way is it different from a CriticalSection? Why can\u0027t we use CriticalSection for everything, including synchronizaton of global resources?",
      "range": {
        "startLine": 100,
        "startChar": 0,
        "endLine": 101,
        "endChar": 31
      },
      "revId": "9887ebc17350abd019cd1a7da355aa1ba51f4171",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cda83956_4f419a39",
        "filename": "rtc_base/critical_section.h",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-11-18T09:50:28Z",
      "side": 1,
      "message": "(unrelated to this CL):\nglobal objects need lock with static storage duration to protect them.\nobjects with static storage duration has to have constant initialization and trivial destructor.\nhttps://google.github.io/styleguide/cppguide.html#Static_and_Global_Variables\n\nrtc::CriticalSection doesn\u0027t obey those restrictions.",
      "parentUuid": "ffd6202b_64d7e169",
      "range": {
        "startLine": 100,
        "startChar": 0,
        "endLine": 101,
        "endChar": 31
      },
      "revId": "9887ebc17350abd019cd1a7da355aa1ba51f4171",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4fa22a1_df279a70",
        "filename": "rtc_base/critical_section.h",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-11-18T11:32:44Z",
      "side": 1,
      "message": "\u003e rtc::CriticalSection doesn\u0027t obey those restrictions.\n\nI see. At least with pthreads, it seems you could implement GlobalLock using a plain pthread_mutex_t, PTHREAD_MUTEX_INITIALIZER, and solve the destructor problem by never calling pthread_mutex_destroy.",
      "parentUuid": "cda83956_4f419a39",
      "range": {
        "startLine": 100,
        "startChar": 0,
        "endLine": 101,
        "endChar": 31
      },
      "revId": "9887ebc17350abd019cd1a7da355aa1ba51f4171",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}