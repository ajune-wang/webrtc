{
  "comments": [
    {
      "key": {
        "uuid": "0836c912_04688a93",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 41,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-10-09T13:16:14Z",
      "side": 1,
      "message": "Not needed in an abstract base class.",
      "range": {
        "startLine": 40,
        "startChar": 1,
        "endLine": 41,
        "endChar": 42
      },
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "145dd780_80f4b7a2",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 41,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-10-09T14:17:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0836c912_04688a93",
      "range": {
        "startLine": 40,
        "startChar": 1,
        "endLine": 41,
        "endChar": 42
      },
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f9413f47_d1bac854",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 65,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-10-09T13:16:14Z",
      "side": 1,
      "message": "Use the actual callback type here instead? I.e., have that type too be a template argument?",
      "range": {
        "startLine": 65,
        "startChar": 3,
        "endLine": 65,
        "endChar": 23
      },
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f79cf6f_ddc22453",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 65,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-10-09T14:17:47Z",
      "side": 1,
      "message": "The callback is the thing returned by OperationsChain::CreateOperationCallback(), which is std::function\u003cvoid()\u003e. This requires no template magic, and in fact, since we require any operation\u0027s functor to take the callback as input, I think it is beneficial to have a known non-template type for it. I also didn\u0027t see a need to introduce a new type, from the operation\u0027s point of view, it needs to invoke a parameterless void function.\n\nIf you suggest something else, can you clarify what? I\u0027m not sure I follow if there are benefits to having even more templates.",
      "parentUuid": "f9413f47_d1bac854",
      "range": {
        "startLine": 65,
        "startChar": 3,
        "endLine": 65,
        "endChar": 23
      },
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf0d2e9f_cc5d1877",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 65,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-10-11T10:16:32Z",
      "side": 1,
      "message": "Oh, so it\u0027s only ever going to be the return value of OperationsChain::CreateOperationCallback()? In that case, I would suggesting making a concrete type for that, and not wrapping it in a std::function. And use that concrete type here.",
      "parentUuid": "9f79cf6f_ddc22453",
      "range": {
        "startLine": 65,
        "startChar": 3,
        "endLine": 65,
        "endChar": 23
      },
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "122d182d_bce85b0a",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 65,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-10-14T16:36:55Z",
      "side": 1,
      "message": "Done. See other comment.",
      "parentUuid": "bf0d2e9f_cc5d1877",
      "range": {
        "startLine": 65,
        "startChar": 3,
        "endLine": 65,
        "endChar": 23
      },
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "44d6196c_a20ff322",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 66,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-10-09T13:16:14Z",
      "side": 1,
      "message": "#ifdef this variable away unless RTC_DCHECK_IS_ON?",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0608cdb9_b869f1f8",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 66,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-10-09T14:17:47Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "44d6196c_a20ff322",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6411d095_ede825ef",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 97,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-10-09T11:23:02Z",
      "side": 1,
      "message": "If we want to support synchronously cancelling any pending tasks I could introduce cancelling mechanisms in a follow-up CL.\n\nA possible use case for this is if we want PeerConnection::Close() to ensure that there are no async tasks keeping the PC alive through reference counting, ensuring that if the client nulls all of its references to the PC after doing Close(), it will in fact be deleted.\n\nI\u0027m not a fan of clients making assumptions about when reference counted objects are deleted but that might be the safest way forward in introducing an operations chain to PC and avoiding regressions.",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6c11b123_cbf3f9ce",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 97,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-10-09T11:24:03Z",
      "side": 1,
      "message": "This might also be needed for the sake of unittests. If we have async tasks posting between threads we can\u0027t delete the thread.",
      "parentUuid": "6411d095_ede825ef",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ab5de1c_7a3ceb11",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 185,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-10-09T10:54:09Z",
      "side": 1,
      "message": "This could also be implemented as an std::list.",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08d3f5af_3bfde2cf",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 185,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-10-09T12:24:03Z",
      "side": 1,
      "message": "Thread annotations for these two data members?",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "60d46dcf_38d84c68",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 185,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-10-09T13:16:14Z",
      "side": 1,
      "message": "Actually, can they be removed? The DCHECKs for execute-exactly-once in OperationWithFunctor should be enough, right?",
      "parentUuid": "08d3f5af_3bfde2cf",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59fb4108_e7a29c62",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 185,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-10-09T14:17:47Z",
      "side": 1,
      "message": "I decided to keep using std::set\u003c\u003e instead of std::list\u003c\u003e, that way the DCHECKing of whether or not the callback has been invoked (which on failure says exactly that: the callback has already been invoked) is not build on assumptions that tasks are executed in-order; that is DCHECKed separately.",
      "parentUuid": "7ab5de1c_7a3ceb11",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3ccea71a_22e7a83e",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 185,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-10-09T14:17:47Z",
      "side": 1,
      "message": "OperationWithFunctor DCHECKs that the operation functor gets invoked exactly once but is unable to tell how many times the user-defined functor later causes the callback (\"operation completed\") to be invoked. This needs to be DCHECKed separately - I kept the members.\n\nBut I did add thread annotations.\n\nI also considered making these behind #ifdef RTC_DCHECK_IS_ON but found that it hurt code readability of CreateOperationCallback() so I don\u0027t think it\u0027s worth the optimization.",
      "parentUuid": "60d46dcf_38d84c68",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7d010fe7_10b31bbd",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 185,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-10-11T10:16:32Z",
      "side": 1,
      "message": "You should be able to CHECK it in the functor returned by CreateOperationCallback()---in fact, you already do. But that check should be able to use a bool stored in that functor, instead of stored centrally here.",
      "parentUuid": "3ccea71a_22e7a83e",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fd9a5516_19ba4717",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 185,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-10-14T16:36:55Z",
      "side": 1,
      "message": "I made it a concrete type. Very nice. I was able to do an easy \"bool has_run_\" inside of the explicit OperationsChainCallback, allowing me to remove the \"pending operation IDs\" logic. And not only could I DCHECK that callback was not invoked more than twice, I was now also able to easily DCEHCK that the callback was invoked.\n\nNote that I was forced to use a copyable type in order for the callback to be an acceptable argument to the functor (if the operation is defined by an std::functor\u003c\u003e all of its arguments - i.e. the callback - has to be copyable). To make it copyable I made it a RefCountedObject rather than have it be something move-only.",
      "parentUuid": "7d010fe7_10b31bbd",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9fcf13b7_d4bccfd6",
        "filename": "rtc_base/operations_chain.h",
        "patchSetId": 3
      },
      "lineNbr": 185,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-10-15T08:34:27Z",
      "side": 1,
      "message": "\u003e I was able to do an easy \"bool has_run_\" inside of the explicit OperationsChainCallback, allowing me to remove the \"pending operation IDs\" logic. And not only could I DCHECK that callback was not invoked more than twice, I was now also able to easily DCEHCK that the callback was invoked.\n\nYes.\n\n\u003e Note that I was forced to use a copyable type in order for the callback to be an acceptable argument to the functor (if the operation is defined by an std::functor\u003c\u003e all of its arguments - i.e. the callback - has to be copyable). To make it copyable I made it a RefCountedObject rather than have it be something move-only.\n\nI don\u0027t understand---the only nontrivial data member in OperationsChainCallback is a scoped_refptr, so OperationsChainCallback would be copyable if you hadn\u0027t explicitly switched that off.",
      "parentUuid": "fd9a5516_19ba4717",
      "revId": "8cf31f59b4fc2ad741d8d9f8cd50055fda423d80",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}