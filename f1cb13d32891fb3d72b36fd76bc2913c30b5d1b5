{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ef60e4f6_c1fdcc0c",
        "filename": "api/stats/rtcstats_objects.h",
        "patchSetId": 10
      },
      "lineNbr": 429,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-04-20T09:45:26Z",
      "side": 1,
      "message": "As far as I know this makes sense, but let\u0027s ask an expert. +Danil, do you have an opinion?",
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0d785e5_898e293f",
        "filename": "api/stats/rtcstats_objects.h",
        "patchSetId": 10
      },
      "lineNbr": 429,
      "author": {
        "id": 19549
      },
      "writtenOn": "2023-04-20T10:39:55Z",
      "side": 1,
      "message": "Without RTX you can\u0027t tell whether a received packet was late or a resend. Which is the reason to do RTX in the first place, see https://www.rfc-editor.org/rfc/rfc4588#section-3 -- \"One approach may...\"\n\nFrom my testing we also have a problem with not accounting for RTX probes on the sender side (these are generated by a different layer). We count them on the receiver because we have no (good) way to tell whether a received RTX packet was a probe or not.\nWording adjusted slightly to \"it is therefore possible\".",
      "parentUuid": "ef60e4f6_c1fdcc0c",
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "56df1f20_2a6b8eea",
        "filename": "api/stats/rtcstats_objects.h",
        "patchSetId": 10
      },
      "lineNbr": 429,
      "author": {
        "id": 5019
      },
      "writtenOn": "2023-04-20T10:44:07Z",
      "side": 1,
      "message": "Yes, without special channel retranmission are hard to distinguish from normal tranmission. You may use some heuristics if you\u0027re using transport sequence number, but I do not think we do, or plan to do it: for BWE purpose it doesn\u0027t matter if packet regular media, retranmission, or pure padding. for regular media it also doesn\u0027t matter if packet arrived regularly (but late) or was retransmitted.\n\n\nFlexfec might make theory a bit more complicated: flexfec can be used not just for Forward Error Correction, but also for pure retranmission (and thus may obsolete RTX).\nWebRTC currently doesn\u0027t use flexfec that way, so it might be better to think how to count such packets later, when/if flexfec implementation would be updated.",
      "parentUuid": "ef60e4f6_c1fdcc0c",
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5e0eadb2_beba14fd",
        "filename": "media/base/media_channel.h",
        "patchSetId": 10
      },
      "lineNbr": 447,
      "author": {
        "id": 5019
      },
      "writtenOn": "2023-04-20T10:44:07Z",
      "side": 1,
      "message": "https://google.github.io/styleguide/cppguide.html#General_Naming_Rules\n\n“Do not abbreviate by deleting letters within a word.”",
      "range": {
        "startLine": 447,
        "startChar": 47,
        "endLine": 447,
        "endChar": 51
      },
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "642adcd4_f23b68b0",
        "filename": "media/base/media_channel.h",
        "patchSetId": 10
      },
      "lineNbr": 447,
      "author": {
        "id": 19549
      },
      "writtenOn": "2023-04-20T12:42:32Z",
      "side": 1,
      "message": "Keeping in style  with the above though, happy to do a replace-all in a different CL (~100 occurences) after landing this one, I found it annoying too!",
      "parentUuid": "5e0eadb2_beba14fd",
      "range": {
        "startLine": 447,
        "startChar": 47,
        "endLine": 447,
        "endChar": 51
      },
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "67e71daa_291cad28",
        "filename": "media/base/media_channel.h",
        "patchSetId": 10
      },
      "lineNbr": 447,
      "author": {
        "id": 19549
      },
      "writtenOn": "2023-04-27T08:13:57Z",
      "side": 1,
      "message": "Fixed downstream, done here too now!",
      "parentUuid": "642adcd4_f23b68b0",
      "range": {
        "startLine": 447,
        "startChar": 47,
        "endLine": 447,
        "endChar": 51
      },
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c397e24e_f0ccd96a",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 10
      },
      "lineNbr": 425,
      "author": {
        "id": 5019
      },
      "writtenOn": "2023-04-20T10:44:07Z",
      "side": 1,
      "message": "why cast from uint64_t to uint64_t?",
      "range": {
        "startLine": 425,
        "startChar": 50,
        "endLine": 425,
        "endChar": 71
      },
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6344808b_20919155",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 10
      },
      "lineNbr": 425,
      "author": {
        "id": 19549
      },
      "writtenOn": "2023-04-20T12:42:32Z",
      "side": 1,
      "message": "\"the other things cast too\" - but they do because types differ, here they don\u0027t!",
      "parentUuid": "c397e24e_f0ccd96a",
      "range": {
        "startLine": 425,
        "startChar": 50,
        "endLine": 425,
        "endChar": 71
      },
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "007ee39d_87047cb9",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 10
      },
      "lineNbr": 426,
      "author": {
        "id": 5019
      },
      "writtenOn": "2023-04-20T10:44:07Z",
      "side": 1,
      "message": "avoid optional::value() - prefer to deference it with \u0027*\u0027 [after you\u0027ve checked with .has_value() it is not nullopt]\n\nhttps://abseil.io/tips/181#solution\n\n“Testing the absl::StatusOr object for validity (as you would a smart pointer or optional) and accessing it using operator* or operator-\u003e is readable, efficient, and safe.”",
      "range": {
        "startLine": 426,
        "startChar": 8,
        "endLine": 426,
        "endChar": 60
      },
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "83690c1f_495f7fa5",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 10
      },
      "lineNbr": 426,
      "author": {
        "id": 19549
      },
      "writtenOn": "2023-04-20T12:42:32Z",
      "side": 1,
      "message": "hbos has opinions ;-)",
      "parentUuid": "007ee39d_87047cb9",
      "range": {
        "startLine": 426,
        "startChar": 8,
        "endLine": 426,
        "endChar": 60
      },
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26e3fd5e_04f8f275",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 10
      },
      "lineNbr": 426,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-04-21T07:17:07Z",
      "side": 1,
      "message": "Do what Danil says :)",
      "parentUuid": "83690c1f_495f7fa5",
      "range": {
        "startLine": 426,
        "startChar": 8,
        "endLine": 426,
        "endChar": 60
      },
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d74074d9_8fe64810",
        "filename": "pc/rtc_stats_collector.cc",
        "patchSetId": 10
      },
      "lineNbr": 426,
      "author": {
        "id": 19549
      },
      "writtenOn": "2023-04-21T08:00:12Z",
      "side": 1,
      "message": "Yield to written rules. I can do the follow-up CL so we settle this discussion once and for all ;-)",
      "parentUuid": "26e3fd5e_04f8f275",
      "range": {
        "startLine": 426,
        "startChar": 8,
        "endLine": 426,
        "endChar": 60
      },
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cdb45c6e_426731e4",
        "filename": "pc/rtc_stats_collector_unittest.cc",
        "patchSetId": 10
      },
      "lineNbr": 2746,
      "author": {
        "id": 5142
      },
      "writtenOn": "2023-04-20T09:45:26Z",
      "side": 1,
      "message": "nit: All the power to testing nullopt path, but if we only test one value I would prefer to test that a value is set. If you want to also test nullopt then have two tests, but with only one test we should make sure something is set IMO.",
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2ed0a775_3fd2be0d",
        "filename": "pc/rtc_stats_collector_unittest.cc",
        "patchSetId": 10
      },
      "lineNbr": 2746,
      "author": {
        "id": 19549
      },
      "writtenOn": "2023-04-21T08:00:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "cdb45c6e_426731e4",
      "revId": "f1cb13d32891fb3d72b36fd76bc2913c30b5d1b5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}