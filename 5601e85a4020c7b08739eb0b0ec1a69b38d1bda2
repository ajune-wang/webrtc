{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "13bc569a_3cc851d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 41
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2023-03-27T12:55:39Z",
      "side": 1,
      "message": "OK, let\u0027s try this.",
      "revId": "5601e85a4020c7b08739eb0b0ec1a69b38d1bda2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1bfd8ec4_c4151201",
        "filename": "pc/sctp_data_channel.h",
        "patchSetId": 41
      },
      "lineNbr": 41,
      "author": {
        "id": 5634
      },
      "writtenOn": "2023-03-27T12:55:39Z",
      "side": 1,
      "message": "That\u0027s not what I would describe it as - the name was chosen because the DCC owns all the datachannels and manages their interactions with the transports and the user of the datachannels (at the moment the peerconnection is the only user).\n\nBut it also does what you say it does.",
      "revId": "5601e85a4020c7b08739eb0b0ec1a69b38d1bda2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "644f1848_a368c40f",
        "filename": "pc/sctp_data_channel.h",
        "patchSetId": 41
      },
      "lineNbr": 41,
      "author": {
        "id": 5508
      },
      "writtenOn": "2023-03-27T15:26:08Z",
      "side": 1,
      "message": "I think this is what Taylor was seeing it as with the todo that we removed a few CLs ago (iirc the TODO was about using the transport directly).\nAlthough the interface is implemented by the controller and has the word \"Controller\" in it, the methods in it, with the exception of `OnChannelStateChanged` map directly to the transport.\n\nWe could rename the interface? Another option is, once we\u0027ve removed the thread hops, is to use the transport interface directly for methods that map to it and keep things like OnChannelStateChanged().\n\nI think it could even be as simple as:\n```\nclass SctpDataChannelControllerInterface {\n public:\n  // Could even use SctpTransportInterface* since it\u0027s an sctp data channel.\n  virtual DataChannelTransportInterface* transport() const \u003d 0;\n  virtual void OnChannelStateChanged(SctpDataChannel* data_channel,\n                                     DataChannelInterface::DataState state) \u003d 0;\n};\n```",
      "parentUuid": "1bfd8ec4_c4151201",
      "revId": "5601e85a4020c7b08739eb0b0ec1a69b38d1bda2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdec605b_54e70df7",
        "filename": "pc/sctp_data_channel.h",
        "patchSetId": 41
      },
      "lineNbr": 44,
      "author": {
        "id": 5634
      },
      "writtenOn": "2023-03-27T12:55:39Z",
      "side": 1,
      "message": "I don\u0027t see this as a goal.\n\nCreateDataChannel() comes ultimately from the signaling thread. Whether this module or the PC does the thread jump is a matter of deciding how to divvy up the functions.",
      "revId": "5601e85a4020c7b08739eb0b0ec1a69b38d1bda2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7854dfb3_5a8d31ab",
        "filename": "pc/sctp_data_channel.h",
        "patchSetId": 41
      },
      "lineNbr": 44,
      "author": {
        "id": 5508
      },
      "writtenOn": "2023-03-27T15:26:08Z",
      "side": 1,
      "message": "The thinking is to not have to do the blocking thread hops for the most sensitive operations. One example:\n```\nRTCError DataChannelController::DataChannelSendData(\n    StreamId sid,\n    const SendDataParams\u0026 params,\n    const rtc::CopyOnWriteBuffer\u0026 payload) {\n  // \u003csnip\u003e\n  return network_thread()-\u003eBlockingCall([this, sid, params, payload] {\n    return data_channel_transport()-\u003eSendData(sid.stream_id_int(), params,\n                                              payload);\n  });\n}\n```\n\nMost of the operations inside of SctpDataChannel are non-blocking in nature. It\u0027s buffer management and then interfacing with the transport. We could do that on the network thread and not require context switches whenever interaction happens between the channel and the transport. I don\u0027t see this as a \"we have to do the hop somewhere\" but rather \"we don\u0027t need to do the hop\" and that\u0027s what I\u0027m seeing as the goal.\n\nYou\u0027re right that CreateDataChannel is triggered from the signaling thread. I\u0027ll move the call to `SctpDataChannel::Create` to the network thread though a couple of CLs down the line, but the call to `InternalCreateDataChannelWithProxy` will happen on the signaling thread. I\u0027m OK with thread hops when setting things up or tearing down, but in between, when sending and receiving data, I\u0027d like to do as little of that as possible.",
      "parentUuid": "fdec605b_54e70df7",
      "revId": "5601e85a4020c7b08739eb0b0ec1a69b38d1bda2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "At least one maximum vote for label \u0027Code-Review\u0027 is required"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader AND -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1 AND -label:Code-Review\u003dMIN"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader AND -label:Code-Review=MIN"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["label:Code-Review=MAX,user=non_uploader"],"failingAtoms":["label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1 AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1","label:Code-Review=MIN"]}
      },
      "patchSetCommitId": "5601e85a4020c7b08739eb0b0ec1a69b38d1bda2",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":["is:review-enforced_gerrit"],"failingAtoms":[]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"PASS","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforcement-satisfied_gerrit"]}
      },
      "patchSetCommitId": "5601e85a4020c7b08739eb0b0ec1a69b38d1bda2",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {
        "value": true
      }
    }
  ]
}