{
  "comments": [
    {
      "key": {
        "uuid": "d71a3e21_218865ac",
        "filename": "modules/audio_coding/neteq/tools/neteq_test_factory.cc",
        "patchSetId": 1
      },
      "lineNbr": 464,
      "author": {
        "id": 5607
      },
      "writtenOn": "2018-12-20T13:14:50Z",
      "side": 1,
      "message": "This makes my brain hurt a bit. We are creating a lambda that captures a reference to decoder_factory, but then we store that lambda wrapped in an object inside decoder_factory. I guess it will end up getting a reference to its own wrapping object when it runs? Will the code actually work or will there be some sort of infinite recursion where the lambda keeps calling MakeAudioDecoder on its own wrapping object?",
      "range": {
        "startLine": 464,
        "startChar": 8,
        "endLine": 464,
        "endChar": 25
      },
      "revId": "8616099accdda98b17a7606a07fe82cdcc69dbe2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "25e63f3f_be6d8bf8",
        "filename": "modules/audio_coding/neteq/tools/neteq_test_factory.cc",
        "patchSetId": 1
      },
      "lineNbr": 464,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-20T13:27:15Z",
      "side": 1,
      "message": "As I understand it, the reference on the right hand side should be capture-by-copy, and right-hand side should be fully evaluated prior to the assignment to the left hand side. So no more recursive than, e.g., x \u003d foo(x). I\u0027ve not read up on all the fine details of C++ lambdas, though.\n\nI could write it as\n\nbuiltin_factory \u003d CreateBuiltinAudioDecoderFactory();\n\nif (...) { decoder_factory \u003d ...[builtin_factory](...){} ... }\nelse { decoder_factory \u003d builtin_factory; } \n\nbut I\u0027m not sure that\u0027s an improvement. What do you suggest?",
      "parentUuid": "d71a3e21_218865ac",
      "range": {
        "startLine": 464,
        "startChar": 8,
        "endLine": 464,
        "endChar": 25
      },
      "revId": "8616099accdda98b17a7606a07fe82cdcc69dbe2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3d867c8_e4f4f239",
        "filename": "modules/audio_coding/neteq/tools/neteq_test_factory.cc",
        "patchSetId": 1
      },
      "lineNbr": 464,
      "author": {
        "id": 5607
      },
      "writtenOn": "2018-12-20T14:33:25Z",
      "side": 1,
      "message": "I was just checking if this is correct, if you\u0027re confident that it is then we can keep it as is, since the problem is just my understanding and not the code itself. Perhaps a comment could be helpful for the uninitiated.",
      "parentUuid": "25e63f3f_be6d8bf8",
      "range": {
        "startLine": 464,
        "startChar": 8,
        "endLine": 464,
        "endChar": 25
      },
      "revId": "8616099accdda98b17a7606a07fe82cdcc69dbe2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8d15018d_5a1b00b9",
        "filename": "modules/audio_coding/neteq/tools/neteq_test_factory.cc",
        "patchSetId": 1
      },
      "lineNbr": 464,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-20T14:53:43Z",
      "side": 1,
      "message": "I can add a comment.\n\nI\u0027m fairly confident that it\u0027s right, but not so confident that I\u0027d like to land without testing. How do I test neteq_rtpplay?",
      "parentUuid": "c3d867c8_e4f4f239",
      "range": {
        "startLine": 464,
        "startChar": 8,
        "endLine": 464,
        "endChar": 25
      },
      "revId": "8616099accdda98b17a7606a07fe82cdcc69dbe2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "968a9df0_4c6b679d",
        "filename": "modules/audio_coding/neteq/tools/neteq_test_factory.cc",
        "patchSetId": 1
      },
      "lineNbr": 468,
      "author": {
        "id": 5607
      },
      "writtenOn": "2018-12-20T14:33:25Z",
      "side": 1,
      "message": "I wonder if this is really necessary. In this part of the control flow we already know that we want to use replacement audio, so can\u0027t we just always return a FakeDecodeFromFile? That would also simplify other parts of the CL.",
      "range": {
        "startLine": 466,
        "startChar": 0,
        "endLine": 468,
        "endChar": 57
      },
      "revId": "8616099accdda98b17a7606a07fe82cdcc69dbe2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2641b3a7_b75bfad4",
        "filename": "modules/audio_coding/neteq/tools/neteq_test_factory.cc",
        "patchSetId": 1
      },
      "lineNbr": 468,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-20T14:53:43Z",
      "side": 1,
      "message": "Even without this, we need an enum that (i) isn\u0027t explicitly refused by DecoderDatabase::RegisterPayload, like kDecoderArbitrary is, (ii) is recognized by NetEqDecoderToSdpAudioFormat, and (iii) can\u0027t reasonably be supported by a real decoder.\n\nAnd I\u0027m thinking it\u0027s good to fail in an obvious way, returning nullptr, in case we get some random unrecognized audio format?\n\nWhen we delete NetEqDecoder, we could represent this more neatly as an SdpAudioFormat with format.name \u003d\u003d \"replacement\", and format.parameters[\"filename\"] saying which file to use.",
      "parentUuid": "968a9df0_4c6b679d",
      "range": {
        "startLine": 466,
        "startChar": 0,
        "endLine": 468,
        "endChar": 57
      },
      "revId": "8616099accdda98b17a7606a07fe82cdcc69dbe2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}