{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "335528b2_c784e46d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2020-10-19T08:01:10Z",
      "side": 1,
      "message": "Hi,\n\nthis is an improved version of https://webrtc-review.googlesource.com/c/src/+/187492 which was reverted. Changes are:\n1) The XdgDesktopPortal base is now a singleton and is not supposed to be stored on the browser side as before\n2) I made use of DesktopCapturer::GetSourceList() and DesktopCapturer::SelectSource() to let the browser select the same portal call to avoid additional portal dialog once user confirms the preview dialog on browser side\n\nThere is one thing I don\u0027t know how to solve. Given the XdgDesktopPortalBase is a singleton, it exists until the process where it was created is destroyed, but the destructor doesn\u0027t get called. I tried to use std::unique_ptr for this to make sure it gets destroyed when it goes out of scope, but it cannot be used this was and the compiler complains about missing exit-time and global destructors. Option is to destroy this object when there is no pending portal call and re-create it again with next capturer, but I\u0027m rather asking first before I implement it. Do you have any suggestion?",
      "revId": "1c95509074d5fa0d18f93fcc7ccdf32a144d20f3",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bee25e9_f5f94123",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5064
      },
      "writtenOn": "2020-10-23T14:26:12Z",
      "side": 1,
      "message": "\u003e Hi,\n\u003e \n\u003e this is an improved version of https://webrtc-review.googlesource.com/c/src/+/187492 which was reverted. Changes are:\n\u003e 1) The XdgDesktopPortal base is now a singleton and is not supposed to be stored on the browser side as before\n\u003e 2) I made use of DesktopCapturer::GetSourceList() and DesktopCapturer::SelectSource() to let the browser select the same portal call to avoid additional portal dialog once user confirms the preview dialog on browser side\n\nReviewing the diff from Patch-set #1 to Patch-set #3 I don\u0027t see those changes, just some \"cancelable\" changes?\n\n\u003e There is one thing I don\u0027t know how to solve. Given the XdgDesktopPortalBase is a singleton, it exists until the process where it was created is destroyed, but the destructor doesn\u0027t get called. I tried to use std::unique_ptr for this to make sure it gets destroyed when it goes out of scope, but it cannot be used this was and the compiler complains about missing exit-time and global destructors. Option is to destroy this object when there is no pending portal call and re-create it again with next capturer, but I\u0027m rather asking first before I implement it. Do you have any suggestion?\n\nIn Chromium we generally allow singletons to leak, since there isn\u0027t any point doing teardown work when the process itself is about to exit. e.g. a common pattern in Chromium is:\n\n  Thing* GetThingInstance() {\n    static base::NoDestructor\u003cThing\u003e instance;\n    return instance.get();\n  }\n\nusing the NoDestructor\u003c\u003e template we have there.  I\u0027m not sure what the equivalent pattern would be in WebRTC though.",
      "parentUuid": "335528b2_c784e46d",
      "revId": "1c95509074d5fa0d18f93fcc7ccdf32a144d20f3",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9d9e35b_9db7b7a0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2020-10-23T15:31:17Z",
      "side": 1,
      "message": "You will not see difference between the change you reviewed before and this one, because the one before was merged and reverted and I had to create a new one.\n\nWebRTC doesn\u0027t seem to have base::NoDestructor. Is there a similar alternative?",
      "parentUuid": "2bee25e9_f5f94123",
      "revId": "1c95509074d5fa0d18f93fcc7ccdf32a144d20f3",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "314f0691_3be3ec97",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5064
      },
      "writtenOn": "2020-10-23T15:35:38Z",
      "side": 1,
      "message": "Oh, if you\u0027re re-landing a patch-set with modifications you can upload the original patch, so that that is patch-set #1 in the new CL, and then upload the changes as later patch-sets, so that reviewers can just compare the later patches tp patch-set #1 to see what the new changes were.\n\n(Reading your updated CL description)\n\nOK, so we need to re-use the same XDG-desktop-portal connection between the picker and the capture, otherwise the capture will trigger the picker to be shown again, because that\u0027s how XDG does things. If we instead start the capture using the same XDG channel and request-Id then it knows not to show the picker again.",
      "parentUuid": "2bee25e9_f5f94123",
      "revId": "1c95509074d5fa0d18f93fcc7ccdf32a144d20f3",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b81d9124_2f77fe0c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2020-10-23T15:53:00Z",
      "side": 1,
      "message": "Yes. that\u0027s the idea. It\u0027s not the picker on Chromium side which will be shown again, but the picker on xdg-desktop-portal side.",
      "parentUuid": "314f0691_3be3ec97",
      "revId": "1c95509074d5fa0d18f93fcc7ccdf32a144d20f3",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}