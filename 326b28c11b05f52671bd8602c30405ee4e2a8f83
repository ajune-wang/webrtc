{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "69ac6a26_1c8ad476",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 31
      },
      "lineNbr": 0,
      "author": {
        "id": 5578
      },
      "writtenOn": "2021-01-19T12:20:12Z",
      "side": 1,
      "message": "Jonas, would you mind reviewing this instead of me? I have very little knowledge about this part of the code?",
      "revId": "326b28c11b05f52671bd8602c30405ee4e2a8f83",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a9d59d73_d79b2c14",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 31
      },
      "lineNbr": 0,
      "author": {
        "id": 5613
      },
      "writtenOn": "2021-01-19T12:44:36Z",
      "side": 1,
      "message": "LGTM on the actual patch.\n\nSome comment on the project/bug: sorry for being late to the party.\n\nThe \"old\" sigslot code had the nice feature of being easy to read as it was \nnamed similarly, and structured similarly.\nIs there a proposal on how that should be done wrt to CallbackList too ?\n\ne.g\n1) definition:\nsigslot SignalPortDestroyed \u003d\u003e port_destroyed_\ncomment: how about port_destroyed_callback_list_\n\n2) invokation:\nSignalPortDestroyed(args); \u003d\u003e port_destroyed_.Send(args);\ncomment: ok\n\n3) subscription\nSignalPortDestroyed.connect(args) \u003d\u003e MyClass::SubscribePortDestroyed()\ncomment: why not \"connect\" like before ?\n",
      "revId": "326b28c11b05f52671bd8602c30405ee4e2a8f83",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a90e333_034566ff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 31
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-01-19T13:20:31Z",
      "side": 1,
      "message": "Before submitting - can we have assurances around avoiding uaf?\n(temporarily -1ing in case of accidental submit)",
      "revId": "326b28c11b05f52671bd8602c30405ee4e2a8f83",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7dcb788_e4bf3976",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 31
      },
      "lineNbr": 0,
      "author": {
        "id": 5087
      },
      "writtenOn": "2021-01-19T13:57:08Z",
      "side": 1,
      "message": "Yes, this is a great point and it is good we have the possibility to address this early in the process (it will make future refactoring easier).\n\nIn SigSlot, if I understand correctly, this is handled by the base class sigslot::has_slots\u003c\u003e which does this: https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/rtc_base/third_party/sigslot/sigslot.h;l\u003d496;drc\u003da4d873786f10eedd72de25ad0d94ad7c53c1f68a. So when a class with slots (a class that has methods connect()\u0027ed to signals) gets destroyed, it automatically disconnects all its slots. In this case, P2PTransportChannel \u003c-- IceTransportInternal \u003c-- PacketTransportInternal \u003c-- sigslot::has_slots\u003c\u003e.\n\nkwiberg@ has added the possibility to do something similar in https://webrtc-review.googlesource.com/c/src/+/195332, I think this CL might be the first one that needs to use it (the class keeps track of what it subscribes to and unsubscribes when it gets destroyed).\n\nOn the other hand, if we are 100% sure that the callback will always have a longer lifetime, we might want to avoid this. How can we signal this from a lifetime point of view? A comment is not good enough, while before we were paying for more locking and cleanup than we were aware of, we now need a way to make these things clear.",
      "parentUuid": "0a90e333_034566ff",
      "revId": "326b28c11b05f52671bd8602c30405ee4e2a8f83",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4cb45c72_15974670",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 31
      },
      "lineNbr": 0,
      "author": {
        "id": 5087
      },
      "writtenOn": "2021-01-20T09:02:35Z",
      "side": 1,
      "message": "What I have written yesterday in the comment above is overly complicated and partially undoes the benefits of the SigSlots-\u003eCallbackList switch.\n\nI think the correct way to avoid UAF is using weak pointers like hta@ has done in https://webrtc-review.googlesource.com/c/src/+/192540 (see the code in pc/rtp_transmission_manager.h and pc/rtp_transmission_manager.cc in that CL).\n\nI never used rtc::WeakPtrFactory so I am reading the code right now, but it looks like the best way to go.",
      "parentUuid": "f7dcb788_e4bf3976",
      "revId": "326b28c11b05f52671bd8602c30405ee4e2a8f83",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8cae7c1c_97a167c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 31
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-01-20T13:47:48Z",
      "side": 1,
      "message": "One thing to consider is that there are at least a couple of design patterns that could be applied towards avoiding uaf. If we talk about a weakptr approach vs a registration token, the differences are:\n\nweak_ptr\n* Pointer is embedded in the callback\n* caller can generate a new weakptr instance per registration\n* no built in trip wires against registering the same callback more than once\n* callback always executes, weak pointer ensures it doesn\u0027t run if object deleted\n* threading concerns if any, taken care of by the weak ptr impl + callback\n* callback reference is actually never deleted and list of callbacks grows indefinitely.\n\nregistration token\n* caller is responsible for holding the token for every registration\n* token calls unregister when it goes out of scope\n* callback actually gets removed from the list of callbacks\n* threading responsibilities are on the callback architecture, not the caller\n* storing a registration token in a variable and registering again, would automatically unregister the previous registration. 1:1 token to callback mapping.",
      "parentUuid": "4cb45c72_15974670",
      "revId": "326b28c11b05f52671bd8602c30405ee4e2a8f83",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}