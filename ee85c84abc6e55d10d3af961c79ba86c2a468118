{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6ed3dbdf_ab158b8e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 18474
      },
      "writtenOn": "2023-03-13T18:11:39Z",
      "side": 1,
      "message": "Salman recently added some eventing, and I think long term the goal would be to try to leverage that, which it looks like this breaks.\n\nFurther, it\u0027s worth the discussion of if the (potential) reduced processing power now makes up for the increased memory (to store this extra buffer on top of the frame queue now) and latency (to process the buffer upon demand).\n\nIs this mostly a theoretical or are there metrics about devices that seem to be adversely affected by the current behavior and how this change improves those devices?",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4982970_097278f0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 8046
      },
      "writtenOn": "2023-03-13T18:34:44Z",
      "side": 1,
      "message": "It\u0027s true that it will not play well with Salman\u0027s workflow, because we now process frames only once they are requested :-/.\n\nIncreased memory won\u0027t be much a problem, because the buffer doesn\u0027t carry the frame itself, only its information (size, stride, etc.) and file descriptor.\n\nMartin Stránský said he saw a drop in CPU usage, but we didn\u0027t do any exact measurement so it\u0027s also somewhat theoretical.",
      "parentUuid": "6ed3dbdf_ab158b8e",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed73e568_d2b0c447",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 18474
      },
      "writtenOn": "2023-03-13T18:38:45Z",
      "side": 1,
      "message": "\u003e Increased memory won\u0027t be much a problem, because the buffer doesn\u0027t carry the frame itself, only its information (size, stride, etc.) and file descriptor.\n\nPresumably this means that *somewhere* on the system has to hold onto the frame longer than it would otherwise though right? What lifetime guarantees do we have on this frame/buffer?",
      "parentUuid": "f4982970_097278f0",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18372050_ad27f170",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 8046
      },
      "writtenOn": "2023-03-13T18:47:27Z",
      "side": 1,
      "message": "That\u0027s right, but I also expect that it doesn\u0027t change anything since the compositor allocates few buffers upfront which are recycled over and over and might not get freed anyway until they are actually reused. \n\nI asked Wim Taymans (PipeWire author), he said there is a mechanism to refcount busy buffers and they will not get used until we queue them back. It should be safe to hold them until we use another one or until we stop streaming.",
      "parentUuid": "ed73e568_d2b0c447",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a83f723_f2f747a2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 8046
      },
      "writtenOn": "2023-03-13T18:52:17Z",
      "side": 1,
      "message": "I can modify it to check whether the callback Salman is using is set and in such case process the buffer right away. That would cover both cases, where one want\u0027s to get the frame as soon as possible and also avoid processing buffers that we are not going to consume.\n\nWould that work for you?",
      "parentUuid": "18372050_ad27f170",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d1443f0_7f1f99d8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 19629
      },
      "writtenOn": "2023-03-13T20:06:34Z",
      "side": 1,
      "message": "Sounds reasonable to me.\n\nWDYT, Alex?",
      "parentUuid": "2a83f723_f2f747a2",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "46cfb0c3_1bec1999",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 18474
      },
      "writtenOn": "2023-03-13T20:31:21Z",
      "side": 1,
      "message": "Yeah; my biggest concern is what you mention in your other commit description comment; this will definitely increase latency for the CaptureFrame API; so I\u0027d like to understand how that would be impacted. If either you or Martin have numbers to share that would be great. We could also look at doing an experiment in Chrome (which requires some flag configuration here, in chromium, and with some internal code); though I\u0027m not sure if I have the bandwidth to setup/analyze such an experiment right now, which is why some preliminary numbers would be good to understand.\n\nIt\u0027d also be good to understand the buffer starvation or otherwise creation issue.",
      "parentUuid": "0d1443f0_7f1f99d8",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f93c024f_58a11b73",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 19629
      },
      "writtenOn": "2023-03-13T20:06:34Z",
      "side": 1,
      "message": "For applications that are using CaptureFrame API, this is going to add some capture latency (especially for bigger frames) since processing is being done at the time of the capture now. May be we should also experiment to see if the delay is palpable with higher resolution, if so it will be a good idea to keep on processing and caching frames eagerly. It is hard to say without some benchmarking how much processing power was being wasted earlier and whether capturing/processing lazily would add any significant delay.",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 35
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f631ffd_62315222",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 18474
      },
      "writtenOn": "2023-03-13T20:31:21Z",
      "side": 1,
      "message": "+1, I\u0027ve put more of my thoughts regarding this in the other commit description commit as they pertain more to that ongoing discussion.",
      "parentUuid": "f93c024f_58a11b73",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 35
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "327ba8f8_c806fe20",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 14134
      },
      "writtenOn": "2023-04-28T23:30:17Z",
      "side": 1,
      "message": "In general I would prefer a design where either the consumer decides what to do , i.e. have it set a policy for the number of frames it\u0027s willing to accommodate in-flight (and has memory allocated to buffer).  This is more compatible with the \"push model\" approach that we want all capturers to use long term.  However that\u0027s not the way the current capture APIs work.\n\nIn the current \"pull model\" with CaptureFrame() we are more limited.  I am not sure we can even add a simple flow control API like AcceptFrames()/DropFrames() since it looks like there is nowhere for the frames to go, if there is already a frame captured and the flow control tells the capturer to accept more frames.\n\nSo I don\u0027t have a better idea right now, until we move more capturers to the \"push model.\"",
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "778c5299_688078cf",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 2
      },
      "lineNbr": 609,
      "author": {
        "id": 19629
      },
      "writtenOn": "2023-03-13T20:06:34Z",
      "side": 1,
      "message": "If it is non-null, should we return it back to the pool first (with `pw_stream_queue_buffer`) or does it not matter at cleanup time?",
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "At least one maximum vote for label \u0027Code-Review\u0027 is required"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader AND -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1 AND -label:Code-Review\u003dMIN"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MIN"]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1 AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["label:Bot-Commit=+1","label:Code-Review=MIN"]}
      },
      "patchSetCommitId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforced_gerrit"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}