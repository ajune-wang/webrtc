{
  "comments": [
    {
      "key": {
        "uuid": "847d4911_9e41b1f5",
        "filename": "p2p/base/port.cc",
        "patchSetId": 7
      },
      "lineNbr": 438,
      "author": {
        "id": 5281
      },
      "writtenOn": "2018-09-12T21:30:29Z",
      "side": 1,
      "message": "This seems less like standard C++ to me, but I will defer to others (and sigslot isn\u0027t really standard either).",
      "revId": "f4f59b4c1c4c5ed55bce20b8b1c720f39f0fc2cf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e4c1bbf1_a424d346",
        "filename": "p2p/base/port.cc",
        "patchSetId": 7
      },
      "lineNbr": 438,
      "author": {
        "id": 5887
      },
      "writtenOn": "2018-09-12T21:49:59Z",
      "side": 1,
      "message": "WeakPtr was mostly a Chromium thing, and WebRTC has the stripped-down version of it. We don\u0027t have many examples of this pattern in WebRTC but we do in Chromium. This is done so because I am worried about capture \"this\" in an asynchronous callback is dangerous, now that the callback definition in the interfaces is changed to aliases of std::function.",
      "parentUuid": "847d4911_9e41b1f5",
      "revId": "f4f59b4c1c4c5ed55bce20b8b1c720f39f0fc2cf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "273ed77a_d737dd41",
        "filename": "p2p/base/port.cc",
        "patchSetId": 7
      },
      "lineNbr": 438,
      "author": {
        "id": 5281
      },
      "writtenOn": "2018-09-13T00:01:25Z",
      "side": 1,
      "message": "Ack - I assume the signal implemented the equivalent functionality before (it should be disconnected if the Port is destroyed). I do think it is nice to have this code inline. Another fix might be to have an MDnsAddressRegistration object (like HostResolver::Request) that is owned by this object so that the callback could be cancelled, but I don\u0027t think we need to expand the scope of this CL now.",
      "parentUuid": "e4c1bbf1_a424d346",
      "revId": "f4f59b4c1c4c5ed55bce20b8b1c720f39f0fc2cf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c43659eb_ac8801c7",
        "filename": "p2p/base/port.cc",
        "patchSetId": 7
      },
      "lineNbr": 445,
      "author": {
        "id": 5039
      },
      "writtenOn": "2018-09-12T22:01:52Z",
      "side": 1,
      "message": "nit: I think just weak_ptr !\u003d nullptr works.",
      "revId": "f4f59b4c1c4c5ed55bce20b8b1c720f39f0fc2cf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7da70db3_65067c3f",
        "filename": "rtc_base/fakenetwork.h",
        "patchSetId": 7
      },
      "lineNbr": 86,
      "author": {
        "id": 5039
      },
      "writtenOn": "2018-09-12T22:01:52Z",
      "side": 1,
      "message": "nit: mdns_responder_ \u003d absl::make_unique\u003cwebrtc::FakeMDnsResponder\u003e();",
      "revId": "f4f59b4c1c4c5ed55bce20b8b1c720f39f0fc2cf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03f981d3_020121ac",
        "filename": "rtc_base/mdns_responder_interface.h",
        "patchSetId": 7
      },
      "lineNbr": 44,
      "author": {
        "id": 5281
      },
      "writtenOn": "2018-09-12T21:30:29Z",
      "side": 1,
      "message": "Why does this need a callback? Can we just return bool?\nTried to look for callers, but it doesn\u0027t look like downstream CLs have been rebased yet.",
      "revId": "f4f59b4c1c4c5ed55bce20b8b1c720f39f0fc2cf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "498eafb7_3bfd63b4",
        "filename": "rtc_base/mdns_responder_interface.h",
        "patchSetId": 7
      },
      "lineNbr": 44,
      "author": {
        "id": 5887
      },
      "writtenOn": "2018-09-12T21:49:59Z",
      "side": 1,
      "message": "This is done so to work with the generated interface by mojo in Chromium. All methods would be implemented as client calls via the mojo pipe, and the returns are given asynchronously via callbacks. This CL (https://chromium-review.googlesource.com/c/chromium/src/+/1182875) may explain better.\n\nTechnically I could rewrite this interface in a synchronous way, but I feel now that our only implementation is asynchronous, it could be a bit more straightforward to understand the codepath by making it clear it is going to be asynchronous. I think I did change the downstream here (https://chromium-review.googlesource.com/c/chromium/src/+/1206002) in mdns_responder_client.cc. Let me know if I missed anything.",
      "parentUuid": "03f981d3_020121ac",
      "revId": "f4f59b4c1c4c5ed55bce20b8b1c720f39f0fc2cf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "296426fa_e8e7fe4c",
        "filename": "rtc_base/mdns_responder_interface.h",
        "patchSetId": 7
      },
      "lineNbr": 44,
      "author": {
        "id": 5281
      },
      "writtenOn": "2018-09-13T00:01:25Z",
      "side": 1,
      "message": "Okay, I see where this comes from now, and I agree that there isn\u0027t any real value to having a synchronous version here. Thanks.",
      "parentUuid": "498eafb7_3bfd63b4",
      "revId": "f4f59b4c1c4c5ed55bce20b8b1c720f39f0fc2cf",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}