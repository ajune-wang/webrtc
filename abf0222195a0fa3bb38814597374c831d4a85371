{
  "comments": [
    {
      "key": {
        "uuid": "75cf409c_f1d057fd",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-29T15:17:35Z",
      "side": 1,
      "message": "is it info, or warning?",
      "range": {
        "startLine": 56,
        "startChar": 12,
        "endLine": 56,
        "endChar": 19
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6e9a82c_22f70719",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:34:15Z",
      "side": 1,
      "message": "I chose info because it would be normal if we supported multiple streams with the current api.",
      "parentUuid": "75cf409c_f1d057fd",
      "range": {
        "startLine": 56,
        "startChar": 12,
        "endLine": 56,
        "endChar": 19
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb83f819_83083939",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-29T08:48:41Z",
      "side": 1,
      "message": "Should we take kMinKeyFrameRequestIntervalMs into account also with MediaTransport?",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c6c5909b_1f3f5107",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-29T15:17:35Z",
      "side": 1,
      "message": "My first thought is that this layer should be responsible for throttling key frame requests\nkMinKeyFrameRequestIntervalMs. \n\nAnd transport simply passes the requests to the other side, reliably.\n\nOtherwise, all implementations of media transport would have to repeat this logic? (or we would have to put it in some base class).",
      "parentUuid": "bb83f819_83083939",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "02213789_4bb71cd5",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:34:15Z",
      "side": 1,
      "message": "I agree transports shouldn\u0027t implement throttling. I\u0027m thinking maybe this should move to VideoStreamEncoder; that class also gets RTT estimates, and hence could do better than using a hard-coded constant.\n\nNot clear to me if we need it at the moment, or if it\u0027s good enough for now to always call SendKeyFrame?",
      "parentUuid": "c6c5909b_1f3f5107",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ad5357be_004dd331",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:48:20Z",
      "side": 1,
      "message": "\u003e Not clear to me if we need it at the moment, or if it\u0027s good enough for now to always call SendKeyFrame?\n\nPeter, if you think it\u0027s ok as is, feel free to press the submit button for me.",
      "parentUuid": "02213789_4bb71cd5",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e635637c_b355c64d",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-30T16:03:42Z",
      "side": 1,
      "message": "Our downstream implementation won\u0027t repeat a keyframe if there is one in transit already.\nBut if the encoder was requesting keyframe with every frame it gets, it will cause issues -- e.g.\n1) you request a keyframe\n2) the keyframe arrives, but it gets put in the jitter buffer\n3) you request a keyframe again\n4) the keyframe request arrives to the other side, new keyframe is generated and sent\n5) you get the keyframe from the jitter buffer (2), but there is another keyframe in transit again.\n\nIn addition, our existing implementation would cancel all intra frames after the first keyframe to the second keyframe, because you explicitly requested a keyframe.\n\nEncoder should only request a keyframe once, and assume that the keyframe request gets delivered to the other side. And then the other side should guarantee the keyframe is sent.\n\nNo other keyframe requests should be requested after you request one keyframe, until you receive that keyframe.\n\n\nI am going to \u0027submit\u0027, because I think this type of logic could be done in a separate change. But please consider doing something like this sooner rather than later :)",
      "parentUuid": "ad5357be_004dd331",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "872af556_5570b117",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-31T08:55:20Z",
      "side": 1,
      "message": "\u003e Encoder should only request a keyframe once, and assume that the keyframe request gets delivered to the other side. And then the other side should guarantee the keyframe is sent.\n\u003e \n\u003e No other keyframe requests should be requested after you request one keyframe, until you receive that keyframe.\n\nThis sounds reasonable, but it will be difficult to get the needed reliable delivery with rtp/rtcp. There may also be issues with participants joining and leaving a stream.",
      "parentUuid": "e635637c_b355c64d",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdf1645f_0563f276",
        "filename": "video/encoder_key_frame_callback.cc",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-31T14:48:28Z",
      "side": 1,
      "message": "(I meant decoder, of course)\n\nJust to clarify \"No other keyframe requests should be requested after you request one keyframe, until you receive that keyframe.\" by the same decoder. If there is a new participant joining, that participant should request a keyframe (once).\n\nI think that it is the responsibility of the transport to guarantee delivery of the message that requests the keyframe.\n\nNow if we allow the keyframe to be lost in transit, then the sender should know that it was lost? (in rtp by receiving RST, I guess?), in which case transport should re-request the keyframe from the encoder.\n\nThis is how it works in our underlying implementation: \n1) we guarantee that keyframe request is delivered to the remote side. We expect this request only once from the decoder, and media transport guarantees its delivery.\n2) Once the encoder on the other side produces the keyframe, we don\u0027t guarantee it will be delivered. But if it isn\u0027t, it\u0027s the responsibility of the transport to re-request the keyframe from the encoder (and not the responsibility of the decoder on the other side).\n\nI did not put much thinking how would this work in group calls, but I think similarly: as long as the keyframe is delivered to the SFU, SFU should now guarantee the delivery of the keyframe. If the keyframe can\u0027t be delivered to the participant, (maybe) it should be SFU to request another keyframe from the sender (because SFU knows that the frame was lost on the way to the receiver!).",
      "parentUuid": "872af556_5570b117",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 62,
        "endChar": 1
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "feb0c498_455e9a8a",
        "filename": "video/encoder_key_frame_callback.h",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-29T15:17:35Z",
      "side": 1,
      "message": "this will be removed once rtp media transport is implemented, right?\nCan you add a // TODO ?",
      "range": {
        "startLine": 25,
        "startChar": 39,
        "endLine": 25,
        "endChar": 61
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8a5abf6_5e6c97a1",
        "filename": "video/encoder_key_frame_callback.h",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-29T15:17:35Z",
      "side": 1,
      "message": "please document.",
      "range": {
        "startLine": 25,
        "startChar": 6,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51f8c7fa_24814a30",
        "filename": "video/encoder_key_frame_callback.h",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a8a5abf6_5e6c97a1",
      "range": {
        "startLine": 25,
        "startChar": 6,
        "endLine": 25,
        "endChar": 29
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "684bc45a_18c8c9ea",
        "filename": "video/encoder_key_frame_callback.h",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:34:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "feb0c498_455e9a8a",
      "range": {
        "startLine": 25,
        "startChar": 39,
        "endLine": 25,
        "endChar": 61
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fd50866b_4b697cdd",
        "filename": "video/video_send_stream_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 245,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-01-29T15:17:35Z",
      "side": 1,
      "message": "note that if we have two video streams, this won\u0027t work and DCHECK.\nShould we allow multiple listeners?",
      "range": {
        "startLine": 245,
        "startChar": 22,
        "endLine": 245,
        "endChar": 48
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b595a34_875a7017",
        "filename": "video/video_send_stream_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 245,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-30T15:34:15Z",
      "side": 1,
      "message": "My thinking is that when adding support for multiple streams, we\u0027ll have a VideoSender object here, which would ideally get this callback at construction time.",
      "parentUuid": "fd50866b_4b697cdd",
      "range": {
        "startLine": 245,
        "startChar": 22,
        "endLine": 245,
        "endChar": 48
      },
      "revId": "abf0222195a0fa3bb38814597374c831d4a85371",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}