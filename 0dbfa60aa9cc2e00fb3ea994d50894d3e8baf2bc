{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e582e119_cf77b7ca",
        "filename": "media/engine/webrtc_video_engine_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 293,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-11-05T08:19:07Z",
      "side": 1,
      "message": "Is it possible to take out this test change to its own cl?",
      "range": {
        "startLine": 293,
        "startChar": 0,
        "endLine": 293,
        "endChar": 57
      },
      "revId": "0dbfa60aa9cc2e00fb3ea994d50894d3e8baf2bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c66b7086_37877934",
        "filename": "media/engine/webrtc_video_engine_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 293,
      "author": {
        "id": 9515
      },
      "writtenOn": "2021-11-05T10:14:34Z",
      "side": 1,
      "message": "-\u003e https://webrtc-review.googlesource.com/c/src/+/237341",
      "parentUuid": "e582e119_cf77b7ca",
      "range": {
        "startLine": 293,
        "startChar": 0,
        "endLine": 293,
        "endChar": 57
      },
      "revId": "0dbfa60aa9cc2e00fb3ea994d50894d3e8baf2bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "107f20f9_d910ce6d",
        "filename": "media/engine/webrtc_video_engine_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 293,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-11-05T11:09:49Z",
      "side": 1,
      "message": "Thanks.",
      "parentUuid": "c66b7086_37877934",
      "range": {
        "startLine": 293,
        "startChar": 0,
        "endLine": 293,
        "endChar": 57
      },
      "revId": "0dbfa60aa9cc2e00fb3ea994d50894d3e8baf2bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8edd68db_6dfecb3f",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 4
      },
      "lineNbr": 76,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-11-05T08:19:07Z",
      "side": 1,
      "message": "I don\u0027t think it\u0027s good practice to capture someone else\u0027s thread/queue via TaskQueueBase::Current(), and use to post work to. It\u0027s better to either uses an explicit constructor argument for the tq to use, or refactor so that the posting happens in the class that owns the queue. If you add a tq argument, you have to consider whether or not to dcheck that that constructor is called on that queue; not sure if that\u0027s something you depend on. It\u0027s usually safe to initialize state in the constructor even if that state is intended to be owned by a different thread.",
      "range": {
        "startLine": 76,
        "startChar": 6,
        "endLine": 76,
        "endChar": 46
      },
      "revId": "0dbfa60aa9cc2e00fb3ea994d50894d3e8baf2bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d592b0f_61eb321b",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 4
      },
      "lineNbr": 76,
      "author": {
        "id": 9515
      },
      "writtenOn": "2021-11-05T10:14:34Z",
      "side": 1,
      "message": "TL;DR - to keep code complexity down I need to post into the same sequence that created this class (and created the VSE).\n\n\u003e I don\u0027t think it\u0027s good practice to capture someone else\u0027s thread/queue via TaskQueueBase::Current(), and use to post work to.\n\nFrom a quick search I see plenty of precedence in the VSE, rtp_rtcp_impl2, rtp_sender_egress, packet_sender, call, nack_requester, bandwidth_quality_scaler... \n\nThe alternatives don\u0027t seem any better to me. Forcing some potentially different queue will either cause thread proliferation + strange destruction sequence, or at best move the TaskQueue::Current() somewhere else. I just don\u0027t see how that\u0027s better.\n\nYou suggested to use the worker thread on the earlier CL, this is the effect. Though, honestly I was planning to do this anyway, just wasn\u0027t sure it\u0027s a good idea for frames in all modes.\n\n\u003e refactor so that the posting happens in the class that owns the queue\n\nThis would cause the VSE would have to call into us to insulate and you\u0027d have the same kind of arguments for that change all over again. The root cause is the threading environment the VSE \u0026 VideoFrameSink live under and those aren\u0027t easy to change.\n\nLater changes will add delay logic to this class so I really do need a target queue here.\n\n\u003e not sure if that\u0027s something you depend on\n\n|safety_| and the target queue for PostTasks (and coming PostDelayedTasks) requires the same thread as ctor/dtor. Using a detached safety would buy me nothing as I do want the worker thread.",
      "parentUuid": "8edd68db_6dfecb3f",
      "range": {
        "startLine": 76,
        "startChar": 6,
        "endLine": 76,
        "endChar": 46
      },
      "revId": "0dbfa60aa9cc2e00fb3ea994d50894d3e8baf2bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b040232_1f2ca4a4",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 4
      },
      "lineNbr": 76,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-11-05T11:09:49Z",
      "side": 1,
      "message": "\u003e TL;DR - to keep code complexity down I need to post into the same sequence that created this class (and created the VSE).\n\u003e \n\u003e \u003e I don\u0027t think it\u0027s good practice to capture someone else\u0027s thread/queue via TaskQueueBase::Current(), and use to post work to.\n\u003e \n\u003e From a quick search I see plenty of precedence in the VSE, rtp_rtcp_impl2, rtp_sender_egress, packet_sender, call, nack_requester, bandwidth_quality_scaler... \n\nI disagree. If we exclude test code and the implementation of task queue and sequence checker, there are about a dozen call sites for TaskQueueBase::Current(), and I hope most of those are about dchecks rather than posting work.\n\nI now see you did add a ::Current call in the VSE constructor in previous cl. Sorry I didn\u0027t speak up, I think that\u0027s wrong for the same reasons. (Using Current for checks is fine, but for posting work I think it\u0027s very questionable). \n\n\u003e The alternatives don\u0027t seem any better to me. Forcing some potentially different queue will either cause thread proliferation + strange destruction sequence, or at best move the TaskQueue::Current() somewhere else. I just don\u0027t see how that\u0027s better.\n\nIf you make it a construction argument, it should be easy for VSE to just pass its worker queue to the constructor, no additional Current call needed? \n\nI think that is better, because it makes the dependency on the VSEs task queue explicit, rather than implicit via the thread local storage location that holds the \"current\" task queue.\n\nYou can keep an RTC_DCHECK(tq_-\u003eIsCurrent()) in constructor and destructor if that is needed, no objection there.\n  \n\u003e You suggested to use the worker thread on the earlier CL, this is the effect.\n\nI still agree that\u0027s an improvement (I just didn\u0027t realize that the VSE doesn\u0027t own uses the questionable ::Current route, rather than creating it or using an explicitly configured queue).",
      "parentUuid": "1d592b0f_61eb321b",
      "range": {
        "startLine": 76,
        "startChar": 6,
        "endLine": 76,
        "endChar": 46
      },
      "revId": "0dbfa60aa9cc2e00fb3ea994d50894d3e8baf2bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33fefc82_fd5ea6cd",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 4
      },
      "lineNbr": 76,
      "author": {
        "id": 9515
      },
      "writtenOn": "2021-11-05T11:30:14Z",
      "side": 1,
      "message": "\u003e I hope most of those are about dchecks rather than posting work.\n\nLook closer, these sites are all stemming from TaskQueueBase::Current():\n- https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/pc/rtp_transceiver.cc;l\u003d135?q\u003drtp_transceiver.cc\u0026ss\u003dchromium\n- https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/video_stream_encoder.cc;l\u003d598?q\u003dvideo_stream_encoder.cc\u0026ss\u003dchromium (beyond my superficial change)\n- https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/video_stream_encoder.cc;l\u003d597;drc\u003d8935a7e8ebb322114a2241f659eb776997fe853e\n- https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/adaptation/encode_usage_resource.cc;l\u003d47;drc\u003d8935a7e8ebb322114a2241f659eb776997fe853e?q\u003dencode_usage_resource.cc\u0026ss\u003dchromium%2Fchromium%2Fsrc\n- https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/audio/channel_receive.cc;l\u003d488;drc\u003d8935a7e8ebb322114a2241f659eb776997fe853e?q\u003dchannel_receive.cc\u0026ss\u003dchromium%2Fchromium%2Fsrc\n- https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/call_stats2.cc;l\u003d94;drc\u003de1712fe5e4cb5af066118968f3d8cb2fc13cb0d3\n- quality scalers\n- \n\n\u003e I now see you did add a ::Current call in the VSE constructor in previous cl. Sorry I didn\u0027t speak up, I think that\u0027s wrong for the same reasons. (Using Current for checks is fine, but for posting work I think it\u0027s very questionable). \n\nI did not add this call :-) it was there since before!\n\n\u003e If you make it a construction argument, it should be easy for VSE to just pass its worker queue to the constructor, no additional Current call needed? \n\nThe VSE doesn\u0027t create the adapter, the VideoSendStream ctor does. This would transport the Current call there - do you think that is better?",
      "parentUuid": "3b040232_1f2ca4a4",
      "range": {
        "startLine": 76,
        "startChar": 6,
        "endLine": 76,
        "endChar": 46
      },
      "revId": "0dbfa60aa9cc2e00fb3ea994d50894d3e8baf2bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8a733871_e076428f",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 4
      },
      "lineNbr": 76,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-11-05T11:56:56Z",
      "side": 1,
      "message": "\u003e The VSE doesn\u0027t create the adapter, the VideoSendStream ctor does. This would transport the Current call there - do you think that is better?\n\nThis is getting more confusing. But yes, I think it would be better if VideoSendStream passed the worker_queue as a construction argument to both VideoCadenceAdapter and the VSE. I don\u0027t see any nearby docs saying which thread is calling the VideoSendStream constructor, but I guess it\u0027s webrtc\u0027s \"worker thread\".\n\nIf we take a step back and look at the current VideoStreamEncoder\u0027s OnFrame method (before you land the CadenceAdapter), my suggestion would be to move ownership of last_captured_timestamp_ and related state not to the worker queue, but to the encoder queue. \n\nOnFrame already has two calls to encoder_queue_-\u003ePostTask(), and it makes sense to me to have it *all* its state updates run on the encoder queue.\n\nAnd it seems like a useless thread hopping to make an extra effort to make sure that it is called on the worker_queue, just to post most of the work on to the encoder queue.\n\nAnd I find this puzzling:\n\n  // Carries out the VideoSourceRestrictions provided by the                               \n  // ResourceAdaptationProcessor, i.e. reconfigures the source of video frames             \n  // to provide us with different resolution or frame rate.                                \n  // This class is thread-safe.                                                            \n  VideoSourceSinkController video_source_sink_controller_\n      RTC_GUARDED_BY(worker_queue_);\n\nIf it is thread safe, why is it guarded by a particular thread/queue? And if use should be single thread, why isn\u0027t it on the encoder queue, which is owned by the VSE?\n\nI\u0027m sorry this seems to get into more refactoring, but to really simplify threading in this class, it would be great of you or hbos (who I imagine is more familiar with the VideoSourceSinkController thing) could have a look at what it would take to move VSE state over to the owned encoder queue, and stop posting tasks to the worker queue.",
      "parentUuid": "33fefc82_fd5ea6cd",
      "range": {
        "startLine": 76,
        "startChar": 6,
        "endLine": 76,
        "endChar": 46
      },
      "revId": "0dbfa60aa9cc2e00fb3ea994d50894d3e8baf2bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}