{
  "comments": [
    {
      "key": {
        "uuid": "3294c37c_78c63bcf",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 1036,
      "author": {
        "id": 7833
      },
      "writtenOn": "2019-01-07T07:40:35Z",
      "side": 1,
      "message": "spelling",
      "range": {
        "startLine": 1036,
        "startChar": 20,
        "endLine": 1036,
        "endChar": 23
      },
      "revId": "22bc7b8211aeee0fc2e5f728168683c46d3cad8d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdc4ddce_2ca859a0",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 1045,
      "author": {
        "id": 7833
      },
      "writtenOn": "2019-01-07T07:40:35Z",
      "side": 1,
      "message": "It\u0027s unclear to me what synchronization is intended here. The flag is set to true unconditionally in RunPostEncode, which will be a nop if the flag already was true. And here, we do something pretty complex.\n\nTo get something that\u0027s more accurate, is it possible to do an atomic increment when deciding to drop a frame, and an atomic decrement-if-non-zero when applying the decision here? Or if it\u0027s ok to sometimes lose the decision to drop a frame, I don\u0027t think we need an atomic compare-and-exchange here either.",
      "range": {
        "startLine": 1041,
        "startChar": 0,
        "endLine": 1045,
        "endChar": 0
      },
      "revId": "22bc7b8211aeee0fc2e5f728168683c46d3cad8d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d862e0a6_40475aeb",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 1045,
      "author": {
        "id": 5524
      },
      "writtenOn": "2019-01-07T08:18:15Z",
      "side": 1,
      "message": "My intention was that it would be fine to occasionally drop a drop.\nI haven\u0027t used std::atomic before, maybe this can be simplified? The intention is just to compare exchange from true to false, and if that succeeded it the flag was true and we do a drop.\n\nWe can do increment instead, though that will require a read first too.",
      "parentUuid": "fdc4ddce_2ca859a0",
      "range": {
        "startLine": 1041,
        "startChar": 0,
        "endLine": 1045,
        "endChar": 0
      },
      "revId": "22bc7b8211aeee0fc2e5f728168683c46d3cad8d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9169b72_7b99fc55",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 1045,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-01-07T09:45:48Z",
      "side": 1,
      "message": "I was thinking of just doing\n\n  result.drop_next_frame \u003d drop_next_frame_.load();\n  drop_next_frame_.store();\n\n(possibly with relaxed memory order), if we don\u0027t aim for any guarantees. Then, we use the atomic to get well defined accesses on platforms where it matters, and silence tsan warnings, but not really guaranteeing anything.\n\nWith a counter, we could do something like\n\n  result.drop_next_frame \u003d (drop_next_frame.fetch_sub(1) \u003e 0);\n  if (!result.drop_next_frame) drop_next_frame.fetch_add(1);  // Undo subtract",
      "parentUuid": "d862e0a6_40475aeb",
      "range": {
        "startLine": 1041,
        "startChar": 0,
        "endLine": 1045,
        "endChar": 0
      },
      "revId": "22bc7b8211aeee0fc2e5f728168683c46d3cad8d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3341d550_dc166748",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 10
      },
      "lineNbr": 1045,
      "author": {
        "id": 5524
      },
      "writtenOn": "2019-01-07T09:52:15Z",
      "side": 1,
      "message": "We currently don\u0027t support more than one callback thread with internal encoders anyway, so I think it\u0027s fine to just read and do a fetch_sub if it\u0027s \u003e 0.",
      "parentUuid": "f9169b72_7b99fc55",
      "range": {
        "startLine": 1041,
        "startChar": 0,
        "endLine": 1045,
        "endChar": 0
      },
      "revId": "22bc7b8211aeee0fc2e5f728168683c46d3cad8d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}