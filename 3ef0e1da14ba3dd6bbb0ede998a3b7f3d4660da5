{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "dc09274c_f7b354d4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-06-19T09:11:14Z",
      "side": 1,
      "message": "This CL fixes this behavior introduced on the new packet buffer and makes it work like the old packet buffer.\n\nIt would be a good idea to add a window in ms to discard old packets and not have to wait until the buffer is full in case a packet is completely lost.",
      "revId": "3ef0e1da14ba3dd6bbb0ede998a3b7f3d4660da5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0611edaf_4700ca11",
        "filename": "modules/video_coding/h26x_packet_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 144,
      "author": {
        "id": 5527
      },
      "writtenOn": "2024-06-20T05:23:52Z",
      "side": 1,
      "message": "Two things:\n\n1) This doesn\u0027t really solve reordering in general. If a keyframe is found then no frames prior to that can be found.\n\n2) AFAICT this completely breaks the packet buffer. In this situation for example:\n\n    1: keyframe\n    2: \u003cpacket lost\u003e\n    3: keyframe\n\nThe keyframe contained in packet 3 would never be found as we would always return here.",
      "range": {
        "startLine": 144,
        "startChar": 13,
        "endLine": 144,
        "endChar": 72
      },
      "revId": "3ef0e1da14ba3dd6bbb0ede998a3b7f3d4660da5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8a61d94_c9ea2fe1",
        "filename": "modules/video_coding/h26x_packet_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 144,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-06-20T08:00:58Z",
      "side": 1,
      "message": "\u003e 1) This doesn\u0027t really solve reordering in general. If a keyframe is found then no frames prior to that can be found.\n\nNot sure exactly what you mean, could you elaborate?\n\n\u003e 2) AFAICT this completely breaks the packet buffer. In this situation for example:\n\u003e\n\u003e1: keyframe\n\u003e2: \u003cpacket lost\u003e\n\u003e3: keyframe\n\u003eThe keyframe contained in packet 3 would never be found as we would always return here.\n\nYes, it you are right. As I said earlier, we should have a reordering window in which we wait for the missing packets and discard the ones that are out of it.\n\nIn absence of this window, we should use the buffer size and advance the `last_continuous_unwrapped_seq_num_` when it gets full, which is not done and causes the issue you describe.\n\nI will try to add this and also unit tests to verify the behaviour",
      "parentUuid": "0611edaf_4700ca11",
      "range": {
        "startLine": 144,
        "startChar": 13,
        "endLine": 144,
        "endChar": 72
      },
      "revId": "3ef0e1da14ba3dd6bbb0ede998a3b7f3d4660da5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d8935ca_0eb741be",
        "filename": "modules/video_coding/h26x_packet_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 144,
      "author": {
        "id": 5527
      },
      "writtenOn": "2024-06-20T09:53:31Z",
      "side": 1,
      "message": "\u003e Not sure exactly what you mean, could you elaborate?\n \nSorry, I thought the test you added wouldn\u0027t pass even with these changes, but now after reading the test again I realize why it works. Just disregard my first comment ðŸ˜Š.\n \n \u003e In absence of this window, we should use the buffer size and advance the...\n \nThe H26XPacketBuffer works like this for a very specific reason. In short the H264/H265 RTP spec does not have any start of frame information, so the only way for a receiver to know if it has received all packets of a frame is to make sure the RTP packet sequence is continuous (all packets have been received).\n\nAFAICT there is no way to solve this using the H264/H265 RTP descriptors. The way I would solve this is by using the DependencyDescriptor.",
      "parentUuid": "c8a61d94_c9ea2fe1",
      "range": {
        "startLine": 144,
        "startChar": 13,
        "endLine": 144,
        "endChar": 72
      },
      "revId": "3ef0e1da14ba3dd6bbb0ede998a3b7f3d4660da5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56e1a0c7_988aaf0c",
        "filename": "modules/video_coding/h26x_packet_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 144,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-06-20T13:44:12Z",
      "side": 1,
      "message": "Just to reword your comment, the issue is detecting the first packet (n) of a frame if the previous two packets have not been received. If the n-1 has been received (with a mark) or the n-2 is is received (without it), we can detect the start of the frame with the rtp timestamp jump.\n\nThe current H26xPacketBuffer tries to detect it based on the SPS/PPS or single nal IDR presence of FU with start packet mark. That would work with the risk of loosing some non-slice nal units.\n\nHowever, the question is if what to do in case of detecting the first packet of an iframe. The current code discards any previous packet, loosing the ability to recover them with subsequent RTX/FEC received packets.\n\nThis CL is incomplete in a way that it does not solve the case in which a rtp packet is completely lost and that\u0027s when we would require a mechanism to discard old non-complete frames either when the queue gets full or after a time window.\n\nMy last questions are that I have been reviewing the old packet buffer code, and it has several functionalities not included in the new H26XPacketBuffer, like the possibility or recovering out of order full frames, or detecting seq number jumps. I would assume that the new H26XPacketBuffer should provide similar functionality.",
      "parentUuid": "4d8935ca_0eb741be",
      "range": {
        "startLine": 144,
        "startChar": 13,
        "endLine": 144,
        "endChar": 72
      },
      "revId": "3ef0e1da14ba3dd6bbb0ede998a3b7f3d4660da5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c22f576c_2fc7af05",
        "filename": "modules/video_coding/h26x_packet_buffer_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 1058,
      "author": {
        "id": 5527
      },
      "writtenOn": "2024-06-20T05:23:52Z",
      "side": 1,
      "message": "Please write out these comments with regular text, or just remove them. This syntax is not really related to these tests.",
      "range": {
        "startLine": 1058,
        "startChar": 2,
        "endLine": 1058,
        "endChar": 46
      },
      "revId": "3ef0e1da14ba3dd6bbb0ede998a3b7f3d4660da5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee8979c3_1289aecf",
        "filename": "modules/video_coding/h26x_packet_buffer_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 1058,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-06-20T08:00:58Z",
      "side": 1,
      "message": "ups, yes, I was only adding the test to compare to the test I added to the packet_buffer_unittest, will remove.",
      "parentUuid": "c22f576c_2fc7af05",
      "range": {
        "startLine": 1058,
        "startChar": 2,
        "endLine": 1058,
        "endChar": 46
      },
      "revId": "3ef0e1da14ba3dd6bbb0ede998a3b7f3d4660da5",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}