{
  "comments": [
    {
      "key": {
        "uuid": "6aecb778_33d4f0f6",
        "filename": "call/rtp_demuxer.cc",
        "patchSetId": 21
      },
      "lineNbr": 218,
      "author": {
        "id": 5019
      },
      "writtenOn": "2020-05-29T17:08:33Z",
      "side": 1,
      "message": "actually... is it correct?\nyou know that ssrc is mapped becaues there is/was one payload_type for it.\nand you know that one of the new payload types should makes some sink ambiguous.\nbut how ssrc \u003d sink_by_ssrc.first is related to payload_type?",
      "range": {
        "startLine": 218,
        "startChar": 8,
        "endLine": 218,
        "endChar": 20
      },
      "revId": "1eb2c438d2a941565f11c0616bb3842d0ad568b1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1201f8c5_0b5cff3e",
        "filename": "call/rtp_demuxer.cc",
        "patchSetId": 21
      },
      "lineNbr": 218,
      "author": {
        "id": 6305
      },
      "writtenOn": "2020-06-01T14:00:58Z",
      "side": 1,
      "message": "There is a check at the very beginning of lambda which checks that ssrc binding inside `sink_by_ssrc_` was created due payload type resolution of sink. So only such bindings in `sink_by_ssrc_` checked for ambiguity and the only modified payload types are checked. So if `sinks_by_pt_` has multiple sinks for a payload type and ssrc binding in `sink_by_ssrc_` was created due payload type resolution, then \"ssrc binding\" in `sink_by_ssrc_` became ambiguous and need to be removed.",
      "parentUuid": "6aecb778_33d4f0f6",
      "range": {
        "startLine": 218,
        "startChar": 8,
        "endLine": 218,
        "endChar": 20
      },
      "revId": "1eb2c438d2a941565f11c0616bb3842d0ad568b1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3932affc_73e56342",
        "filename": "call/rtp_demuxer.cc",
        "patchSetId": 21
      },
      "lineNbr": 218,
      "author": {
        "id": 5019
      },
      "writtenOn": "2020-06-01T14:24:58Z",
      "side": 1,
      "message": "scenario I was thinking about:\npt 90 -\u003e sink1\npt 91 -\u003e sink2\narrived packet with pt 90 and ssrc 1234. created a mapping pt90 -\u003e ssrc 1234\n// a new mapping added:\npt 91 -\u003e sink3\n\nnow code starts iterating and finds entry\nsink_by_ssrc.second.ssrc \u003d\u003d 1234 \u0026 sink_by_ssrc.second.origin \u003d\u003d ResolvedByType\nthen code iterate through updated_payload_types and finds sinks_by_pt_.count(91) \u003e 1\nCode makes conclusion that mapping for ssrc 1234 should be deleted now (even though that particular mapping is still unambiguous)\n\n\nTechnically it shouldn\u0027t be an issue to delete such mapping: next packet with p90 and ssrc 1234 would just recreate it. But then it is possible to make this code simpler (and faster):\n\nbool new_ambigious_payload_types \u003d false;\nfor (int payload_type : updated_payload_types) {\n  if (sinks_by_pt_.count(payload_type) \u003d\u003d 2) {\n    new_ambigious_payload_types \u003d true;\n    break;\n  } \n}\n\nif (new_ambigious_payload_types) {\n  RemoveFromMapIf(sink_by_ssrc_, [\u0026](const auto\u0026 sink_by_ssrc) {\n    return sink_by_ssrc.second.origin \u003d\u003d SsrcBinding::Origin::kResolvedByPayloadType; });\n}",
      "parentUuid": "1201f8c5_0b5cff3e",
      "range": {
        "startLine": 218,
        "startChar": 8,
        "endLine": 218,
        "endChar": 20
      },
      "revId": "1eb2c438d2a941565f11c0616bb3842d0ad568b1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6acfdac1_23bcb050",
        "filename": "call/rtp_demuxer.cc",
        "patchSetId": 21
      },
      "lineNbr": 218,
      "author": {
        "id": 6305
      },
      "writtenOn": "2020-06-01T16:09:21Z",
      "side": 1,
      "message": "Thank you very much, that\u0027s a very nice catch. I actually did not want to remove binding, if it is not became ambiguous due to change, because I think it might break the following requirement from spec:\n```\n   Note that when using the payload type to associate RTP streams with\n   \"m\u003d\" sections an RTP stream, identified by its SSRC, will be mapped\n   to an \"m\u003d\" section when the first packet of that RTP stream is\n   received, and the mapping will not be changed even if the payload\n   type used by that RTP stream changes.  In other words, the SSRC\n   cannot \"move\" to a different \"m\u003d\" section simply by changing the\n   payload type.\n```\n\nI\u0027ve added unit test with the scenario you\u0027ve described and fixed implementation such that it now passes test.\nIt might look like a performance regression, since previous change set. But as far as I understand `AddSink` and hence `RemoveAmbiguousSsrcBindingsResolvedByPayloadType` only called when something is changed due signaling, which is relatively rare compared to receive packets rate.\n\nThank you very much Danil!",
      "parentUuid": "3932affc_73e56342",
      "range": {
        "startLine": 218,
        "startChar": 8,
        "endLine": 218,
        "endChar": 20
      },
      "revId": "1eb2c438d2a941565f11c0616bb3842d0ad568b1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}