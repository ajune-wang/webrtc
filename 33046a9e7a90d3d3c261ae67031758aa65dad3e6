{
  "comments": [
    {
      "key": {
        "uuid": "354a0e70_28858134",
        "filename": "call/call.cc",
        "patchSetId": 5
      },
      "lineNbr": 470,
      "author": {
        "id": 5524
      },
      "writtenOn": "2020-05-25T12:48:44Z",
      "side": 1,
      "message": "What happens wrt this move if ref_count_ goes 0-\u003e1-\u003e2-\u003e1-\u003e2-\u003e1-\u003e0 ?\nWill the callback do the right thing if ref_count goes back up?",
      "range": {
        "startLine": 470,
        "startChar": 27,
        "endLine": 470,
        "endChar": 31
      },
      "revId": "33046a9e7a90d3d3c261ae67031758aa65dad3e6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "472b17b3_34387fcb",
        "filename": "call/call.cc",
        "patchSetId": 5
      },
      "lineNbr": 470,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-05-25T13:55:50Z",
      "side": 1,
      "message": "When the object is constructed inside of Create(), the refcount goes up to 1.\n\nSo if Create() is called and then immediately the object is freed, we hit the \u003d\u003d0 case above. Only the creator of the object gets to specify a callback and the purpose of the callback is to know when the creator is again the only remaining owner of a reference.\n\nIn theory though, if A calls Create, hands a reference to B, then A calls Release() (before B), then we get here, execute the callback, and now B owns the last reference.\nIf A does something to the variable that it\u0027s in the middle of freeing, then yes there\u0027d be a problem, but that\u0027s like calling a method of a derived class from the destructor of a parent class - it\u0027s possible, but not a good idea ðŸ˜Š Regardless, it should crash consistently in such a case. A would also need to specifically be designed to do one thing in the callback and a contradictory thing outside the callback.",
      "parentUuid": "354a0e70_28858134",
      "range": {
        "startLine": 470,
        "startChar": 27,
        "endLine": 470,
        "endChar": 31
      },
      "revId": "33046a9e7a90d3d3c261ae67031758aa65dad3e6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6d5c7969_51c74d60",
        "filename": "call/call.cc",
        "patchSetId": 5
      },
      "lineNbr": 470,
      "author": {
        "id": 5524
      },
      "writtenOn": "2020-05-25T15:35:31Z",
      "side": 1,
      "message": "Ah, I got confused. This isn\u0027t called when there is only one remaining Call instance - it\u0027s when there is only the ref from CallFactory. Never mind about that then. ðŸ˜Š\n\nOne last comment though. If I understand it correctly, the lambda would reset the last ref counted instance which calls Release() and thus returns at L466. So when the lambda returns, |this| will have been deleted?\nI assume then that the kOtherRefsRemained return value doesn\u0027t hurt because the call site won\u0027t try to delete the already deleted instance.\nShould there be a comment warning that no member of this class must be referenced after calling moved_fn()?",
      "parentUuid": "472b17b3_34387fcb",
      "range": {
        "startLine": 470,
        "startChar": 27,
        "endLine": 470,
        "endChar": 31
      },
      "revId": "33046a9e7a90d3d3c261ae67031758aa65dad3e6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e7d448e_90487f27",
        "filename": "call/call.cc",
        "patchSetId": 5
      },
      "lineNbr": 470,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-05-25T15:45:16Z",
      "side": 1,
      "message": "Yes, I\u0027ll add a comment to make that clear.",
      "parentUuid": "6d5c7969_51c74d60",
      "range": {
        "startLine": 470,
        "startChar": 27,
        "endLine": 470,
        "endChar": 31
      },
      "revId": "33046a9e7a90d3d3c261ae67031758aa65dad3e6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}