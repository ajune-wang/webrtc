{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "957196a3_c60d2577",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5825
      },
      "writtenOn": "2024-11-28T14:13:49Z",
      "side": 1,
      "message": "Can we use pre-encoded bitstreams instead? I think it would be easer to maintain bitstreams than this rather non-trivial generator. Wrap bitstreams into IVFs. Fake encoder can read frames from IVF and deliver them.",
      "revId": "b808107f7fd3012cce70534bf450613c3c2ec6fe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e601aec_2a9700a0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 18005
      },
      "writtenOn": "2024-11-28T14:38:29Z",
      "side": 1,
      "message": "- A fixed bitstream will not be able to emulate exactly the behavior of key-frame request and bitrate adjustment request from WebRTC stack.\n- Also it is not easy to emulate L1T2/L1T3.\n- I also want to use this builder to create different combination of NALUs, for example, IDR/Trail with Fd/Aud/Prefix-SEI/EOS/EOB NALU, to watch/test the depacketizer behavior and jitter buffer behavior on packet loss.\n- Finally I want to check how the video bitrate allocation module allocates bitrate among temporal layers and simulcast layers. We have TODOs to experiment out a better bitrate allocation for H.265 instead of reusing VP9 settings.\n\nThat\u0027s why I want to use a fake-encoder that dynamically changes bitrate/temporal layer settings on-demand, and allows combination of NALUs to mimic HW encoder behavior.",
      "parentUuid": "957196a3_c60d2577",
      "revId": "b808107f7fd3012cce70534bf450613c3c2ec6fe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "375d4f6b_fe100edb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5825
      },
      "writtenOn": "2024-11-28T15:37:32Z",
      "side": 1,
      "message": "Looks like an overengineering to me.\n\n\u003e A fixed bitstream will not be able to emulate exactly the behavior of key-frame request and bitrate adjustment request from WebRTC stack.\n\nWhat exactly you want to test? Could you please share some example? Component, input, expectation...\n\n\u003e Also it is not easy to emulate L1T2/L1T3.\n\nWe can have bitstreams with temporal layering. Or what is the problem here?\n\n\u003e I also want to use this builder to create different combination of NALUs..\n\nWould having a set of hardcoded NALUs (which you can combine in the tests) work? How often do you think you will need to update/add new combinations? I guess that will be done ~once. Adding dedicated generators for this doesn\u0027t sound necessary. It will be a dead code.\n\n\u003e Finally I want to check how the video bitrate allocation module allocates bitrate\n\nWhy would testing of rate allocation need ~real NALUs?",
      "parentUuid": "4e601aec_2a9700a0",
      "revId": "b808107f7fd3012cce70534bf450613c3c2ec6fe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e6c405f_de1bcbe5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 18005
      },
      "writtenOn": "2024-11-29T01:34:57Z",
      "side": 1,
      "message": "\u003e Looks like an overengineering to me.\n\nI must acknowledge the overhead of this is much larger than a file-based fake encoder.\n\n\u003e \n\u003e \u003e A fixed bitstream will not be able to emulate exactly the behavior of key-frame request and bitrate adjustment request from WebRTC stack.\n\u003e \n\u003e What exactly you want to test? Could you please share some example? Component, input, expectation...\n\nExamples:\n1. The bandwidth-based quality scaler in WebRTC stack. Input to it will be manually controlled actual-output-bitrates from the fake encoder. Expectation is that when encoder output bitrate is overshooting or undershooting, resolution is changing as expected over timespan, any adjustment to the quality-scaler resolution switching threshold needed.  - But perhaps this can be simulated with unittest on the bandwidth-based quality scaler itself. The fake encoder just make it more flexible if this is not a one-time tuning effort.\n2. Integration test/tuning with the Chromium H.26x SW BRC. Input to the H.26x SW BRC will be the fake H.265 encoded bitstream that roughly aligns with BWE estimation by RTC stack, with configurable bitrate deviation per-test configuration. Expectation is to verify the H.26x SW BRC\u0027s frame-dropping logic works well on bitrate overshot.\n\n\n\u003e \n\u003e \u003e Also it is not easy to emulate L1T2/L1T3.\n\u003e \n\u003e We can have bitstreams with temporal layering. Or what is the problem here?\n\nMy concern is that a fixed temporal layering stream will not produce output temporal-layer bitrates aligning with what the BWE and bitrate allocator requested. In that case, RTC stack may reduce/increase simulcast stream layers with a fixed pattern. With that I cannot experiment/adjust the threshold tables I placed in simulcast.cc for H.265.\n\n\u003e \n\u003e \u003e I also want to use this builder to create different combination of NALUs..\n\u003e \n\u003e Would having a set of hardcoded NALUs (which you can combine in the tests) work? How often do you think you will need to update/add new combinations? I guess that will be done ~once. Adding dedicated generators for this doesn\u0027t sound necessary. It will be a dead code.\n\nThat I agree is just a one-time effort. If there is a need, we may just add unittests in corresponding modules.\n\n\u003e \n\u003e \u003e Finally I want to check how the video bitrate allocation module allocates bitrate\n\u003e \n\u003e Why would testing of rate allocation need ~real NALUs?\n\nBitrate allocation and the encoder output rate is a feedback-loop . A file-base fake encoder will not change its encoding bitrate according to input from bitrate allocation module. But this fake encoder will be able to produce bitstream aligning with rate allocator requests.\nTo be honest, I don\u0027t see real issue with the rate allocation for now.\n\nAnyway, with a file-based fake encoder, at least we will be able to unblock the end-to-end integration tests for H.265, which is the #1 reason I need a fake encoder. For that I won\u0027t insist on having a encoder that produces ~real NALUs, as long as Chromium receiver-side H.265 parser is satisfied with the incoming bitstream.",
      "parentUuid": "375d4f6b_fe100edb",
      "revId": "b808107f7fd3012cce70534bf450613c3c2ec6fe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aefb8ed3_307f863e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5142
      },
      "writtenOn": "2024-12-05T14:02:21Z",
      "side": 1,
      "message": "CC eshr do you have a take on the need for this?",
      "revId": "b808107f7fd3012cce70534bf450613c3c2ec6fe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a2d2351_53f4e56e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5825
      },
      "writtenOn": "2024-12-05T15:50:29Z",
      "side": 1,
      "message": "On testing components that depends on encoded bitrate. Do they even need bitstream?",
      "parentUuid": "6e6c405f_de1bcbe5",
      "revId": "b808107f7fd3012cce70534bf450613c3c2ec6fe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bef50b72_9a15b31c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 5825
      },
      "writtenOn": "2024-12-05T15:50:29Z",
      "side": 1,
      "message": "For testing rate control, bandwidth-based quality scaler, etc (whatever needs encoded bitrate), frame sizes + some metadata (frame type, etc) should be sufficient.\n\nFor testing parsers on receiver side hardcoded bitstreams should work.\n\nFor end-to-end testing I suggest we use real encoders. HW H265 is available on Chromium/WebRTC Android test bots.",
      "parentUuid": "6e6c405f_de1bcbe5",
      "revId": "b808107f7fd3012cce70534bf450613c3c2ec6fe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "35ee45f2_172e91dd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 7
      },
      "lineNbr": 0,
      "author": {
        "id": 18005
      },
      "writtenOn": "2024-12-06T02:08:30Z",
      "side": 1,
      "message": "I\u0027m OK to archive this builder and not seek for a merging into WebRTC code base for now.\n\n@ssilkin@webrtc.org I\u0027ll keep this in WIP status in case someone needs that.",
      "parentUuid": "bef50b72_9a15b31c",
      "revId": "b808107f7fd3012cce70534bf450613c3c2ec6fe",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}