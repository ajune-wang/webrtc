{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "18d9f73d_8cb3ecf8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12359
      },
      "writtenOn": "2021-09-13T14:08:36Z",
      "side": 1,
      "message": "Hi Harald, any chance you can take a look at this?",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ea0f0751_3b2e063f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-13T14:50:32Z",
      "side": 1,
      "message": "Adding danilchap@ as reviewer, since he did some bit stuff here recently.\n\nA bunch of questions here ... I would very much like to see at least one usage of the function in the same CL, since some of the questions are dependent on the context in which it is intended to be used.",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4aeadd81_57e0541e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-09-13T15:29:17Z",
      "side": 1,
      "message": "I\u0027m currently migrating all webrtc bit parsers from BitBuffer to BitstreamReader\nwith intent to deprecate and then delete BitBuffer.\n(BitstreamReader allows to write more compact parsers, both in code and in binary size)\n\nAs such I prefer not to add more functions to the BitBuffer.\n\nIt seems to me H264 specific function \u0027more_rbsp_data()\u0027 can be implemented without adding anything extra to the buffer reader class itself. e.g. with BitstreamReader it could look like:\n\n  bool MoreRbspData(BitstreamReader reader) {\n    // Take reader by value to avoid modifying original reader\n    int remaining_bits \u003d reader.RemainigBitcount();\n    if (remaining_bits \u003c\u003d 0) return false;\n    // rbsp_trailing_bits can\u0027t take more than a byte.\n    if (remaining_bits \u003e 8) return true;\n    uint64_t remaining \u003d reader.ReadBits(remaining_bits);\n    RTC_DCHECK(reader.Ok());\n    bool is_rbsp_trailing_bits \u003d (remaining \u003d\u003d (1 \u003c\u003c (remaining_bits - 1)));\n    return !is_rbsp_trailing_bits;\n  }\n\n",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8d7ae84f_1bf177b3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12359
      },
      "writtenOn": "2021-09-14T19:00:12Z",
      "side": 1,
      "message": "Thanks for the review",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b9bf55ec_b7f38c5d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 12359
      },
      "writtenOn": "2021-09-14T19:00:12Z",
      "side": 1,
      "message": "I read Danil\u0027s solution, and it should be equivalent to the standard definition. Therefore I\u0027m abandoning this patch. \n\nOnly minor issue with the solution is that it is reading the bits, and we probably want to just peek them: `more_rbsp_data()` is a const function. \n\nThis raises a second (also minor) issue, which is that `BitBuffer::PeekBits()` is not declared `const`. Is this intended?\n\nI added a full solution in the original user (h264nal): https://github.com/chemag/h264nal/commit/fbaf983959b7894fc29cbd080afc53d6196fc7c2\n\nThanks for the review!",
      "parentUuid": "4aeadd81_57e0541e",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c8d6460d_4402f21e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-09-15T08:43:15Z",
      "side": 1,
      "message": "yes, more_rbsp_data() should peek, not read, shouldn\u0027t modify original bit reader\n(and yep, BitBuffer::PeekBits() should probably be const)\n\nThe example I\u0027ve provided uses BitstreamReader, not BitBuffer.\nBitstreamReader doesn\u0027t have PeekBits function, instead peeking is done by taking copy of the BitstreamReader object, reading from that copy, then discarding it.\n(See https://source.chromium.org/chromium/_/webrtc/src.git/+/7ca630f8dd0c1c8179a635660c0265bb5f4ea179:rtc_base/bitstream_reader_unittest.cc;l\u003d233;drc\u003d5af152c214987f55b747cdb407546b0625da6802 )",
      "parentUuid": "b9bf55ec_b7f38c5d",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ccfb5eba_32c99c73",
        "filename": "rtc_base/bit_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 254,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-13T14:50:32Z",
      "side": 1,
      "message": "Why is the bit_val an uint_32? A bool would seem like a more natural represnetation.",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a74de19_647c5264",
        "filename": "rtc_base/bit_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 256,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-13T14:50:32Z",
      "side": 1,
      "message": "The current guidance in the style guide is to use reference arguments as output parameters, not pointers.",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6fd47341_3cb267e1",
        "filename": "rtc_base/bit_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 259,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-13T14:50:32Z",
      "side": 1,
      "message": "This scans through the whole buffer, disregarding the byte and bit offsets of the current read position. Is this what you want to achieve?",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab2d06d3_b7ed88ba",
        "filename": "rtc_base/bit_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 263,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-13T14:50:32Z",
      "side": 1,
      "message": "I\u0027d suggest using absl::CountTrailingZeroes if all the usages are zero-counting. That reduces to a native machine instruction on any architectures.",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a29aaa8_02ed8b59",
        "filename": "rtc_base/bit_buffer.h",
        "patchSetId": 1
      },
      "lineNbr": 40,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-13T14:50:32Z",
      "side": 1,
      "message": "This name is a bit confusing. I\u0027d suggest using CountTrailingZeroes and CountTrailingOnes exposed in the .h file, and merging the implementations in the .cc file.\n\nNote that BitBuffer does not have any way to have an odd number of bits in the last byte. This may or may not matter; the usage will determine this.",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f51c938f_ddffe5ed",
        "filename": "rtc_base/bit_buffer_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 214,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-13T14:50:32Z",
      "side": 1,
      "message": "I would recommend not using __LINE__ to identify the test. It is impossible for the casual reader to figure out what these test cases represent. Instead, use a string describing how this particular test datum is different from the others - like \"five trailing zero bits\" or \"nine trailing zero bits\".",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "243a8890_e94297da",
        "filename": "rtc_base/bit_buffer_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 223,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-13T14:50:32Z",
      "side": 1,
      "message": "You only test trailing zeroes here. Since you have an argument to the function, you need to have tests for trailing ones as well. If you keep the non-bool argument format, you also need tests for values different from 0 or 1.",
      "revId": "c9bff098d0eb5341dc996fbcb207185ac36f93de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}