{
  "comments": [
    {
      "key": {
        "uuid": "b17efb55_08202d64",
        "filename": "test/task_runner/task_runner.h",
        "patchSetId": 5
      },
      "lineNbr": 81,
      "author": {
        "id": 6337
      },
      "writtenOn": "2019-02-06T13:11:53Z",
      "side": 1,
      "message": "Please document provided guarantees for memory access order and task execution",
      "range": {
        "startLine": 81,
        "startChar": 19,
        "endLine": 81,
        "endChar": 29
      },
      "revId": "e284df5e310311294b22bcfd1ed15f1284db9ea6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "07c7d062_7a4e6a39",
        "filename": "test/task_runner/task_runner.h",
        "patchSetId": 5
      },
      "lineNbr": 138,
      "author": {
        "id": 6337
      },
      "writtenOn": "2019-01-31T13:59:08Z",
      "side": 1,
      "message": "Which tasks will do it?\nAlso should all tasks, that are running by this runner be destroyed first?",
      "range": {
        "startLine": 138,
        "startChar": 39,
        "endLine": 138,
        "endChar": 74
      },
      "revId": "e284df5e310311294b22bcfd1ed15f1284db9ea6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13f28e10_03d95eb9",
        "filename": "test/task_runner/task_runner.h",
        "patchSetId": 5
      },
      "lineNbr": 138,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-31T14:07:23Z",
      "side": 1,
      "message": "Any task that posts a task will use the impl_.\n\nThey are destroyed when the implementation is destroyed (that is how we can avoid requiring locks in TaskQueue implementations)",
      "parentUuid": "07c7d062_7a4e6a39",
      "range": {
        "startLine": 138,
        "startChar": 39,
        "endLine": 138,
        "endChar": 74
      },
      "revId": "e284df5e310311294b22bcfd1ed15f1284db9ea6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d43be1ee_fc5433c8",
        "filename": "test/task_runner/task_runner_interface.h",
        "patchSetId": 5
      },
      "lineNbr": 25,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-01-31T14:09:35Z",
      "side": 1,
      "message": "will it possible to use std::function\u003cvoid()\u003e instead of this interface?",
      "range": {
        "startLine": 25,
        "startChar": 6,
        "endLine": 25,
        "endChar": 26
      },
      "revId": "e284df5e310311294b22bcfd1ed15f1284db9ea6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32ccfd23_79fa339d",
        "filename": "test/task_runner/task_runner_interface.h",
        "patchSetId": 5
      },
      "lineNbr": 25,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-31T14:23:21Z",
      "side": 1,
      "message": "I\u0027d like to, but std::function is copyable: it can\u0027t take ownership of movable only types.",
      "parentUuid": "d43be1ee_fc5433c8",
      "range": {
        "startLine": 25,
        "startChar": 6,
        "endLine": 25,
        "endChar": 26
      },
      "revId": "e284df5e310311294b22bcfd1ed15f1284db9ea6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "06498021_a1d1b451",
        "filename": "test/task_runner/task_runner_interface.h",
        "patchSetId": 5
      },
      "lineNbr": 39,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-01-31T14:09:35Z",
      "side": 1,
      "message": "What is missing in rtc_base/repeating_task.h to generate new interfaces ?",
      "range": {
        "startLine": 39,
        "startChar": 6,
        "endLine": 39,
        "endChar": 28
      },
      "revId": "e284df5e310311294b22bcfd1ed15f1284db9ea6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e1f6ad1_81cae093",
        "filename": "test/task_runner/task_runner_interface.h",
        "patchSetId": 5
      },
      "lineNbr": 39,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-31T14:23:21Z",
      "side": 1,
      "message": "It\u0027s closely coupled with the TaskQueue api and a QueuedTask has a return value controlling ownership, something that\u0027s avoided here. It might make sense to base that implementation on this though.",
      "parentUuid": "06498021_a1d1b451",
      "range": {
        "startLine": 39,
        "startChar": 6,
        "endLine": 39,
        "endChar": 28
      },
      "revId": "e284df5e310311294b22bcfd1ed15f1284db9ea6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1cc31099_3d5a8afe",
        "filename": "test/task_runner/task_runner_interface.h",
        "patchSetId": 5
      },
      "lineNbr": 45,
      "author": {
        "id": 5019
      },
      "writtenOn": "2019-01-31T14:09:35Z",
      "side": 1,
      "message": "This looks very similar to the TaskQueue interface, but using different vocabulary.\ncan you just use webrtc::TaskQueueBase interface instead?)",
      "range": {
        "startLine": 45,
        "startChar": 6,
        "endLine": 45,
        "endChar": 29
      },
      "revId": "e284df5e310311294b22bcfd1ed15f1284db9ea6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "08be4356_35f43c28",
        "filename": "test/task_runner/task_runner_interface.h",
        "patchSetId": 5
      },
      "lineNbr": 45,
      "author": {
        "id": 5531
      },
      "writtenOn": "2019-01-31T14:23:21Z",
      "side": 1,
      "message": "I\u0027ts quite different, I\u0027d have hoped that it could become cleaner, but currently it uses ownership controlling QueuedTask class, has some reference counting scheme, hidden internal pointers (int the interface) and Delete() etc.\n\nMaybe when you are done with that refactoring it will look like this class?",
      "parentUuid": "1cc31099_3d5a8afe",
      "range": {
        "startLine": 45,
        "startChar": 6,
        "endLine": 45,
        "endChar": 29
      },
      "revId": "e284df5e310311294b22bcfd1ed15f1284db9ea6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94ee77a0_04f37585",
        "filename": "test/task_runner/task_runner_interface.h",
        "patchSetId": 5
      },
      "lineNbr": 45,
      "author": {
        "id": 6337
      },
      "writtenOn": "2019-02-06T13:11:53Z",
      "side": 1,
      "message": "Why we need interface with no public methods?",
      "range": {
        "startLine": 45,
        "startChar": 6,
        "endLine": 45,
        "endChar": 29
      },
      "revId": "e284df5e310311294b22bcfd1ed15f1284db9ea6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}