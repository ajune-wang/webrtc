{
  "comments": [
    {
      "key": {
        "uuid": "07a7b04c_67d31a5d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 5492
      },
      "writtenOn": "2020-08-27T10:30:32Z",
      "side": 1,
      "message": "Adding Ilya for media/engine",
      "revId": "39c72326e9a7bdaf4eaf1d57fd7d3eeea4280437",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4a7db896_e552193e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-08-27T13:01:24Z",
      "side": 1,
      "message": "So, the idea here is to ensure that we report to the source the alignment in such a way, that after applying provided scale factors, all layers have resolutions still divisible by the required value? I.e. alignment/scale_factor is an integer multiple of an encoder reported value, right?\n\nSo, if user requests scale resolution down by 4.0, and we want the result to be even, we want reported to the source alignment \u003d 8, right?\n\nIt would be a very easy problem if the scale factors were given as rationals and we could request arbitrary alignments. Sadly, the problem you are solving is much more difficult or even impossible to solve in all cases.\n\nBecause we can\u0027t ask the capturer to provide resolutions divisible by e.g. 210, even if the user requests scale_resolution_down\u003d{3.0, 5.0, 7.0} while encoder requires even resolutions, you also have to adjust scaling logic in simulcast_encoder_adapter to incorporate cropping there to the nearest multiple of required alignment.\n\nAfter that, the problem could be reduced to finding such a value x, what x/scale_factor[i] are as close as possible to integers, divisible by a given encoder requirement and x is not too big.\n\nI believe, the best metric here would be to require as few layers to do cropping as possible, with more penalty for higher layers.\n\nThis could be done like that:\n\nbest_alignment \u003d requested_alignment;\nbest_diff \u003d std::numeric_limits\u003cfloat\u003e::infinity();\nfor (alignment \u003d 1; alignment \u003c kMaxAlignment; ++alignment) {\n  current_diff \u003d 0.0;\n  for (i \u003d 0; i \u003c num_layers; ++i) {\n     // if we ask source to provide resolution divisible by alignment,\n     // scaled down would be multiple of this.\n     adjusted_scale \u003d alignment / scale_down_by[i];\n     int closest_target \u003d (int)adjusted_scale;\n     closest_target -\u003d closest_target % requested_alignment;\n     // add penalty if the final adjusted_scale isn\u0027t integer, divisible by requested_alignment.\n     current_diff +\u003d (abs(closest_target - adjusted_scale) \u003e 1e-9) ? 1+(i+1)/100.0 : 0; \n  }\n  if (current_diff \u003c best_diff) {\n    best_diff \u003d current_diff;\n    best_alignment \u003d alignment;\n  }\n}\nreturn best_alignment;  // no multiplication by requested_alignment!\n\n\nI believe, this solution is simpler and more suitable to what the users would want.\n\nIn some easy cases, like scale_down\u003d{1,2,4} and even resolutions for encoders, it would easily find 8 as an alignment with the best_diff \u003d 0. In case {1.5, 2.5}, even result - it would request resolution divisible by 15. Then if scaled down by 3/2, 5/2, the result would be even, as requested!\nThis should also work in the weird case above. If the user requests {3,5,7} scaling factors and encoder requests even resolution, it should find alignment of 30 or 6, depending on how large is kMaxAlignment. This would require cropping only on the lowest or two lower layers. The cropping on the lowest layer will always be required, unless the input resolution happens to be divisible by 210, which we can\u0027t realistically require. You can change the metric if you believe other trade-offs are better.\n\nThe best way to incorporate the cropping is to adjust the logic in [1] and [2] to configure encoders with resolutions, divisible by required alignment. Then, simulcast_encoder_adapter should do scaling and cropping to configured resolution. If the required alignment is not available in [1],[2], then you should have some logic in simulcast_encoder_adapter. \n\nAt the very least, scaling logic should not round the resulting resolution down, but to the closer integer value, while doing scaling.\n\n\nFinally, maybe a better approach would be to simply make your encoder to request not 2, but e.g. 8 as an alignment on the top layer if you plan to make it work only with a fixed set of scale factors?\n\n\n[1]\nhttps://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/media/engine/webrtc_video_engine.cc;l\u003d3540;drc\u003dc55e24acc766704338e5432a2159548ef266d251\n\n[2] https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/media/engine/webrtc_video_engine.cc;l\u003d3446;drc\u003dc55e24acc766704338e5432a2159548ef266d251",
      "revId": "39c72326e9a7bdaf4eaf1d57fd7d3eeea4280437",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b9ecbca5_79c2306a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-08-27T13:43:07Z",
      "side": 1,
      "message": "To clarify: There are two things I really don\u0027t like about the current implementation:\n\n1) It changes configures scaling factors. This is not according to spec. I understand, cropping image here and there by 1 pixels if encoder doesn\u0027t support odd resolutions (as it\u0027s done now), but if the user requests scaling factors {7, 3.333} it would be bad to instead scale down to {7, 3.5}.\n\n2) It seems overly complicated for the task you are solving.\n\n\nI\u0027m probably missing some design reasons behind 1). Maybe my understanding is wrong, please provide your reasoning.\n\nThen, after we are on the same page about how the solution should work, let\u0027s thing about making it simpler.\n",
      "revId": "39c72326e9a7bdaf4eaf1d57fd7d3eeea4280437",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "02f69731_b7ce6c19",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 11
      },
      "lineNbr": 706,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-08-27T13:01:24Z",
      "side": 1,
      "message": "This would be better placed at L847, right before the place where it\u0027s actually used.",
      "range": {
        "startLine": 706,
        "startChar": 2,
        "endLine": 706,
        "endChar": 17
      },
      "revId": "39c72326e9a7bdaf4eaf1d57fd7d3eeea4280437",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "10074e2d_1c9ec505",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 11
      },
      "lineNbr": 706,
      "author": {
        "id": 5492
      },
      "writtenOn": "2020-09-17T07:12:28Z",
      "side": 1,
      "message": "Needs to be called before CreateEncoderStreams since scale factors can be adjusted. Also moved alignment code to separate class as discussed offline.",
      "parentUuid": "02f69731_b7ce6c19",
      "range": {
        "startLine": 706,
        "startChar": 2,
        "endLine": 706,
        "endChar": 17
      },
      "revId": "39c72326e9a7bdaf4eaf1d57fd7d3eeea4280437",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7abd8619_3ed77f2d",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 11
      },
      "lineNbr": 706,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-09-17T11:16:50Z",
      "side": 1,
      "message": "nit: Please rename the function to |GetAlignmentAndAdjustScaleFactors|, so that it\u0027s really clear that this function does.",
      "parentUuid": "10074e2d_1c9ec505",
      "range": {
        "startLine": 706,
        "startChar": 2,
        "endLine": 706,
        "endChar": 17
      },
      "revId": "39c72326e9a7bdaf4eaf1d57fd7d3eeea4280437",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}