{
  "comments": [
    {
      "key": {
        "uuid": "94588fe2_08cb10ed",
        "filename": "rtc_base/string_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-22T11:12:59Z",
      "side": 1,
      "message": "VLAs are in C99 but not in any standard version of C++. Could you perhaps create an empty std::wstring of length `len16` and write directly into that? That\u0027s the technique used by e.g. absl::StrCat.\n\nIt would also be possible to create a C function that creates a VLA on the stack and calls a callback and passes it the VLA\u0027s address, but let\u0027s not get carried away...",
      "revId": "5e346913cd8127e91c8fa6a08ec290ce8299d950",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1c7255c3_50b8439a",
        "filename": "rtc_base/string_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-22T11:37:04Z",
      "side": 1,
      "message": "\u003e VLAs are in C99 but not in any standard version of C++. Could you perhaps create an empty std::wstring of length `len16` and write directly into that? That\u0027s the technique used by e.g. absl::StrCat.\n\nAccording to https://en.cppreference.com/w/cpp/string/basic_string/data, the version providing a non-const char* isn\u0027t available until C++17. How does absl::StrCat deal with that? const_cast?\n\nIf all else fails I could copy via an std::vector\u003cchar\u003e. But that\u0027s a bit silly. And there\u0027s no way to move storage between std::vector\u003cT\u003e and std::string\u003cT\u003e, right?\n\nI had no idea what kind of box I was opening here...",
      "parentUuid": "94588fe2_08cb10ed",
      "revId": "5e346913cd8127e91c8fa6a08ec290ce8299d950",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f5cd1181_e14cebcd",
        "filename": "rtc_base/string_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-22T11:49:12Z",
      "side": 1,
      "message": "Use .front() or [0]?",
      "parentUuid": "1c7255c3_50b8439a",
      "revId": "5e346913cd8127e91c8fa6a08ec290ce8299d950",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0c6ec02_74f98501",
        "filename": "rtc_base/string_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-22T11:57:32Z",
      "side": 1,
      "message": "I just looked at absl::StrCat. It uses the following hack:\n\n  std::string s;\n  ... allocate, using another hack to skip initialization ...\n  char *out \u003d \u0026*s.begin();\n\nNot sure what\u0027s the most portable way to get a working char *, in theory and practice, but I imagine this way is reasonably well tested on the platforms we target.",
      "parentUuid": "f5cd1181_e14cebcd",
      "revId": "5e346913cd8127e91c8fa6a08ec290ce8299d950",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "89899ea1_79de2df8",
        "filename": "rtc_base/string_utils.h",
        "patchSetId": 2
      },
      "lineNbr": 52,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-22T11:58:43Z",
      "side": 1,
      "message": "StrCat uses s.resize(size) to resize the string, then \u0026*s.begin() to get the pointer. (It actually uses a backdoor to resize the string without filling it with zeros if possible; IIRC someone was trying to get that into C++20...)",
      "parentUuid": "f5cd1181_e14cebcd",
      "revId": "5e346913cd8127e91c8fa6a08ec290ce8299d950",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}