{
  "comments": [
    {
      "key": {
        "uuid": "056a1112_ed875895",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "Thanks for the CL!",
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b4253b90_66cfeeb3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5122
      },
      "writtenOn": "2020-09-24T09:00:43Z",
      "side": 1,
      "message": "Thanks for your comments Per.\nLet me start with two of them.",
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "abe1cd71_9cb66bf5",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 83,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "If DumpDebugData is moved (according to the suggestion below) and the else if with the DCHECK is removed (according to the other suggestion) these two if-statements can be turned into one single if-statement, which I think would be good for the readability of this code (bundled if-statements are hard to follow).",
      "range": {
        "startLine": 81,
        "startChar": 2,
        "endLine": 83,
        "endChar": 42
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "208913ce_52d28929",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 87,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "I see the point of using the temporary and reliable states.\nHowever, this potentially is a very expensive copy since it copies the whole ring-buffer in SaturationProtectorState.\n\nWould it be possible to somehow avoid these copies? Also, copying ring-buffers kind of lose the whole point with using ring-buffers (the main value of ring-buffers is to avoid having to copy their data during updates).",
      "range": {
        "startLine": 87,
        "startChar": 8,
        "endLine": 87,
        "endChar": 43
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8db739bd_2987ba3e",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 91,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "I would suggest that this is skipped. It requires the implementation of the operators, and it is code that is there only to check the rest of the code. As of now, it adds 10 extra lines of code.\nAlso, the state machine for this is quite complicated to follow and it would be good to be able to avoid this if-statement.\n\nIf this behavior needs to be locked down, please add a unittest for it instead.",
      "range": {
        "startLine": 89,
        "startChar": 5,
        "endLine": 91,
        "endChar": 5
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "da0b446d_bc6d049b",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "DumpDebugData(); is called in 3 places in this method. Please move it so that it is only called once (I would suggest at the entry of the method)",
      "range": {
        "startLine": 104,
        "startChar": 4,
        "endLine": 104,
        "endChar": 20
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2196d6f2_e4d35dd2",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 111,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "To me it looks like this copying has some side-effect. For instance time_to_full_buffer_ms indicates that there is a buffer somewhere that is filled, and that will become full in a certain number of ms.\nThis copy sets changes that value, but I don\u0027t see that that buffer is affected by this setting.\n\nLooking a bit more into detail I have a feeling that the buffer being referred to is the ring-buffer in SaturationProtectorState? If that is the case, please move this counter there instead. Having this kind of distributed book-keeping is error prone and confusing.",
      "range": {
        "startLine": 111,
        "startChar": 4,
        "endLine": 111,
        "endChar": 39
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a9942a8_fa8233d1",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 111,
      "author": {
        "id": 5122
      },
      "writtenOn": "2020-09-24T09:00:43Z",
      "side": 1,
      "message": "Good catch. With the current parameters, IsConfident() returns true when the ring buffer in the (reliable) saturation protector state is full. However, if the saturation protector is not used, we can\u0027t look at its buffer.\n\nIn practice the saturation protector is always active and I don\u0027t expect that we will get rid of it as it has proven to be useful. So, I could add a parent CL to remove `use_saturation_protector_` and always use the saturation protector. Then, we can remove `time_to_full_buffer_ms` from the state.",
      "parentUuid": "2196d6f2_e4d35dd2",
      "range": {
        "startLine": 111,
        "startChar": 4,
        "endLine": 111,
        "endChar": 39
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51579f88_588d06c2",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 111,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T09:21:20Z",
      "side": 1,
      "message": "Yes, absolutely.",
      "parentUuid": "1a9942a8_fa8233d1",
      "range": {
        "startLine": 111,
        "startChar": 4,
        "endLine": 111,
        "endChar": 39
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "420ad0e6_1c49e2d2",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 133,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "From what I can see, the reliable_state_ is only used here to report values.\n\nIf that is the case, I don\u0027t see why two states are needed.\nIt should be possible to only use one state and store the outputs for these two as the reliable values.\n\nThat would eliminate the need for the copying of the complete states, and probably also simplify the logic for how the temporary and reliable states are handled.",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 133,
        "endChar": 53
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9edd318b_00f62e66",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 133,
      "author": {
        "id": 5122
      },
      "writtenOn": "2020-09-24T09:00:43Z",
      "side": 1,
      "message": "\u003e From what I can see, the reliable_state_ is only used here to report values.\n\nNope. Once enough consecutive speech frames are observed, `reliable_state_` is *updated* (see line 113). Also note that `reliable_state_` is implicitly used in line 122 because `last_level_dbfs_` always equals `reliable_state_.level_dbfs.GetRatio()` - the ratio is cached so that we don\u0027t need to compute the ratio every time that `GetLevelDbfs()` is called.\n\n\u003e If that is the case, I don\u0027t see why two states are needed.\n\nGood point on making sure that we don\u0027t have redundancy and hence a minimal state.\nLet\u0027s think of alternative approaches.\n\n1. The level estimator state only holds a `Ratio` (two floats), hence we keep `preliminary_level_dbfs_` and `reliable_level_dbfs_` so that we have an affordable copy (two floats) once the level estimation becomes reliable - i.e., enough consecutive speech frames are observed.\n - PRO: no need to copy a larger struct, but just two floats\n - CON: that works only if the saturation protector is not used\n\n2. As above and we intentionally exclude the saturation protector state from the feature added in this CL (i.e., requiring enough consecutive speech frames in order to update the reliable state)\n - PRO: same as above\n - CON: we accept the consequences of a frame that is incorrectly labeled as speech (false positive); for instance, a frame with noise and low peak power may lower the safety margin recommended by the protector and that could lead to clipping - i.e., we disable the saturation protector\n\n\u003e It should be possible to only use one state and store the outputs for these two as the reliable values.\n\u003e \n\u003e That would eliminate the need for the copying of the complete states, and probably also simplify the logic for how the temporary and reliable states are handled.\n\nI still believe that we need two states because `reliable_state_` is *updated* after it\u0027s copied from `preliminary_state_`.\n\nAlso, I don\u0027t think that excluding the saturation protector (alternative #2) is a good idea (see CONs).\n\nWhat we can for sure do is to reduce the size of `Struct` by\n  (i) always use the saturation protector and get rid of `time_to_full_buffer_ms` (see my previous answer)\n  (ii) replace the saturation protector ring buffer (4 floats + 2 ints) to an array of 4 floats.\nIn this way, when a copy between preliminary and reliable states occurs, we copy 7 floats and 1 int (32 bytes), namely:\n - 2 `Ratio`, i.e., 2 floats\n - minimized* saturation protector state:\n   - array of 4 floats\n   - float margin_db\n   - int time_since_push_ms\n\n*: switch from ring buffer to array and get rid of `max_peaks_dbfs`, which seems to be doable when we switch (back) to an array\n\nWDYT?",
      "parentUuid": "420ad0e6_1c49e2d2",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 133,
        "endChar": 53
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "baaafdad_1c06faf4",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 133,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T09:21:20Z",
      "side": 1,
      "message": "||From what I can see, the reliable_state_ is only used here to report values.\n\n|Nope. Once enough consecutive speech frames are observed, `reliable_state_` |is *updated* (see line 113). Also note that `reliable_state_` is implicitly |used in line 122 because `last_level_dbfs_` always equals |`reliable_state_.level_dbfs.GetRatio()` - the ratio is cached so that we |don\u0027t need to compute the ratio every time that `GetLevelDbfs()` is called.\nWhat I meant was that this is the only place where it is used to produce output.\n\n||If that is the case, I don\u0027t see why two states are needed.\n\n|Good point on making sure that we don\u0027t have redundancy and hence a minimal |state.\n|Let\u0027s think of alternative approaches.\nMy main concern is actually the copies of the states that contains a ring-buffer. I\u0027m less concerned about the redundancy.\n\nYou know best what options to pursue. I don\u0027t think we should compromise the quality with the way we choose but an option that keeps copying structures of data should be avoided, and looking at the code I think it should be avoidable.\n\n|I still believe that we need two states because `reliable_state_` is |*updated* after it\u0027s copied from `preliminary_state_`.\nAs I see it, the idea with the two states is that the reliable_state_ can be \"frozen\" and then updated with the temporary state whenever it again should be updated.\nHowever, with the current code I don\u0027t see why the same effect cannot be achieved by\n1. Only having one state that is updated\n2. Instead of as before freezing the whole state, only freezing the outputs produced by the state.\n\n\n| (i) always use the saturation protector and get rid of |`time_to_full_buffer_ms` (see my previous answer)\n|  (ii) replace the saturation protector ring buffer (4 floats + 2 ints) to |an array of 4 floats.\n|In this way, when a copy between preliminary and reliable states occurs, we |copy 7 floats and 1 int (32 bytes), namely:\n| - 2 `Ratio`, i.e., 2 floats\n| - minimized* saturation protector state:\n|   - array of 4 floats\n|   - float margin_db\n|   - int time_since_push_ms\nYes, this is also an option. But I don\u0027t think two states are needed. Also, as you point out in another it may be that the ringbuffer will need to be increased in size, which means that going for this approach will lock us into a construct that is more expensive than it has to be.",
      "parentUuid": "9edd318b_00f62e66",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 133,
        "endChar": 53
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "581e1b74_066e499d",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 133,
      "author": {
        "id": 5122
      },
      "writtenOn": "2020-09-24T09:58:48Z",
      "side": 1,
      "message": "Ok, let\u0027s then think about the option of only updating the level estimation once enough speech frames are observed. What I want to show below is that we cannot achieve the same result with the approach you suggest - it may solve the problem we address, but the output won\u0027t be bit-exact.\n\nSo, we get rid of the two states; instead, we keep a single state instance which essentially spans:\n- `Ratio level_ratio_dbfs_`\n- `SaturationProtectorState saturation_protector_state_`\n- `float reliable_level_dbfs_`\n\nOnce enough consecutive speech frames are observed, we assign `reliable_level_dbfs_ \u003d level_ratio_dbfs_.GetRatio();` - i.e., the level estimation is updated.\n\nBut what happens if the VAD produces frequent isolated false positives (high probability spikes) during a long near-end inactivity turn? `reliable_level_dbfs_` won\u0027t be updated, but the rest will be updated since there is no mechanism that restores `level_ratio_dbfs_` and `saturation_protector_state_` to any previous (reliable) state. More in detail:\n- With the false positives we want to fight, we will analyze frames with low peak/rms power; hence\n  - `level_ratio_dbfs_` will converge to a lower level\n  - `saturation_protector_state_` will be updated and the safety margin will get lower and lower\n\n`reliable_level_dbfs_` is not updated, so everything looks ok until this point.\n\nBut then the near-end becomes active and the VAD correctly detects speech.\n`level_ratio_dbfs_` and `saturation_protector_state_` are in a wrong state and it\u0027ll take time before they converge to a correct state based on the actual speech level. However, as soon as enough consecutive speech frames are observed (say 200 ms), `reliable_level_dbfs_` is updated and it is influenced by the previous unwanted udpates of `level_ratio_dbfs_` and `saturation_protector_state_`.\n\nSo, this example proves that we can\u0027t produce the same behavior by switching to a single state. Please, correct me if I\u0027m wrong.\n\nMore importantly, the different behavior is not what we want and that\u0027s why I believe we should keep two states for the best possible result.\n\nOne alternative is to reset the `level_ratio_dbfs_` and `saturation_protector_state_` when the speech probability is below the threshold - i.e., not a speech frame. However, this will lead to fluctuating `reliable_level_dbfs_` values because the estimation will be based on a short term analysis (we can\u0027t implement a long term memory anymore).",
      "parentUuid": "baaafdad_1c06faf4",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 133,
        "endChar": 53
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6bac399_07abc339",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 133,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-25T10:04:32Z",
      "side": 1,
      "message": "As discussed offline, I think you are correct. Two states are indeed as you say needed.",
      "parentUuid": "581e1b74_066e499d",
      "range": {
        "startLine": 121,
        "startChar": 0,
        "endLine": 133,
        "endChar": 53
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0628c560_ea5acc98",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 134,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "This should go into the header file to allow inlining.",
      "range": {
        "startLine": 132,
        "startChar": 0,
        "endLine": 134,
        "endChar": 1
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "74691477_eaa56567",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 136,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "Please add a comment, either here or in the header, what this method does. UpdateState is a very nondescriptive name.",
      "range": {
        "startLine": 136,
        "startChar": 0,
        "endLine": 136,
        "endChar": 45
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "070672d4_3a966c97",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 142,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "Is there anything that prohibits this from becoming negative? What is the effect in that case (A negative time seems strange)?",
      "range": {
        "startLine": 140,
        "startChar": 1,
        "endLine": 142,
        "endChar": 3
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "32123ed6_1ef418dd",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 3
      },
      "lineNbr": 189,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "This kind of goes against the idea of the data dumper class. If data dumping is not activated, the DumpRaw() calls compile to no-ops.\nI would suggest that the data dumper is always created and that the if-statement is skipped.\n(this is the pattern used in AEC3).",
      "range": {
        "startLine": 189,
        "startChar": 2,
        "endLine": 189,
        "endChar": 25
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04ead340_1724a685",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.h",
        "patchSetId": 3
      },
      "lineNbr": 59,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "Since this is (as stated in the comment) a part of the level estimator state and not the actual state, I think a more descriptive name should be used for it than State.",
      "range": {
        "startLine": 59,
        "startChar": 9,
        "endLine": 59,
        "endChar": 14
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "461150d7_40ee9a5f",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.h",
        "patchSetId": 3
      },
      "lineNbr": 82,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "Please rename this. With its current naming, it seems like this is a minimum value for the seen consecutive speech frames. But it is actually a threshold.",
      "range": {
        "startLine": 82,
        "startChar": 12,
        "endLine": 82,
        "endChar": 42
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a8b3efef_ad8a542c",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.h",
        "patchSetId": 3
      },
      "lineNbr": 86,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-24T05:55:59Z",
      "side": 1,
      "message": "Nit: I think that with the way this is used in the CL, this is more of a preliminary state than a temporary state.",
      "range": {
        "startLine": 86,
        "startChar": 8,
        "endLine": 86,
        "endChar": 17
      },
      "revId": "deefa30f16874a382fd34c45f6a21c044a6db51a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}