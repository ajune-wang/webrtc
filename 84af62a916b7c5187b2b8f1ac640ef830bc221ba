{
  "comments": [
    {
      "key": {
        "uuid": "0e926fb6_47c82865",
        "filename": "sdk/android/src/jni/android_media_encoder.cc",
        "patchSetId": 6
      },
      "lineNbr": 99,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-11T11:19:20Z",
      "side": 1,
      "message": "If I\u0027ve understood this correctly, AndroidMediaDecoder is the old way of doing hardware encoding on android. The new way is VideoEncoderWrapper, and in this case, releaseOutputBuffer is called on the java side, here: https://cs.chromium.org/chromium/src/third_party/webrtc/sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java?q\u003dHardwareVideoEncoder\u0026sq\u003dpackage:chromium\u0026dr\u003dCSs\u0026l\u003d537\n\nI\u0027d like to do a followup cl to delete this memcpy: https://cs.chromium.org/chromium/src/third_party/webrtc/sdk/android/src/jni/video_encoder_wrapper.cc?l\u003d230. But to do that, control of releaseOutputBuffer must be given to the C++ code, possibly as a method on the java class EncodedImage. \n\nSami, do you think that is feasible, and do you have any advice?",
      "range": {
        "startLine": 99,
        "startChar": 1,
        "endLine": 99,
        "endChar": 69
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b2c0679_f4182f60",
        "filename": "sdk/android/src/jni/android_media_encoder.cc",
        "patchSetId": 6
      },
      "lineNbr": 99,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-12T11:20:15Z",
      "side": 1,
      "message": "I think we need to:\n1. Add a way to add a release callback to EncodedImage interface / add reference counting\n2. Update all encoders to allow holding the buffer while the reference is alive\n3. Update wrapper to remove the memcpy",
      "parentUuid": "0e926fb6_47c82865",
      "range": {
        "startLine": 99,
        "startChar": 1,
        "endLine": 99,
        "endChar": 69
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "68339696_8164c9a9",
        "filename": "sdk/android/src/jni/android_media_encoder.cc",
        "patchSetId": 6
      },
      "lineNbr": 99,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-12T11:38:30Z",
      "side": 1,
      "message": "This cl tries to do (1). EncodedImage holds a scoped_refptr\u003cEncodedImageBufferInterface\u003e. My question is how to implement that interface to get an object representing what\u0027s passed to VideoEncoderWrapper::OnEncodedFrame from java.\n\nI\u0027d like to do something similar to the JavaEncodedImageBuffer class here, which invokes the java releaseOutputBuffer on destruction. It\u0027s just that I don\u0027t see any way to do that in VideoEncoderWrapper, without also doing some changes on the java side.\n\nWe\u0027d need some kind of release callback passed from java to C++, and invoked from the appropriate C++ destructor. Hmm, what is the |j_caller| argument to VideoEncoderWrapper::OnEncodedFrame? It\u0027s currently unused.",
      "parentUuid": "1b2c0679_f4182f60",
      "range": {
        "startLine": 99,
        "startChar": 1,
        "endLine": 99,
        "endChar": 69
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}