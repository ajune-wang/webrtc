{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "7de51612_0e8397b1",
        "filename": "api/audio/audio_frame.h",
        "patchSetId": 19
      },
      "lineNbr": 133,
      "author": {
        "id": 5125
      },
      "writtenOn": "2024-04-24T12:49:52Z",
      "side": 1,
      "message": "I did not comment on this is the previous round, but I wonder if it is really the right thing to do to state that the sample count is 0 when the frame is muted?\nIt all depends on how the calling code is constructed, but it would seem fully fine to have a muted frame reporting non-zero as sample count.\n\nOne example of where this could make a huge difference is for resampling of audio.\n\nIf the implementation is such that whenever sample_count is zero due to muting, then the resampling is not done, it is very easy to end up in situations where the resampler contains old input data in the state from before the muting was done, which will result in audio clicks.\nThis can be overcome by priming the resampler with zero data when unmuting occurs but that will instead increase the peak complexity.\n\nIf this is added, I think we need to be careful for how it is used, and add documentation about this aspect.",
      "range": {
        "startLine": 131,
        "startChar": 0,
        "endLine": 133,
        "endChar": 3
      },
      "revId": "fb001bf12ed88dd51e93ed61db893e8e8bb9b5c2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77e348b6_3cc3c896",
        "filename": "api/audio/audio_frame.h",
        "patchSetId": 19
      },
      "lineNbr": 133,
      "author": {
        "id": 5508
      },
      "writtenOn": "2024-04-26T17:26:07Z",
      "side": 1,
      "message": "yes - after much deliberation I agree. I\u0027ve removed sample_count() now and changed `data_view()` so that it behaves _essentially_ the same way as `data()`.\n\n...with one important exception:\n\n* When ArrayView is created with a size of 0, `data()` will always return nullptr.\n\nThis means the following:\n```\nAudioFrame frame;  // By default samples_per_channel \u003d\u003d 0, num_channels \u003d\u003d 0.\nframe.data();      // Returns a valid pointer regardless of ^^^\nframe.data_view().data();  // Returns nullptr.\n```\n\nWhat I\u0027d like to do is move away from just constructing AudioFrame with no parameters, towards a more RAII model where we pass arguments to a constructor. So, as an example, I\u0027m adding a constructor that allows specifying those two size properties. If we get into that habit, we shouldn\u0027t be hitting that `nullptr` case and we also reduce code outside of the AudioFrame class that\u0027s touching the public member variables.\n\nBtw, I\u0027m concerned that num_channels and samples_per_channel are both `size_t` and easy to mix up when passing as parameters. I\u0027m wondering if it would be better down the line to make num_channels_ an enum. The AudioFrame test file already has constants such as `kNumChannelsMono`, `kNumChannelsStereo`, `kNumChannels5_1` which I think would help avoid this possible mix up and also help with readability.",
      "parentUuid": "7de51612_0e8397b1",
      "range": {
        "startLine": 131,
        "startChar": 0,
        "endLine": 133,
        "endChar": 3
      },
      "revId": "fb001bf12ed88dd51e93ed61db893e8e8bb9b5c2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c30443f_5ab3dedc",
        "filename": "api/audio/audio_frame.h",
        "patchSetId": 19
      },
      "lineNbr": 133,
      "author": {
        "id": 5125
      },
      "writtenOn": "2024-04-29T17:57:34Z",
      "side": 1,
      "message": "Sounds good with an implementation that returns nullptr for zero sizes.!\n\nMoving to fully use an RAII model would be great! At least it should be possible to give some kind of assessment for the parameters at construction time, even though it may be needed to change those later on.\n\nRegarding the num_channels and samples_per_channel I partly share the concern, but I see it slightly differently. Some aspects:\n-I\u0027d myself prefer to keep a channel count as size_t (or an int) since that is actually how it is used in the code, and I fear that going via enums would require a fair amount of boilerplate code to convert back and forth. \n-I think bundling the layout into the enums such as kNumChannels5_1 will tying additional information into the channel count which is rarely used.\n-I think the main risk of mixup of num_channels is due to the use of samples_per_channel. If instead num_channels and sample_rate_hz is specified, the risk of mixup should be much less. (e.g., CHECKS/DCHECKs could then be added to make sure that the channel count is less than 1000, which should work since there are no usable sample rates for audio that are that low).",
      "parentUuid": "77e348b6_3cc3c896",
      "range": {
        "startLine": 131,
        "startChar": 0,
        "endLine": 133,
        "endChar": 3
      },
      "revId": "fb001bf12ed88dd51e93ed61db893e8e8bb9b5c2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c50d368d_93fde19d",
        "filename": "api/audio/audio_frame.h",
        "patchSetId": 19
      },
      "lineNbr": 133,
      "author": {
        "id": 5508
      },
      "writtenOn": "2024-04-30T08:01:49Z",
      "side": 1,
      "message": "OK, makes sense. I guess we could also define separate types for those values (or even just one) to make it harder to mix them up. Also, since there\u0027s no reason for them to be 64bit values, they could both be 16bit and save a bit of stack size in the future since we\u0027ll be passing pointers with frame size information (likely 3 separate properties; channels, per-channel-size, allocation size).",
      "parentUuid": "9c30443f_5ab3dedc",
      "range": {
        "startLine": 131,
        "startChar": 0,
        "endLine": 133,
        "endChar": 3
      },
      "revId": "fb001bf12ed88dd51e93ed61db893e8e8bb9b5c2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d07e54c2_aa1e6e48",
        "filename": "api/audio/audio_frame.h",
        "patchSetId": 19
      },
      "lineNbr": 133,
      "author": {
        "id": 5125
      },
      "writtenOn": "2024-04-30T10:50:31Z",
      "side": 1,
      "message": "Yep, that sounds good.",
      "parentUuid": "c50d368d_93fde19d",
      "range": {
        "startLine": 131,
        "startChar": 0,
        "endLine": 133,
        "endChar": 3
      },
      "revId": "fb001bf12ed88dd51e93ed61db893e8e8bb9b5c2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc5fbe39_493f5648",
        "filename": "audio/audio_transport_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 82,
      "author": {
        "id": 5125
      },
      "writtenOn": "2024-04-24T12:49:52Z",
      "side": 1,
      "message": "I missed this in the previous round but this is a bit risky in the sense that not keeping doing the resampling of muted data will cause the previous data to remain in the resampler state. That in turn will mean that when unmuting occurs, those samples will be put into the resampler output at that point, causing unwanted audio content to included and likely resulting in clicks.\n\nMy suggestion would be to keep resampling the muted data even though it is suboptimal.\nThe alternative would be to add a resetting mechanism to apply when data becomes unmuted. I\u0027m not convinced that logic warrants the CPU savings by not resampling muted data though, and on top of that the resetting will affect the peak complexity (while not reampling muted data will only improve the average complexity)",
      "range": {
        "startLine": 82,
        "startChar": 5,
        "endLine": 82,
        "endChar": 21
      },
      "revId": "fb001bf12ed88dd51e93ed61db893e8e8bb9b5c2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "763acc2b_334f105f",
        "filename": "audio/audio_transport_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 82,
      "author": {
        "id": 5508
      },
      "writtenOn": "2024-04-26T17:26:07Z",
      "side": 1,
      "message": "ok thanks for catching that - I\u0027ll remove this",
      "parentUuid": "fc5fbe39_493f5648",
      "range": {
        "startLine": 82,
        "startChar": 5,
        "endLine": 82,
        "endChar": 21
      },
      "revId": "fb001bf12ed88dd51e93ed61db893e8e8bb9b5c2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1563826a_bddca6f0",
        "filename": "audio/audio_transport_impl.cc",
        "patchSetId": 19
      },
      "lineNbr": 82,
      "author": {
        "id": 5125
      },
      "writtenOn": "2024-04-29T17:57:34Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "763acc2b_334f105f",
      "range": {
        "startLine": 82,
        "startChar": 5,
        "endLine": 82,
        "endChar": 21
      },
      "revId": "fb001bf12ed88dd51e93ed61db893e8e8bb9b5c2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1170cfba_c8b39c45",
        "filename": "modules/audio_processing/agc2/vad_wrapper.cc",
        "patchSetId": 19
      },
      "lineNbr": 107,
      "author": {
        "id": 5826
      },
      "writtenOn": "2024-04-23T18:00:45Z",
      "side": 1,
      "message": "So we do it only for the first channel? Or is it always mono?",
      "revId": "fb001bf12ed88dd51e93ed61db893e8e8bb9b5c2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55b90b42_15eb2588",
        "filename": "modules/audio_processing/agc2/vad_wrapper.cc",
        "patchSetId": 19
      },
      "lineNbr": 107,
      "author": {
        "id": 5508
      },
      "writtenOn": "2024-04-23T20:19:15Z",
      "side": 1,
      "message": "Yes, it assumes mono. It\u0027s not super clear from this code (it would be good to have e.g. a check for num_channels()), but if you take a look at the header file, you can see that the class assumes mono.",
      "parentUuid": "1170cfba_c8b39c45",
      "revId": "fb001bf12ed88dd51e93ed61db893e8e8bb9b5c2",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}