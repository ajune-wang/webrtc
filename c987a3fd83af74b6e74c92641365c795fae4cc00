{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "067c71b6_0225655b",
        "filename": "net/dcsctp/public/dcsctp_message.h",
        "patchSetId": 25
      },
      "lineNbr": 45,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-04-06T09:01:23Z",
      "side": 1,
      "message": "uhm, don\u0027t think I\u0027ve seen this before - have to ask:\n\nwhat is the semantic difference with and without \u0026\u0026?\n\n(nice to have the ReleasePayload option btw)",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d7013a18_fb13ee37",
        "filename": "net/dcsctp/public/dcsctp_message.h",
        "patchSetId": 25
      },
      "lineNbr": 45,
      "author": {
        "id": 12215
      },
      "writtenOn": "2021-04-06T09:34:16Z",
      "side": 1,
      "message": "This is a destructive method and will put the object in a \"undefined\" state (the payload will be moved from, and you shouldn\u0027t call payload() on that object).\n\nSo the \u0026\u0026 requires that you call it on a std::moved-from instance, which signals to the reader, and to the compiler, that the object is not valid past this point.\n\nTypically:\n\nstd::vector\u003cconst uint8_t\u003e payload \u003d std::move(message).ReleasePayload();\n\n// This would yield a compiler warning/error (use after std::moved)\nrtc::ArrayView\u003cconst uint8_t\u003e payload2 \u003d message.payload();\n\nSo it\u0027s just for safety.",
      "parentUuid": "067c71b6_0225655b",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5009b5d2_f98994d7",
        "filename": "net/dcsctp/public/dcsctp_options.h",
        "patchSetId": 25
      },
      "lineNbr": 82,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-04-06T09:01:23Z",
      "side": 1,
      "message": "RFC3758?",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "42fa41db_2b13282b",
        "filename": "net/dcsctp/public/dcsctp_options.h",
        "patchSetId": 25
      },
      "lineNbr": 82,
      "author": {
        "id": 12215
      },
      "writtenOn": "2021-04-06T09:34:16Z",
      "side": 1,
      "message": "RFC4960 actually - updating. And I actually noticed when looking for the reference, that I used the wrong value. It\u0027s 8 in the RFC. Thanks",
      "parentUuid": "5009b5d2_f98994d7",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "070b1701_d165ca48",
        "filename": "net/dcsctp/public/dcsctp_socket.h",
        "patchSetId": 25
      },
      "lineNbr": 230,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-04-06T09:01:23Z",
      "side": 1,
      "message": "would it make sense to set the observer via a constructor instead?\n\nAlso, is nullptr valid (and is it desired)?\n\nWhat I\u0027m wondering about is if it allows for a simpler implementation with fewer states if we can assume:\n- There is always an observer (introduced via the ctor)\n- There is no way to \"unset\" an observer (it can be const)\n- The observer object ownership is with the DcSctpSocketInterface implementation (observer is set via unique_ptr\u003c\u003e).\n\nThe last bit moves the responsibility of potential synchronization if the outside implementation requires it, out of the DcSctpSocketInterface implementation and into the outside implementation. It furthermore gives the outside implementation a way to get a callback when the DcSctpSocketInterface object goes out of scope, via the dtor of the callback implementation.",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fba513cb_0bea3363",
        "filename": "net/dcsctp/public/dcsctp_socket.h",
        "patchSetId": 25
      },
      "lineNbr": 230,
      "author": {
        "id": 12215
      },
      "writtenOn": "2021-04-06T09:34:16Z",
      "side": 1,
      "message": "Good points! Yes, it can be nullptr, and there\u0027s no real value of unsetting it. It\u0027s actually intended to be used in tests - which I hope I\u0027ll get to soon. All high-level test cases will create PCAP files with observed packets for all sockets, as artifacts. I\u0027ll see if I can make that into ResultDB, as the PacketObserver was originally written for a different artifact storage system.\n\nI\u0027ll make it into a constructor parameter, as a unique_ptr, so ownership is clear. And then it will disappear from this interface.",
      "parentUuid": "070b1701_d165ca48",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2473e62_e54d4c8c",
        "filename": "net/dcsctp/public/dcsctp_socket.h",
        "patchSetId": 25
      },
      "lineNbr": 246,
      "author": {
        "id": 7036
      },
      "writtenOn": "2021-04-06T09:25:14Z",
      "side": 1,
      "message": "Could this return an error if it doesn\u0027t support a stream reset?\nOr can we make sure the failed callback is called with a proper error code?",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "75fff21d_f32591ed",
        "filename": "net/dcsctp/public/dcsctp_socket.h",
        "patchSetId": 25
      },
      "lineNbr": 246,
      "author": {
        "id": 12215
      },
      "writtenOn": "2021-04-06T09:34:16Z",
      "side": 1,
      "message": "Please call SupportStreamsReset prior to calling this method, to ensure that the peer supports it. As stream resetting is asynchronous, and the peer may return an error, it\u0027s not guaranteed that this will succeed. If this fails, though, the callback `OnStreamsResetFailed` is guaranteed to be triggered. The same if it succeeds; then `OnStreamsResetPerformed` will be triggered.",
      "parentUuid": "e2473e62_e54d4c8c",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0bbc1668_6c2150bc",
        "filename": "net/dcsctp/public/dcsctp_socket.h",
        "patchSetId": 25
      },
      "lineNbr": 246,
      "author": {
        "id": 7036
      },
      "writtenOn": "2021-04-06T10:04:37Z",
      "side": 1,
      "message": "But what happens if it doesn\u0027t support it or is not known yet and it\u0027s called anyway?\nDo we get an error in the callback, an assert, is it a no-op?\nThat should properly be specified in the contract.",
      "parentUuid": "75fff21d_f32591ed",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a7163d51_096c74e8",
        "filename": "net/dcsctp/public/dcsctp_socket.h",
        "patchSetId": 25
      },
      "lineNbr": 246,
      "author": {
        "id": 12215
      },
      "writtenOn": "2021-04-06T10:11:25Z",
      "side": 1,
      "message": "The last paragraph in the method description indicates that it\u0027s a no-op. Should I rewrite it to be even more explicit?",
      "parentUuid": "0bbc1668_6c2150bc",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d5864b8_54f73e07",
        "filename": "net/dcsctp/public/dcsctp_socket.h",
        "patchSetId": 25
      },
      "lineNbr": 246,
      "author": {
        "id": 7036
      },
      "writtenOn": "2021-04-06T10:38:29Z",
      "side": 1,
      "message": "Since it wasn\u0027t clear to me at least, that would be nice. The part about the other function returning true is a bit redundant. Maybe something like:\n\nResetting streams can only be done on an established association that supports stream resetting.\nCalling this method on e.g. a closed association or streams that don\u0027t support resetting will not perform any operation.",
      "parentUuid": "a7163d51_096c74e8",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2c6e4eed_5042f52c",
        "filename": "net/dcsctp/public/dcsctp_socket.h",
        "patchSetId": 25
      },
      "lineNbr": 246,
      "author": {
        "id": 12215
      },
      "writtenOn": "2021-04-06T10:44:19Z",
      "side": 1,
      "message": "I took your suggestion as it was - thanks!",
      "parentUuid": "7d5864b8_54f73e07",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67aa620b_c6fe6934",
        "filename": "net/dcsctp/public/dcsctp_socket.h",
        "patchSetId": 25
      },
      "lineNbr": 252,
      "author": {
        "id": 7036
      },
      "writtenOn": "2021-04-06T09:25:14Z",
      "side": 1,
      "message": "Can\u0027t we make this a strong enum instead of abusing an optional nullopt to convey a specific meaning?",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "20e49301_29fe52fe",
        "filename": "net/dcsctp/public/dcsctp_socket.h",
        "patchSetId": 25
      },
      "lineNbr": 252,
      "author": {
        "id": 12215
      },
      "writtenOn": "2021-04-06T09:34:16Z",
      "side": 1,
      "message": "Good idea - done, and thanks",
      "parentUuid": "67aa620b_c6fe6934",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fce701f_d358cf15",
        "filename": "net/dcsctp/public/timeout.h",
        "patchSetId": 25
      },
      "lineNbr": 29,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-04-06T09:01:23Z",
      "side": 1,
      "message": "could this be done via a constructor? Avoid the possibility of multiple calls to Start() for the same Timeout? (without a matching \u0027Stop()\u0027)",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d662daa8_ea77b51d",
        "filename": "net/dcsctp/public/timeout.h",
        "patchSetId": 25
      },
      "lineNbr": 29,
      "author": {
        "id": 12215
      },
      "writtenOn": "2021-04-06T09:34:16Z",
      "side": 1,
      "message": "The reason I made it like this, having a Start and Stop method, is that it works very well with the Hashed Wheel Timer algorithm, which is really efficient to handle a large (1000s) of timers, which are frequently started and stopped - which the timers in SCTP do.\n\nBy having a Start and Stop, these will translate into a simple linked-list insertion/deletion (which are constant, and use no heap allocations). If using objects and ctor/dtor to signal Start and Stop, that would add the heap operations  that aren\u0027t extremely expensive, but unnecessary.\n\nI will make a note about the contract that Start and Stop will _always_ be called in pairs.",
      "parentUuid": "2fce701f_d358cf15",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d2877a3_a7267887",
        "filename": "net/dcsctp/public/timeout.h",
        "patchSetId": 25
      },
      "lineNbr": 32,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-04-06T09:01:23Z",
      "side": 1,
      "message": "Cancel()? Alternatively force use of a dtor (delete the Timeout instance) to do this?",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "43e18ff4_5a875552",
        "filename": "net/dcsctp/public/timeout.h",
        "patchSetId": 25
      },
      "lineNbr": 32,
      "author": {
        "id": 12215
      },
      "writtenOn": "2021-04-06T09:34:16Z",
      "side": 1,
      "message": "Please see above 😊\n\nI also added a remark that it will always be stopped when destructed. Yeah, I agree that this object is fairly low-level...",
      "parentUuid": "8d2877a3_a7267887",
      "revId": "c987a3fd83af74b6e74c92641365c795fae4cc00",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}