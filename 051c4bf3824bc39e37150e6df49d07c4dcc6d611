{
  "comments": [
    {
      "key": {
        "uuid": "de9ef9de_14d554c9",
        "filename": "api/media_transport_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 90,
      "author": {
        "id": 5077
      },
      "writtenOn": "2019-02-12T09:49:50Z",
      "side": 1,
      "message": "Why the default impls? Add TODO: to remove them if it is scaffolding.",
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ca77fae_c08aedd5",
        "filename": "api/media_transport_interface.cc",
        "patchSetId": 2
      },
      "lineNbr": 90,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-02-12T10:29:01Z",
      "side": 1,
      "message": "Added TODOs. Should be pure virtual whn downstream implementation is updated.",
      "parentUuid": "de9ef9de_14d554c9",
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a68f36a0_45a72c0b",
        "filename": "api/media_transport_interface.h",
        "patchSetId": 2
      },
      "lineNbr": 267,
      "author": {
        "id": 5077
      },
      "writtenOn": "2019-02-12T09:49:50Z",
      "side": 1,
      "message": "What\u0027s the rationale for having these objects? The impls currently look like lambdas binding channel_id to a transport.",
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7cf0668d_1fcc473e",
        "filename": "api/media_transport_interface.h",
        "patchSetId": 2
      },
      "lineNbr": 267,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-02-12T10:29:01Z",
      "side": 1,
      "message": "They\u0027re intended to encapsulate everything an audio send stream (or receive stream) needs from the MediaTransport.\n\nFor audio, they\u0027re expected to be quite thin, but for video and rtp, implementation is going to be similar to the current RtpVideoSender class.",
      "parentUuid": "a68f36a0_45a72c0b",
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ec8f363_3acc3b79",
        "filename": "api/test/loopback_media_transport.cc",
        "patchSetId": 2
      },
      "lineNbr": 112,
      "author": {
        "id": 5077
      },
      "writtenOn": "2019-02-12T14:02:57Z",
      "side": 1,
      "message": "These should be DCHECKs. These are programming errors.",
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3cbe5ee9_bfd25411",
        "filename": "api/test/loopback_media_transport.cc",
        "patchSetId": 2
      },
      "lineNbr": 127,
      "author": {
        "id": 5077
      },
      "writtenOn": "2019-02-12T09:49:50Z",
      "side": 1,
      "message": "...but we\u0027ll never know when an AudioSender has a dead pointer to the transport. :/",
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "996d87bf_d5808d4c",
        "filename": "api/test/loopback_media_transport.cc",
        "patchSetId": 2
      },
      "lineNbr": 127,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-02-12T10:29:01Z",
      "side": 1,
      "message": "The expectation is the the AudioSender will be owned by AudioSendStream, and that one mustn\u0027t delete the MediaTransport under the feet of live streams.\n\nAny concrete suggestion? It\u0027s possible to add a count of sender objects in the MediaTransport and DCHECK that it\u0027s zero on destruction. But not sure if it\u0027s worth the effort.",
      "parentUuid": "3cbe5ee9_bfd25411",
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f617ec4_7bd855cd",
        "filename": "api/test/loopback_media_transport.cc",
        "patchSetId": 2
      },
      "lineNbr": 127,
      "author": {
        "id": 5077
      },
      "writtenOn": "2019-02-12T14:02:57Z",
      "side": 1,
      "message": "Sorry if I\u0027m missing the high level goal here and making you repeat it. I\u0027ve probably missed a design doc or two on the topic. Please point me there.\n\nWith the support for pluggable transports it seems to me that configuring the transport should not happen through the current stream objects. There has to be a switch at the SDP parsing or API level, so then that layer should route the settings directly to the RTP or QUIC transport instances.\n\nThe \"streams\" will then just handle code/encode tasks, making the stream concept somewhat redundant (at least for audio, which I admittedly know better than video). With the \"streams\" becoming essentially live encoders and decoders, it doesn\u0027t seem right that they are tightly coupled with the \"transport\" concept. Rather, the entity receiving the PCM data to encode should know where the encoded payload should be forwarded (the transport sender).",
      "parentUuid": "996d87bf_d5808d4c",
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3cdfb0d0_616e242e",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 2
      },
      "lineNbr": 167,
      "author": {
        "id": 5077
      },
      "writtenOn": "2019-02-12T09:49:50Z",
      "side": 1,
      "message": "Is the audio_sink_ in audio_sinks_ ?",
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b634667_c0d36d7a",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 2
      },
      "lineNbr": 167,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-02-12T10:29:01Z",
      "side": 1,
      "message": "No, it\u0027s a fallback for code not yet converted to use CreateAudioReceiver. Added TODO.",
      "parentUuid": "3cdfb0d0_616e242e",
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "30f36e75_29fc24ea",
        "filename": "api/transport/media/audio_transport.h",
        "patchSetId": 2
      },
      "lineNbr": 130,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-02-11T08:22:22Z",
      "side": 1,
      "message": "It seems a bit questionable to me use use RTCError here; it seems intended for errors to be propagated to the javascript api. I would suggest either no return value, to make the method fire-and-forget, or a bool (true for success), if there\u0027s any use for reporting early failure, e.g., from packetization. \n\nI expect the typical implementation will at most do packetization before returning, and post the interesting part of the work to some network thread.",
      "range": {
        "startLine": 130,
        "startChar": 10,
        "endLine": 130,
        "endChar": 18
      },
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "747017dd_a00fdfa2",
        "filename": "api/transport/media/audio_transport.h",
        "patchSetId": 2
      },
      "lineNbr": 130,
      "author": {
        "id": 7704
      },
      "writtenOn": "2019-02-11T14:33:14Z",
      "side": 1,
      "message": "I think in principle I disagree with having methods that silently drop errors (fire and forget), except for the top-level ones (but even those should log warnings).\n\nIs there a better error type? Worst case we can use \u0027boolean\u0027.",
      "parentUuid": "30f36e75_29fc24ea",
      "range": {
        "startLine": 130,
        "startChar": 10,
        "endLine": 130,
        "endChar": 18
      },
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "56876a45_04ae60f8",
        "filename": "api/transport/media/audio_transport.h",
        "patchSetId": 2
      },
      "lineNbr": 130,
      "author": {
        "id": 5599
      },
      "writtenOn": "2019-02-11T18:11:21Z",
      "side": 1,
      "message": "We chose RTCError because it seemed like the cleanest abstraction for an error code (it\u0027s got a nice wrapper class, it lets us specify an error message, and you can have an RTCErrorOr if there\u0027s either a return value or error).\n\nIf the caller is never going to be able to do anything with an error (other than log and continue), we might as well do that in the implementation.  The only issue is that it becomes harder to test the implementation.  If there are incomplete frames we can\u0027t packetize, parameters we need to validate, or other synchronous failure modes, we can no longer test them directly.\n\nWe could return an int/bool, but we lose any error message associated with it.\n\nAnother option would be to define an error callback.  This could be a function pointer that gives full error details for a particular frame, and defaults to nullptr if production code doesn\u0027t need to know about errors.  Something like this:\n\nvoid SendAudioFrame(MediaTransportEncodedAudioFrame frame, void(*on_error)(int, string) \u003d nullptr);\n\nThat would even let us capture and test certain error cases in the async part of media transport.  However, it might be overkill.\n\nDo you think the callee ever needs to know about errors?  Does it ever do anything with them?",
      "parentUuid": "747017dd_a00fdfa2",
      "range": {
        "startLine": 130,
        "startChar": 10,
        "endLine": 130,
        "endChar": 18
      },
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "37431dc3_5aa7d5d7",
        "filename": "api/transport/media/audio_transport.h",
        "patchSetId": 2
      },
      "lineNbr": 130,
      "author": {
        "id": 5077
      },
      "writtenOn": "2019-02-12T09:49:50Z",
      "side": 1,
      "message": "+1, do we need the error code? If this function is called in a way where the transport can\u0027t work with the data, that\u0027s a programming error -\u003e DCHECK.",
      "parentUuid": "56876a45_04ae60f8",
      "range": {
        "startLine": 130,
        "startChar": 10,
        "endLine": 130,
        "endChar": 18
      },
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "05a96ec8_bb5cae18",
        "filename": "api/transport/media/audio_transport.h",
        "patchSetId": 2
      },
      "lineNbr": 130,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-02-12T10:29:01Z",
      "side": 1,
      "message": "I think I\u0027ll delete the return value. Rationale:\n\n1. Early errors, e.g., in packetization, is a sign of programming error, and should log and/or crash, with no error handling required in the caller.\n\n2. The interesting measure of success is whether or not the frame made it to the remote side. Proper handling of lost data is the responsibility of code quite far away from the direct caller of SendAudioFrame, e.g., retransmission and adjusting bandwidth estimate or FEC parameters. So a return value at this point isn\u0027t very useful.",
      "parentUuid": "37431dc3_5aa7d5d7",
      "range": {
        "startLine": 130,
        "startChar": 10,
        "endLine": 130,
        "endChar": 18
      },
      "revId": "051c4bf3824bc39e37150e6df49d07c4dcc6d611",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}