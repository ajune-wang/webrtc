{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "036f8e48_aeac3cd6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5053
      },
      "writtenOn": "2023-12-07T21:59:22Z",
      "side": 1,
      "message": "It\u0027s a bit hard to think through all the ramifications of this... but it\u0027s definitely confusing how we sometimes match codecs with different packetization and sometimes don\u0027t. \n\nMaybe we just wait until we have a different way of representing this in SDP? Since we already have a viable workaround for the time being.\n\nOr, we could always allow codecs with different packetization to match (meaning they\u0027ll always be treated as duplicate codecs), but handle duplicates generally in a better way, removing their payload types from the set (https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/pc/media_session.cc;l\u003d956;drc\u003d8e78783dc1f7007bad46d657c9f332614e240fd8) instead of just ignoring them.",
      "revId": "6f83e00fbdf300785dec844b117b3ccfc0778020",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2dca0fe7_6623217f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 18169
      },
      "writtenOn": "2023-12-11T09:44:51Z",
      "side": 1,
      "message": "I tried to implement the approach you described - to allow different packetizations match (as before) but handle duplicates better when it comes to reusing the payload ids.\n\nMy change in MergeCodecs adds the payload ids of the duplicates to the used_pltypes. Before, the payload ids of the duplicates would be ignored because the algorithm would think the codec is already offered (contained in offered_codecs). This led to unwanted payload id reuse.\n\nYou suggest the opposite: \"removing their payload types from the set\". Can you describe your reasoning?",
      "parentUuid": "036f8e48_aeac3cd6",
      "revId": "6f83e00fbdf300785dec844b117b3ccfc0778020",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a3e2210_aa36dfef",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 18169
      },
      "writtenOn": "2023-12-11T09:44:51Z",
      "side": 1,
      "message": "Splitting from another comment:\n\n\u003e It\u0027s a bit hard to think through all the ramifications of this... Maybe we just wait until we have a different way of representing this in SDP?\n\nI agree that it\u0027s hard. It\u0027s also worrying that the test coverage is probably not the best given that it let the basic e2ee flow regress by https://webrtc-review.googlesource.com/c/src/+/326522.\n\nDo other reviewers agree that https://bugs.chromium.org/p/webrtc/issues/detail?id\u003d15473#c10 can be left unfixed till we rectify the non-standard packetization signaling? Note that workaround has been implemented on JS side - munge SDP to undo any attempts of WebRTC to reuse a payload id that JS has previously \"allocated\" for a raw codec.",
      "revId": "6f83e00fbdf300785dec844b117b3ccfc0778020",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7a19c30a_41fbf9a5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5053
      },
      "writtenOn": "2023-12-12T01:10:32Z",
      "side": 1,
      "message": "Sorry, I was thinking \"remove payload types from the set of available ids\", you figured out what I meant.\n\nHave you uploaded that patchset yet? What I\u0027m talking about is reverting most the changes in this CL, and doing this in MergeCodecs:\n\n```\n  for (const Codec\u0026 reference_codec : reference_codecs) {\n    if (reference_codec.GetResiliencyType() !\u003d Codec::ResiliencyType::kRtx \u0026\u0026\n        reference_codec.GetResiliencyType() !\u003d Codec::ResiliencyType::kRed) {\n      Codec codec \u003d reference_codec;\n      used_pltypes-\u003eFindAndSetIdUsed(\u0026codec);\n      if (!FindMatchingCodec(reference_codecs, *offered_codecs, reference_codec,\n                             /*ignore_packetization\u003d*/false)) {\n        offered_codecs-\u003epush_back(codec);\n      }\n    }\n  }\n  ```\n  \nThough I guess we would only want this done when called from MergeCodecsFromDescription, otherwise we\u0027ll be adding extra used payload types when merging from the reference codecs...",
      "parentUuid": "2dca0fe7_6623217f",
      "revId": "6f83e00fbdf300785dec844b117b3ccfc0778020",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8829eb66_f08b4ad4",
        "filename": "pc/media_session.cc",
        "patchSetId": 5
      },
      "lineNbr": 829,
      "author": {
        "id": 5053
      },
      "writtenOn": "2023-12-07T21:59:22Z",
      "side": 1,
      "message": "Is this going to be a problem? If we offer both default and raw packetization codecs, and both are also locally supported, then it seems like the raw packetization codec will match the default packetization (if it appears first) and then be set back to default by this function",
      "revId": "6f83e00fbdf300785dec844b117b3ccfc0778020",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3c60f50_b8176d3a",
        "filename": "pc/media_session.cc",
        "patchSetId": 5
      },
      "lineNbr": 829,
      "author": {
        "id": 5053
      },
      "writtenOn": "2023-12-12T01:10:32Z",
      "side": 1,
      "message": "I think this comment is still applicable, though not something Meet will run into as the client is always the offerer.",
      "parentUuid": "8829eb66_f08b4ad4",
      "revId": "6f83e00fbdf300785dec844b117b3ccfc0778020",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "954c0cf5_f3552cd1",
        "filename": "pc/media_session_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 4402,
      "author": {
        "id": 5053
      },
      "writtenOn": "2023-12-07T21:59:22Z",
      "side": 1,
      "message": "So the issue here was that the raw codecs were negotiated away since they didn\u0027t match the built-in supported codecs? Could we instead add raw variants to the set of supported codecs to address this? Or... is it not possible to add something to the set of supported codecs without also offering it by default (which we don\u0027t want)? If it were possible to change that, I think that would be the ideal solution.",
      "revId": "6f83e00fbdf300785dec844b117b3ccfc0778020",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "788ba7bb_6537cf2e",
        "filename": "pc/media_session_unittest.cc",
        "patchSetId": 5
      },
      "lineNbr": 4402,
      "author": {
        "id": 5053
      },
      "writtenOn": "2023-12-12T01:10:32Z",
      "side": 1,
      "message": "Not relevant anymore if we go with the approach described in the other comment",
      "parentUuid": "954c0cf5_f3552cd1",
      "revId": "6f83e00fbdf300785dec844b117b3ccfc0778020",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}