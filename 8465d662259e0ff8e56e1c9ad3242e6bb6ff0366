{
  "comments": [
    {
      "key": {
        "uuid": "d4c1704f_adcc07c9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 9,
      "author": {
        "id": 5100
      },
      "writtenOn": "2018-12-05T08:39:50Z",
      "side": 1,
      "message": "Slightly wonky format for this comment.",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 9,
        "endChar": 41
      },
      "revId": "8465d662259e0ff8e56e1c9ad3242e6bb6ff0366",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7fc33453_486a5179",
        "filename": "api/audio_codecs/audio_decoder.h",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 5126
      },
      "writtenOn": "2018-12-03T16:28:50Z",
      "side": 1,
      "message": "Actually, it looks like what we should do is override ParsePayload instead. These two are legacy methods that someone should clean away at some point. (The basic idea there is that NetEQ wants to parse packets immediately and put them in a queue, and then decode them on-demand. In order to make this type safe and nice, we represent the parsed-but-not-yet-decoded packets as instances of EncodedAudioFrame.)\n\n+CC Henrik and Oskar, to verify I\u0027m not making this up. I haven\u0027t touched this code in a while...",
      "revId": "8465d662259e0ff8e56e1c9ad3242e6bb6ff0366",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ff22d61_3f996c8e",
        "filename": "api/audio_codecs/audio_decoder.h",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 5399
      },
      "writtenOn": "2018-12-03T16:59:06Z",
      "side": 1,
      "message": "All of this is made up! What you\u0027re saying is correct, though. :)\nIf you need to change the behavior of Decode/DecodeRedundant, you should override DecodeInternal och DecodeRedundantInternal, below, instead. I don\u0027t see why changing the old APIs wouldn\u0027t work, but since we want to get rid of \u0027em, don\u0027t use \u0027em!",
      "parentUuid": "7fc33453_486a5179",
      "revId": "8465d662259e0ff8e56e1c9ad3242e6bb6ff0366",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71b917f8_4a2133ee",
        "filename": "api/audio_codecs/audio_decoder.h",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 5126
      },
      "writtenOn": "2018-12-03T18:29:22Z",
      "side": 1,
      "message": "He wants to make a forwarding wrapper, and with the current state of the interface, his DecodeInternal has to call the wrapee\u0027s Decode, which is nontrivial because it has to reconstruct implicit parameters.",
      "parentUuid": "0ff22d61_3f996c8e",
      "revId": "8465d662259e0ff8e56e1c9ad3242e6bb6ff0366",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "94cd8772_6927b75a",
        "filename": "api/audio_codecs/audio_decoder.h",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 5126
      },
      "writtenOn": "2018-12-06T08:02:42Z",
      "side": 1,
      "message": "Niels, does your wrapper still work if you assume that all calls go through ParsePayload, and you implement DecodeInternal as RTC_NOTREACHED()?",
      "parentUuid": "71b917f8_4a2133ee",
      "revId": "8465d662259e0ff8e56e1c9ad3242e6bb6ff0366",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e5f3675_c07d0a8c",
        "filename": "api/audio_codecs/audio_decoder.h",
        "patchSetId": 2
      },
      "lineNbr": 114,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-06T10:31:15Z",
      "side": 1,
      "message": "Undoing the overrides of Decode and DecodeInternal (and hence no longer virtual), and it seems to still work\u0027",
      "parentUuid": "94cd8772_6927b75a",
      "revId": "8465d662259e0ff8e56e1c9ad3242e6bb6ff0366",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b562fbee_fdad1c5b",
        "filename": "modules/audio_coding/neteq/neteq_impl_unittest.cc",
        "patchSetId": 2
      },
      "lineNbr": 535,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-03T14:20:16Z",
      "side": 1,
      "message": "This is where the test fails.",
      "range": {
        "startLine": 532,
        "startChar": 0,
        "endLine": 535,
        "endChar": 37
      },
      "revId": "8465d662259e0ff8e56e1c9ad3242e6bb6ff0366",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "45d7e9c3_0955d3ad",
        "filename": "modules/audio_coding/neteq/neteq_impl_unittest.cc",
        "patchSetId": 2
      },
      "lineNbr": 535,
      "author": {
        "id": 5100
      },
      "writtenOn": "2018-12-05T08:39:50Z",
      "side": 1,
      "message": "Does your new decoder produce the same number of samples in each decode call as the old code did?",
      "parentUuid": "b562fbee_fdad1c5b",
      "range": {
        "startLine": 532,
        "startChar": 0,
        "endLine": 535,
        "endChar": 37
      },
      "revId": "8465d662259e0ff8e56e1c9ad3242e6bb6ff0366",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "75c64c3f_2b31846f",
        "filename": "modules/audio_coding/neteq/neteq_impl_unittest.cc",
        "patchSetId": 2
      },
      "lineNbr": 535,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-05T14:47:57Z",
      "side": 1,
      "message": "I\u0027m running the failing test as \n\n$ ./out/Debug/modules_unittests --logs --gtest_filter\u003dNetEqImplTest.VerifyTimestampPropagation\n\nI\u0027ve added a debug printout in CountingSamplesDecoder::DecodeInternal, and both before and after my cl I see a single call, and at entry, I have next_value_ \u003d\u003d 1 and encoded_len_ \u003d\u003d 80.",
      "parentUuid": "45d7e9c3_0955d3ad",
      "range": {
        "startLine": 532,
        "startChar": 0,
        "endLine": 535,
        "endChar": 37
      },
      "revId": "8465d662259e0ff8e56e1c9ad3242e6bb6ff0366",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8ec7baa_2133792a",
        "filename": "modules/audio_coding/neteq/neteq_impl_unittest.cc",
        "patchSetId": 2
      },
      "lineNbr": 535,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-12-05T15:42:40Z",
      "side": 1,
      "message": "This is what |output| looks like in the debugger before my cl:\n\n {timestamp_ \u003d 305419891, elapsed_time_ms_ \u003d -1, \n  ntp_time_ms_ \u003d -1, samples_per_channel_ \u003d 80, \n  sample_rate_hz_ \u003d 8000, num_channels_ \u003d 1, \n  speech_type_ \u003d webrtc::AudioFrame::kNormalSpeech, \n  vad_activity_ \u003d webrtc::AudioFrame::kVadUnknown, \n  profile_timestamp_ms_ \u003d 0, data_ \u003d {0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, \n    7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, \n    24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, \n    40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, \n    56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, \n    72, 73, 74, 75, 0 \u003crepeats 7600 times\u003e}, muted_ \u003d false}\n\nAnd after:\n\n {timestamp_ \u003d 305419966, elapsed_time_ms_ \u003d -1, \n  ntp_time_ms_ \u003d -1, samples_per_channel_ \u003d 80, \n  sample_rate_hz_ \u003d 8000, num_channels_ \u003d 1, \n  speech_type_ \u003d webrtc::AudioFrame::kUndefined, \n  vad_activity_ \u003d webrtc::AudioFrame::kVadUnknown, \n  profile_timestamp_ms_ \u003d 0, data_ \u003d {0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, \n    7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, \n    24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, \n    40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, \n    56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, \n    72, 73, 74, 75, 0 \u003crepeats 7600 times\u003e}, muted_ \u003d false}\n\nA few things to note: \n\n1. The data isn\u0027t {1,2,3, ..., 80}, as is produced by the decoder; we get 5 initial zero samples. No idea why, but that\u0027s the same before and after.\n\n2. The timestamp differs, larger by 75 units after the cl.\n\n3. The cl changes |speech_type_| from kNormalSpeech to kUndefined. It\u0027s not clear to me how the setting of that attribute works. The decoder sets |*speech_type \u003d kSpeech;|, but that\u0027s a different enum. As far as I see, neteq_impl.cc assigns speech_type_ only in SetAudioFrameActivityAndType(), and never to kUndefined, which is the default value on construction of AudioFrame. Which seems to imply that SetAudioFrameActivityAndType never is called after the cl.\n\nI\u0027m a bit lost.",
      "parentUuid": "75c64c3f_2b31846f",
      "range": {
        "startLine": 532,
        "startChar": 0,
        "endLine": 535,
        "endChar": 37
      },
      "revId": "8465d662259e0ff8e56e1c9ad3242e6bb6ff0366",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}