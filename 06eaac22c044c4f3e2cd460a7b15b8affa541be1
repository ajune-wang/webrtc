{
  "comments": [
    {
      "key": {
        "uuid": "3f69f3a1_f7f75f5a",
        "filename": "modules/audio_coding/neteq/neteq_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 909,
      "author": {
        "id": 5607
      },
      "writtenOn": "2020-01-31T12:51:03Z",
      "side": 1,
      "message": "If we\u0027re measuring jitter buffer delay, shouldn\u0027t the clock start ticking when the packet reaches NetEq? In that case there would be no need to pass the receive time to the InsertPacket function, as it could be measured inside of NetEq.",
      "range": {
        "startLine": 909,
        "startChar": 15,
        "endLine": 909,
        "endChar": 34
      },
      "revId": "06eaac22c044c4f3e2cd460a7b15b8affa541be1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5291e2b1_2ed919b1",
        "filename": "modules/audio_coding/neteq/neteq_impl.cc",
        "patchSetId": 1
      },
      "lineNbr": 909,
      "author": {
        "id": 5963
      },
      "writtenOn": "2020-01-31T13:45:56Z",
      "side": 1,
      "message": "As per w3c spec: \"It is the sum of the time, in seconds, each audio sample or video frame takes from the time it is received and to the time it exits the jitter buffer.\"\n\nThere is no other stat that calculates the time from when a sample is received to the time it enters the jitterBuffer, so IMHO this is the correct approach. @hbos could you confirm?",
      "parentUuid": "3f69f3a1_f7f75f5a",
      "range": {
        "startLine": 909,
        "startChar": 15,
        "endLine": 909,
        "endChar": 34
      },
      "revId": "06eaac22c044c4f3e2cd460a7b15b8affa541be1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e48b18a3_ee98126f",
        "filename": "modules/audio_coding/neteq/sync_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 5607
      },
      "writtenOn": "2020-01-31T12:51:03Z",
      "side": 1,
      "message": "This looks potentially expensive. Have you checked the impact on the perf tests? Deleting items that are not at the end of a vector cause everything after the item to be copied. How about a ring buffer instead?\n\nAlso: is there a way to avoid updating every element?",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 34,
        "endChar": 3
      },
      "revId": "06eaac22c044c4f3e2cd460a7b15b8affa541be1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "91d5cb6c_b2865c2a",
        "filename": "modules/audio_coding/neteq/sync_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 5963
      },
      "writtenOn": "2020-01-31T13:45:56Z",
      "side": 1,
      "message": "How do I check the perf tests? Note that there is only one entre per packet, and I think that the max jitterbuffe size is 20 packets, so the list won\u0027t be too big. A ring buffer could do it, just didn\u0027t wanted to add too many changes for reviewing.",
      "parentUuid": "e48b18a3_ee98126f",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 34,
        "endChar": 3
      },
      "revId": "06eaac22c044c4f3e2cd460a7b15b8affa541be1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f817ee5d_b69f5af6",
        "filename": "modules/audio_coding/neteq/sync_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 5607
      },
      "writtenOn": "2020-01-31T15:51:14Z",
      "side": 1,
      "message": "On a release build you can run (before and after applying your change): \nout/Release/webrtc_perf_tests --gtest_filter\u003dNetEqPerformanceTest*\nThe output lines starting with *RESULT contain the duration.\nIf the impact is not too big I\u0027m fine with the current code, but I\u0027d like to see the numbers.",
      "parentUuid": "91d5cb6c_b2865c2a",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 34,
        "endChar": 3
      },
      "revId": "06eaac22c044c4f3e2cd460a7b15b8affa541be1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdc3d211_4079bc5d",
        "filename": "modules/audio_coding/neteq/sync_buffer.cc",
        "patchSetId": 1
      },
      "lineNbr": 34,
      "author": {
        "id": 5963
      },
      "writtenOn": "2020-01-31T20:17:55Z",
      "side": 1,
      "message": "Patch version:\n\n(field_trial.cc:140): Setting field trial string:\nNote: Google Test filter \u003d NetEqPerformanceTest*\n[\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d] Running 2 tests from 1 test suite.\n[----------] Global test environment set-up.\n[----------] 2 tests from NetEqPerformanceTest\n[ RUN      ] NetEqPerformanceTest.Run\n(delay_manager.cc:73): Delay histogram config: quantile\u003d1041529569 forget_factor\u003d32745 start_forget_weight\u003d2\n(decision_logic.cc:55): NetEq decision logic settings: estimate_dtx_delay\u003d0 time_stretch_cn\u003d0 target_level_window_ms\u003d100\n(neteq_impl.cc:144): NetEq config: sample_rate_hz\u003d32000, enable_post_decode_vad\u003dfalse, max_packets_in_buffer\u003d200, min_delay_ms\u003d0, enable_fast_accelerate\u003dfalse, enable_muted_state\u003dfalse, enable_rtx_handling\u003dfalse\n*RESULT neteq_performance: 10_pl_10_drift\u003d 5113 ms\n[       OK ] NetEqPerformanceTest.Run (5120 ms)\n[ RUN      ] NetEqPerformanceTest.RunClean\n(delay_manager.cc:73): Delay histogram config: quantile\u003d1041529569 forget_factor\u003d32745 start_forget_weight\u003d2\n(decision_logic.cc:55): NetEq decision logic settings: estimate_dtx_delay\u003d0 time_stretch_cn\u003d0 target_level_window_ms\u003d100\n(neteq_impl.cc:144): NetEq config: sample_rate_hz\u003d32000, enable_post_decode_vad\u003dfalse, max_packets_in_buffer\u003d200, min_delay_ms\u003d0, enable_fast_accelerate\u003dfalse, enable_muted_state\u003dfalse, enable_rtx_handling\u003dfalse\n*RESULT neteq_performance: 0_pl_0_drift\u003d 3401 ms\n[       OK ] NetEqPerformanceTest.RunClean (3402 ms)\n[----------] 2 tests from NetEqPerformanceTest (8531 ms total)\n\n[----------] Global test environment tear-down\n[\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d] 2 tests from 1 test suite ran. (8537 ms total)\n[  PASSED  ] 2 tests.\n\nOriginal code:\n\nNote: Google Test filter \u003d NetEqPerformanceTest*\n[\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d] Running 2 tests from 1 test suite.\n[----------] Global test environment set-up.\n[----------] 2 tests from NetEqPerformanceTest\n[ RUN      ] NetEqPerformanceTest.Run\n(delay_manager.cc:73): Delay histogram config: quantile\u003d1041529569 forget_factor\u003d32745 start_forget_weight\u003d2\n(decision_logic.cc:55): NetEq decision logic settings: estimate_dtx_delay\u003d0 time_stretch_cn\u003d0 target_level_window_ms\u003d100\n(neteq_impl.cc:144): NetEq config: sample_rate_hz\u003d32000, enable_post_decode_vad\u003dfalse, max_packets_in_buffer\u003d200, min_delay_ms\u003d0, enable_fast_accelerate\u003dfalse, enable_muted_state\u003dfalse, enable_rtx_handling\u003dfalse\n*RESULT neteq_performance: 10_pl_10_drift\u003d 4654 ms\n[       OK ] NetEqPerformanceTest.Run (4655 ms)\n[ RUN      ] NetEqPerformanceTest.RunClean\n(delay_manager.cc:73): Delay histogram config: quantile\u003d1041529569 forget_factor\u003d32745 start_forget_weight\u003d2\n(decision_logic.cc:55): NetEq decision logic settings: estimate_dtx_delay\u003d0 time_stretch_cn\u003d0 target_level_window_ms\u003d100\n(neteq_impl.cc:144): NetEq config: sample_rate_hz\u003d32000, enable_post_decode_vad\u003dfalse, max_packets_in_buffer\u003d200, min_delay_ms\u003d0, enable_fast_accelerate\u003dfalse, enable_muted_state\u003dfalse, enable_rtx_handling\u003dfalse\n*RESULT neteq_performance: 0_pl_0_drift\u003d 2987 ms\n[       OK ] NetEqPerformanceTest.RunClean (2988 ms)\n[----------] 2 tests from NetEqPerformanceTest (7651 ms total)\n\n[----------] Global test environment tear-down\n[\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d] 2 tests from 1 test suite ran. (7658 ms total)\n[  PASSED  ] 2 tests.\n\n\nso from 7658ms to 8537ms, which seems a bit high, what would be the acceptable range?",
      "parentUuid": "f817ee5d_b69f5af6",
      "range": {
        "startLine": 27,
        "startChar": 2,
        "endLine": 34,
        "endChar": 3
      },
      "revId": "06eaac22c044c4f3e2cd460a7b15b8affa541be1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bf811555_b1c979b0",
        "filename": "modules/audio_coding/neteq/sync_buffer.h",
        "patchSetId": 1
      },
      "lineNbr": 143,
      "author": {
        "id": 5607
      },
      "writtenOn": "2020-01-31T13:08:10Z",
      "side": 1,
      "message": "Is it necessary to store the whole RtpPacketInfo here? Could we store just the timestamps instead?",
      "range": {
        "startLine": 143,
        "startChar": 44,
        "endLine": 143,
        "endChar": 57
      },
      "revId": "06eaac22c044c4f3e2cd460a7b15b8affa541be1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0403d69_3e01df4a",
        "filename": "modules/audio_coding/neteq/sync_buffer.h",
        "patchSetId": 1
      },
      "lineNbr": 143,
      "author": {
        "id": 5963
      },
      "writtenOn": "2020-01-31T13:45:56Z",
      "side": 1,
      "message": "There was another issue that said that the per-frame packet info was desirable to be stored on the sync buffer:\nhttps://bugs.chromium.org/p/webrtc/issues/detail?id\u003d10757\n\nThe packet_infos are already allocated on neteq, so if they are moved correctly (I think they do), this should not be so expensive.",
      "parentUuid": "bf811555_b1c979b0",
      "range": {
        "startLine": 143,
        "startChar": 44,
        "endLine": 143,
        "endChar": 57
      },
      "revId": "06eaac22c044c4f3e2cd460a7b15b8affa541be1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e1ff4088_8cfb11f2",
        "filename": "modules/audio_coding/neteq/sync_buffer.h",
        "patchSetId": 1
      },
      "lineNbr": 143,
      "author": {
        "id": 5607
      },
      "writtenOn": "2020-01-31T15:51:14Z",
      "side": 1,
      "message": "Can you indicate where the move happens? Note that RtpPacketInfo is a mostly-POD struct (ignoring the small vector), which means moving is no more efficient than copying.",
      "parentUuid": "c0403d69_3e01df4a",
      "range": {
        "startLine": 143,
        "startChar": 44,
        "endLine": 143,
        "endChar": 57
      },
      "revId": "06eaac22c044c4f3e2cd460a7b15b8affa541be1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1842d613_13b49c67",
        "filename": "modules/audio_coding/neteq/sync_buffer.h",
        "patchSetId": 1
      },
      "lineNbr": 143,
      "author": {
        "id": 5963
      },
      "writtenOn": "2020-01-31T20:17:55Z",
      "side": 1,
      "message": "My bad, I had a couple of std::move on my chrome build, but it gave warnings when compiling webrtc standalone, so I had to remove it.",
      "parentUuid": "e1ff4088_8cfb11f2",
      "range": {
        "startLine": 143,
        "startChar": 44,
        "endLine": 143,
        "endChar": 57
      },
      "revId": "06eaac22c044c4f3e2cd460a7b15b8affa541be1",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}