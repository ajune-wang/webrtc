{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4ab9f599_ebce0f52",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-12-21T14:31:28Z",
      "side": 1,
      "message": "How often are key frames requested by the receiver when 0 Hz mode is used by the sender?\n\nIs there anything about 0 Hz that would trigger key frames more or less often than in non-0 Hz mode? For example, is the receiver surprised by not receiving high fps? Do we quickly reach a stable 1 fps or will key frames repeatedly happen causing \u003e1 fps?",
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7c535c85_de77fe8a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 9515
      },
      "writtenOn": "2021-12-21T18:16:26Z",
      "side": 1,
      "message": "\u003eHow often are key frames requested by the receiver when 0 Hz mode is used by the sender?\n\nNot more often than before hopefully! There\u0027s a 1 Hz repeat-send mode implemented exactly to counter receivers and backends reacting to no frames after a while.\n\nFor more details see go/rtc-0hz-present.",
      "parentUuid": "4ab9f599_ebce0f52",
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e0f98ed0_e48adb38",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-12-21T12:19:23Z",
      "side": 1,
      "message": "api/ lgtm",
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cc884be2_38e1a86a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-12-21T14:31:28Z",
      "side": 1,
      "message": "Just comments on comments, so +1 % those",
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df028e0e_5d0089b2",
        "filename": "api/video/video_source_interface.h",
        "patchSetId": 4
      },
      "lineNbr": 103,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-12-21T12:19:23Z",
      "side": 1,
      "message": "Makes sense to me.\n\nIf the main use of this method is to ask for a new frame when starting to send a new stream, consider if there\u0027s some way to have that happen automatically, e.g., as a result of AddOrUpdateSink that adds a new source, or at higher level closer to corresponding PeerConnection methods.",
      "range": {
        "startLine": 101,
        "startChar": 0,
        "endLine": 103,
        "endChar": 39
      },
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e331e6b8_f1ef82a5",
        "filename": "api/video/video_source_interface.h",
        "patchSetId": 4
      },
      "lineNbr": 103,
      "author": {
        "id": 9515
      },
      "writtenOn": "2021-12-21T12:25:55Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "df028e0e_5d0089b2",
      "range": {
        "startLine": 101,
        "startChar": 0,
        "endLine": 103,
        "endChar": 39
      },
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32d02673_93885ad2",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 4
      },
      "lineNbr": 141,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-12-21T14:31:28Z",
      "side": 1,
      "message": "Is \"quality converged\" a well-understood concept or should you add some more context? I\u0027d like a comment to capture what quality converging means and how that changes the behavior of the adapter, e.g. going into 1 Hz idle repeat mode. When is non-SVC converged?",
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "87c93d34_0c9c4fb8",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 4
      },
      "lineNbr": 141,
      "author": {
        "id": 9515
      },
      "writtenOn": "2021-12-21T18:16:26Z",
      "side": 1,
      "message": "Updated the comment and in the header file. It\u0027s when all spatial layers have dropped to low enough QP to warrant the ceasing of repeating identical frames at high frequency.",
      "parentUuid": "32d02673_93885ad2",
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6efbbfc9_99370dec",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 4
      },
      "lineNbr": 388,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-12-21T14:31:28Z",
      "side": 1,
      "message": "How do we know if quality has converged? If I read the code correctly it looks like this happens based on encoder feedback, not based on RTCP information.\n\nWhat happens if SVC layers don\u0027t reach the receiver? I guess we\u0027ll consider quality converged until we receive a key frame request, which should restore things (unless those frames goes missing too)?\n\n(Not asking you to change anything, just wondering how it works)",
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "57b25a05_999e8fba",
        "filename": "video/frame_cadence_adapter.cc",
        "patchSetId": 4
      },
      "lineNbr": 388,
      "author": {
        "id": 9515
      },
      "writtenOn": "2021-12-21T18:16:26Z",
      "side": 1,
      "message": "\u003e What happens if SVC layers don\u0027t reach the receiver?\n\nYou mean if a layer is disabled? In that case the layer is considered converged. Note: all the quality logic was added in https://webrtc-review.googlesource.com/c/src/+/241421, this CL merely swizzels it around.",
      "parentUuid": "6efbbfc9_99370dec",
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "049fae7d_f4bb66eb",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 4
      },
      "lineNbr": 1825,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-12-21T12:13:03Z",
      "side": 1,
      "message": "Call this unconditionally on stream startup?\n\n(Or arrange so that some other method at startup (maybe AddTrack, AddOrUpdateSink, ...) ensures that the VideoSource produces a new frame shortly).",
      "range": {
        "startLine": 1825,
        "startChar": 0,
        "endLine": 1825,
        "endChar": 58
      },
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1032640a_f4ddea2e",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 4
      },
      "lineNbr": 1825,
      "author": {
        "id": 9515
      },
      "writtenOn": "2021-12-21T12:25:55Z",
      "side": 1,
      "message": "Yep we discussed this offline and initially it sounded like a good idea. After some thought I think this might however be a bad idea:\n\nIf the shared content is in fact animating media, then the refresh frame will unconditionally be inserted in a stream of 30 Hz content, leading to local frame spacings being lower than 1/30. That will cause the encoder to use too much BW for the frames and lead to bitrate debt.\n\nThe alternative is better. The probability of a remote keyframe request happens at the same time as the source is beginning to burp out frames is very small in comparison.",
      "parentUuid": "049fae7d_f4bb66eb",
      "range": {
        "startLine": 1825,
        "startChar": 0,
        "endLine": 1825,
        "endChar": 58
      },
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be373d5e_d20e1ffc",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 4
      },
      "lineNbr": 1825,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-12-21T12:44:55Z",
      "side": 1,
      "message": "\u003e If the shared content is in fact animating media, then the refresh frame will unconditionally be inserted in a stream of 30 Hz content, leading to local frame spacings being lower than 1/30. That will cause the encoder to use too much BW for the frames and lead to bitrate debt.\n\nBut a source that is producing frames with a reasonably high fps could just ignore the RequestRefreshFrame call. If we think of it as not \"please give me an extra frame\" but \"please make sure I get some frame real soon\".",
      "parentUuid": "1032640a_f4ddea2e",
      "range": {
        "startLine": 1825,
        "startChar": 0,
        "endLine": 1825,
        "endChar": 58
      },
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e8115dec_9838804d",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 4
      },
      "lineNbr": 1825,
      "author": {
        "id": 9515
      },
      "writtenOn": "2021-12-21T18:16:26Z",
      "side": 1,
      "message": "Yeah it\u0027s a point but we would rely on specific capturer implementation.\n\nI just realized there are other problems with asking for refresh frames on sink addition or similar. One precondition for entering Zero-hertz mode is that specific constraints are setup. Source setup and constraints setup are not guaranteed to be synchronized. So to make robust code we do need to ask first when the mode has been activated so as to not miss out if the constraints setup happens later. I think the current approach is better.",
      "parentUuid": "be373d5e_d20e1ffc",
      "range": {
        "startLine": 1825,
        "startChar": 0,
        "endLine": 1825,
        "endChar": 58
      },
      "revId": "e9fa3aaa0fc723cb058b6b10a98eb53d262418bc",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}