{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6ed3dbdf_ab158b8e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 18474
      },
      "writtenOn": "2023-03-13T18:11:39Z",
      "side": 1,
      "message": "Salman recently added some eventing, and I think long term the goal would be to try to leverage that, which it looks like this breaks.\n\nFurther, it\u0027s worth the discussion of if the (potential) reduced processing power now makes up for the increased memory (to store this extra buffer on top of the frame queue now) and latency (to process the buffer upon demand).\n\nIs this mostly a theoretical or are there metrics about devices that seem to be adversely affected by the current behavior and how this change improves those devices?",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f4982970_097278f0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 8046
      },
      "writtenOn": "2023-03-13T18:34:44Z",
      "side": 1,
      "message": "It\u0027s true that it will not play well with Salman\u0027s workflow, because we now process frames only once they are requested :-/.\n\nIncreased memory won\u0027t be much a problem, because the buffer doesn\u0027t carry the frame itself, only its information (size, stride, etc.) and file descriptor.\n\nMartin Stránský said he saw a drop in CPU usage, but we didn\u0027t do any exact measurement so it\u0027s also somewhat theoretical.",
      "parentUuid": "6ed3dbdf_ab158b8e",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ed73e568_d2b0c447",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 18474
      },
      "writtenOn": "2023-03-13T18:38:45Z",
      "side": 1,
      "message": "\u003e Increased memory won\u0027t be much a problem, because the buffer doesn\u0027t carry the frame itself, only its information (size, stride, etc.) and file descriptor.\n\nPresumably this means that *somewhere* on the system has to hold onto the frame longer than it would otherwise though right? What lifetime guarantees do we have on this frame/buffer?",
      "parentUuid": "f4982970_097278f0",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "18372050_ad27f170",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 8046
      },
      "writtenOn": "2023-03-13T18:47:27Z",
      "side": 1,
      "message": "That\u0027s right, but I also expect that it doesn\u0027t change anything since the compositor allocates few buffers upfront which are recycled over and over and might not get freed anyway until they are actually reused. \n\nI asked Wim Taymans (PipeWire author), he said there is a mechanism to refcount busy buffers and they will not get used until we queue them back. It should be safe to hold them until we use another one or until we stop streaming.",
      "parentUuid": "ed73e568_d2b0c447",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a83f723_f2f747a2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 8046
      },
      "writtenOn": "2023-03-13T18:52:17Z",
      "side": 1,
      "message": "I can modify it to check whether the callback Salman is using is set and in such case process the buffer right away. That would cover both cases, where one want\u0027s to get the frame as soon as possible and also avoid processing buffers that we are not going to consume.\n\nWould that work for you?",
      "parentUuid": "18372050_ad27f170",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d1443f0_7f1f99d8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 19629
      },
      "writtenOn": "2023-03-13T20:06:34Z",
      "side": 1,
      "message": "Sounds reasonable to me.\n\nWDYT, Alex?",
      "parentUuid": "2a83f723_f2f747a2",
      "range": {
        "startLine": 10,
        "startChar": 14,
        "endLine": 12,
        "endChar": 31
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f93c024f_58a11b73",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 13,
      "author": {
        "id": 19629
      },
      "writtenOn": "2023-03-13T20:06:34Z",
      "side": 1,
      "message": "For applications that are using CaptureFrame API, this is going to add some capture latency (especially for bigger frames) since processing is being done at the time of the capture now. May be we should also experiment to see if the delay is palpable with higher resolution, if so it will be a good idea to keep on processing and caching frames eagerly. It is hard to say without some benchmarking how much processing power was being wasted earlier and whether capturing/processing lazily would add any significant delay.",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 13,
        "endChar": 35
      },
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "778c5299_688078cf",
        "filename": "modules/desktop_capture/linux/wayland/shared_screencast_stream.cc",
        "patchSetId": 2
      },
      "lineNbr": 609,
      "author": {
        "id": 19629
      },
      "writtenOn": "2023-03-13T20:06:34Z",
      "side": 1,
      "message": "If it is non-null, should we return it back to the pool first (with `pw_stream_queue_buffer`) or does it not matter at cleanup time?",
      "revId": "ee85c84abc6e55d10d3af961c79ba86c2a468118",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}