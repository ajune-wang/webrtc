{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c88de80e_26cc2935",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-09-13T09:40:35Z",
      "side": 1,
      "message": "Can you share more details how do you plan to use this enum in the api?\n\nthe linked bug may be confuses id and type of an extension. They are not the same.\nThere is 1:1 relation between type and uri, but id has a different meaning\n(there is 1:1 relation between uri and id, but that mapping is local to a webrtc session)\n\nRTPExtensionType enum is sort-of internal representation of a known extension uri.\nRtpExtension is designed to also carry uris that are not known.\nfor internal webrtc usage there is RtpHeaderExtensionMap class that does id\u003c-\u003etype mapping.\n",
      "revId": "f8917d6303f1bd50f1aee6cea6a47650fc586127",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8e01d546_7e623eaf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-13T10:09:25Z",
      "side": 1,
      "message": "Instinctively, I\u0027d prefer to keep this enum an implementation detail.\n\nRTP header extensions is a \"no registration needed\" field (identified by URI), so we are guaranteed to encounter extensions that we haven\u0027t seen before, and we\u0027re guaranteed to want to expand the list over time. Both actions cause breakages with an API-exposed enum that covers all the RTP extensions we support.\n\nThe ID in the header is a negotiated value; it does not map to the enum.\n\n",
      "revId": "f8917d6303f1bd50f1aee6cea6a47650fc586127",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0c9a7361_50a89d81",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-09-14T09:36:18Z",
      "side": 1,
      "message": "Thanks both - yes, I was misunderstanding (or rather, getting confused by) the enum and use of both constants and literals for the uris in the code. The uris seem to be what we should be using consistently and enforcing use of the constants somehow, ideally. I\u0027ll abandon this CL and rethink the approach (not urgent).",
      "revId": "f8917d6303f1bd50f1aee6cea6a47650fc586127",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2bdedd99_1596c946",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-14T09:55:46Z",
      "side": 1,
      "message": "What I\u0027d be thinking about is a single registry for supported URLs in some module (possibly with register-on-load or register-in-linker if possible, so that supported URLs can be in the source together with the code that supports them) that can map an URL to an internal representation that is a) unique and b) fast to compare.\n\nThen everything that parses URLs coming from external sources go to this single registry in order to get the answer to 1) is it supported, and 2) what code do I use when passing it to other places.\n\nAn opaque type that has a hidden inner value that is a pointer to the registry entry would do fine (and make the \"map this to its text representation\" function very quick).",
      "parentUuid": "0c9a7361_50a89d81",
      "revId": "f8917d6303f1bd50f1aee6cea6a47650fc586127",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "298bf4e1_a982c534",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-09-14T09:55:46Z",
      "side": 1,
      "message": "Trying to exercise imagination....\n",
      "revId": "f8917d6303f1bd50f1aee6cea6a47650fc586127",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b16de827_6863371f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 5
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-01-25T15:12:10Z",
      "side": 1,
      "message": "Sounds very much like the \"intern\" function, as found in handling of lisp symbols, as well as \"atoms\" in the X11 protocol. One drawback is that the the \"interned representation\", more or less a pointer to an entry in a hashtable (traditionally called the \"obarray\") then won\u0027t be a compile time constant.",
      "parentUuid": "2bdedd99_1596c946",
      "revId": "f8917d6303f1bd50f1aee6cea6a47650fc586127",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}