{
  "comments": [
    {
      "key": {
        "uuid": "b6ebe9f6_211c9215",
        "filename": "pc/dtls_transport.cc",
        "patchSetId": 5
      },
      "lineNbr": 120,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-02-13T08:52:24Z",
      "side": 1,
      "message": "Can the internal object be modified on the network thread in other places which are unaware of this lock?",
      "revId": "df6e20b8a855e7f12d8e61bc7edb5ed4653d6874",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48ee1b96_fb62ba09",
        "filename": "pc/dtls_transport.cc",
        "patchSetId": 5
      },
      "lineNbr": 120,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-02-13T08:56:23Z",
      "side": 1,
      "message": "Nevermind, this always happens on the network thread and is therefor safe. Please add a thread check in this helper function too.",
      "parentUuid": "b6ebe9f6_211c9215",
      "revId": "df6e20b8a855e7f12d8e61bc7edb5ed4653d6874",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b7af3493_8a3f7a11",
        "filename": "pc/dtls_transport.cc",
        "patchSetId": 5
      },
      "lineNbr": 120,
      "author": {
        "id": 5634
      },
      "writtenOn": "2019-02-13T09:27:14Z",
      "side": 1,
      "message": "Done.\n(this imposes the additional requirement that this function is called without any additional locks captured after the calling function\u0027s RTC_DCHECK_RUN_ON - otherwise TSAN will complain about a lock sequence inversion. It ain\u0027t easy....)",
      "parentUuid": "48ee1b96_fb62ba09",
      "revId": "df6e20b8a855e7f12d8e61bc7edb5ed4653d6874",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b22994a2_a4d5c748",
        "filename": "pc/dtls_transport.h",
        "patchSetId": 5
      },
      "lineNbr": 42,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-02-13T08:41:22Z",
      "side": 1,
      "message": "To prevent destruction race the return value must be scoped_refptr, otherwise the caller has to hold the lock.",
      "revId": "df6e20b8a855e7f12d8e61bc7edb5ed4653d6874",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0a6c34a_1abe4258",
        "filename": "pc/dtls_transport.h",
        "patchSetId": 5
      },
      "lineNbr": 42,
      "author": {
        "id": 5634
      },
      "writtenOn": "2019-02-13T08:45:07Z",
      "side": 1,
      "message": "Yep, but that requires redesigning the whole Cricket subsystem, which uses raw pointers all over the place. Out of scope for this CL.\n\nNote - this is returning a pointer to cricket::DtlsTransportInternal, which is not refcounted - not a pointer to webrtc::DtlsTransport{interface}, which is.",
      "parentUuid": "b22994a2_a4d5c748",
      "revId": "df6e20b8a855e7f12d8e61bc7edb5ed4653d6874",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e75e351_716f2b8b",
        "filename": "pc/dtls_transport.h",
        "patchSetId": 5
      },
      "lineNbr": 42,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-02-13T08:52:24Z",
      "side": 1,
      "message": "Ack. So only use the return value when something prevents Clear() from happening? It sort of defeats the purpose of a lock, but it does establish a happens-before relationship.",
      "parentUuid": "c0a6c34a_1abe4258",
      "revId": "df6e20b8a855e7f12d8e61bc7edb5ed4653d6874",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16d9e5b7_baacad48",
        "filename": "pc/dtls_transport.h",
        "patchSetId": 5
      },
      "lineNbr": 42,
      "author": {
        "id": 5634
      },
      "writtenOn": "2019-02-13T09:27:14Z",
      "side": 1,
      "message": "Clear() is called only from the destructor in jseptransport. Which is where it originally deallocated the object (without doing anything to the dangling pointers in other objects); since this hasn\u0027t crapped all over the place so far, I assume that the sequence of destruction in the jseptransport destructor was carefully managed.\n\nThe lock\u0027s purpose in this case is to make sure we don\u0027t get inconsistent updates - it doesn\u0027t lock the underlying object.",
      "parentUuid": "1e75e351_716f2b8b",
      "revId": "df6e20b8a855e7f12d8e61bc7edb5ed4653d6874",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}