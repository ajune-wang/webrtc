{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "4b25eb04_7713902e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-03-18T16:24:39Z",
      "side": 1,
      "message": "PTAL. I\u0027m not sure what test coverage we have for this. But it appears referenced from chromium,\n\nthird_party/blink/renderer/modules/peerconnection/peer_connection_dependency_factory.h:#include \"third_party/webrtc/p2p/stunprober/stun_prober.h\"\nthird_party/blink/renderer/platform/peerconnection/stun_field_trial.h:#include \"third_party/webrtc/p2p/stunprober/stun_prober.h\"\n",
      "revId": "3af3e62b095b79f92b97e50763037d3acfd97542",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5ccfb226_9f490fd9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-19T09:05:09Z",
      "side": 1,
      "message": "Drive-by comment on AsyncResolver.\n",
      "revId": "3af3e62b095b79f92b97e50763037d3acfd97542",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68f2e3d1_703c10b7",
        "filename": "p2p/stunprober/stun_prober.cc",
        "patchSetId": 1
      },
      "lineNbr": 264,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-03-19T08:42:54Z",
      "side": 1,
      "message": "I don\u0027t know why webrtc::ScopedTaskSafety is required to be destroyed on the same thread as the tasks run on, but to me it sounds like we must now RTC_DCHECK(thread_checker_.IsCurrent()); in ~StunProber.",
      "revId": "3af3e62b095b79f92b97e50763037d3acfd97542",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a5ad09d3_ae887455",
        "filename": "p2p/stunprober/stun_prober.cc",
        "patchSetId": 1
      },
      "lineNbr": 264,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-03-19T09:32:10Z",
      "side": 1,
      "message": "That requirement is inherited from PendingTaskSafetyFlag::SetNotAlive, which is called from the destructor.\n\nAdding DCHECK for clarity, even if it is redundant, since PendingTaskSafety has its own thread check. (A separate improvement would be to add thread annotations, and replace RTC_DCHECK(thread_checker_.IsCurrent()); with RTC_DCHECK_RUN_ON(thread_);, but I don\u0027t intend to do that now)",
      "parentUuid": "68f2e3d1_703c10b7",
      "revId": "3af3e62b095b79f92b97e50763037d3acfd97542",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9e932f1d_c040d774",
        "filename": "p2p/stunprober/stun_prober.cc",
        "patchSetId": 1
      },
      "lineNbr": 264,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-03-19T11:09:50Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "a5ad09d3_ae887455",
      "revId": "3af3e62b095b79f92b97e50763037d3acfd97542",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d48947d0_f5d1a773",
        "filename": "p2p/stunprober/stun_prober.cc",
        "patchSetId": 1
      },
      "lineNbr": 362,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-03-19T08:42:54Z",
      "side": 1,
      "message": "Is this thread safe? Don\u0027t we need task_safety_.flag() here too since we no longer have an async invoker that is being destroyed?\n\nOr else, who is responsible for AsyncResolverInterface staying alive?",
      "revId": "3af3e62b095b79f92b97e50763037d3acfd97542",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20736993_064fb32e",
        "filename": "p2p/stunprober/stun_prober.cc",
        "patchSetId": 1
      },
      "lineNbr": 362,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-19T09:05:09Z",
      "side": 1,
      "message": "AsyncResolver is a self-deleting interface - the Destroy() method causes it to be deleted eventually. I have a CL in progress (triggered by a flaky test with ASAN issues) to revisit AsyncResolver\u0027s ownership design.\n\nI suspect it\u0027s threadsafe, but it\u0027s a different issue than this one.",
      "parentUuid": "d48947d0_f5d1a773",
      "revId": "3af3e62b095b79f92b97e50763037d3acfd97542",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3f359b4_6a3dbf20",
        "filename": "p2p/stunprober/stun_prober.cc",
        "patchSetId": 1
      },
      "lineNbr": 362,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-03-19T09:32:10Z",
      "side": 1,
      "message": "As far as I understand, (i) nothing else destroys the resolver, so it should stay alive until the task runs, and (ii) the lambda doesn\u0027t depend on anything in `this`.\n\nBut lifetime of the resolver isn\u0027t crystal clear to me. It would be simpler if it automatically self destructed after OnServerResolved returns. And if I remember correctly, the reason we can\u0027t destroy it synchronously is that OnServerResolved isn\u0027t a tail call, the resolver object is calling it from an iteration of the sigslot state, and calling Destroy directly gives a use-after-free immediately on return.",
      "parentUuid": "20736993_064fb32e",
      "revId": "3af3e62b095b79f92b97e50763037d3acfd97542",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1a51e19_0118b2eb",
        "filename": "p2p/stunprober/stun_prober.cc",
        "patchSetId": 1
      },
      "lineNbr": 362,
      "author": {
        "id": 5142
      },
      "writtenOn": "2021-03-19T11:09:50Z",
      "side": 1,
      "message": "But prior to this CL, wouldn\u0027t the task get cancelled by the destruction of invoker_, happening at ~StunProber?\n\n\"any calls in flight will be cancelled when the AsyncInvoker used to make the call is destructed\"\n\nSo to get the same behavior (whether or not this is a good design) we would still need the flag, even if we don\u0027t access |this|? Or am I mistaken?",
      "parentUuid": "a3f359b4_6a3dbf20",
      "revId": "3af3e62b095b79f92b97e50763037d3acfd97542",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}