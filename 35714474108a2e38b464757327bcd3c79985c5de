{
  "comments": [
    {
      "key": {
        "uuid": "43392b0d_6ba1ffbd",
        "filename": "rtc_base/physical_socket_server.h",
        "patchSetId": 3
      },
      "lineNbr": 101,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-05-18T12:58:14Z",
      "side": 1,
      "message": "To improve clarity on how various threads access members, we need some annotation or comment on this one (the same problem as with the old std:vector). Is WaitEpoll called with the lock held? If so, a RTC_GUARDED_BY with that lock is right. If not, at least document use, or consider adding a ThreadChecker.",
      "range": {
        "startLine": 101,
        "startChar": 0,
        "endLine": 101,
        "endChar": 64
      },
      "revId": "35714474108a2e38b464757327bcd3c79985c5de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51fb1252_b6640a66",
        "filename": "rtc_base/physical_socket_server.h",
        "patchSetId": 3
      },
      "lineNbr": 101,
      "author": {
        "id": 9515
      },
      "writtenOn": "2020-05-18T14:05:40Z",
      "side": 1,
      "message": "WaitEpoll is not holding any locks when calling epoll_wait, indicating that it\u0027s the same context calling into it given the age of the code. However, failures appeared when adding a thread checker. Unfortunately it seems we just have to document it\u0027s supposedly used in isolation, or do you (@deadbeef, @nisse) have some other recommendation?",
      "parentUuid": "43392b0d_6ba1ffbd",
      "range": {
        "startLine": 101,
        "startChar": 0,
        "endLine": 101,
        "endChar": 64
      },
      "revId": "35714474108a2e38b464757327bcd3c79985c5de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8547f33_4b63c55a",
        "filename": "rtc_base/physical_socket_server.h",
        "patchSetId": 3
      },
      "lineNbr": 101,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-05-18T15:15:59Z",
      "side": 1,
      "message": "Looks like it\u0027s called from the public Wait method, part of the SocketServer class. Main use seems to be from Thread::Run via Thread::ProcessMessages (a public method!), but other callers could be a problem. When you tried adding a thread checker (or it seems it should be SequenceChecker now), did you call Detach() from the constructor?\n\nDocumenting usage for now is good enough for me.",
      "parentUuid": "51fb1252_b6640a66",
      "range": {
        "startLine": 101,
        "startChar": 0,
        "endLine": 101,
        "endChar": 64
      },
      "revId": "35714474108a2e38b464757327bcd3c79985c5de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d5e0cea_13eda7f1",
        "filename": "rtc_base/physical_socket_server.h",
        "patchSetId": 3
      },
      "lineNbr": 101,
      "author": {
        "id": 9515
      },
      "writtenOn": "2020-05-18T19:43:20Z",
      "side": 1,
      "message": "Yes, used Detach() eventually.\nUnfortunately, it seems that SocketServers can outsurvive threads and be attached to new threads, as they\u0027re used in nat_unittest.cc. Actually there aren\u0027t any guarantees that the same SocketServer isn\u0027t ending up getting used by several threads concurrently, although I really don\u0027t see the use of that (it should really be enforced somehow IMHO and would be caught by TSAN). I think the best at this point is to just document that it\u0027s accessed in isolation.",
      "parentUuid": "f8547f33_4b63c55a",
      "range": {
        "startLine": 101,
        "startChar": 0,
        "endLine": 101,
        "endChar": 64
      },
      "revId": "35714474108a2e38b464757327bcd3c79985c5de",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}