{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e1c940df_57e78df8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-08-25T01:12:34Z",
      "side": 1,
      "message": "Responded to all comments, left a couple of my own upon re-reviewing myself",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a222fe7d_efa615c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-08-26T14:22:48Z",
      "side": 1,
      "message": "I think I\u0027m signing off on this one.\nI think the basis of my frustration is the fact that OpenSSL refers to 2 different things:\n- the API that we are using to access either BoringSSL or OpenSSL (second sense)\n- the implementation of that API in OpenSSL\n\nBut changing one of the names to something else is probably a large task and out of scope for this CL.\nApproving.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "da08d58b_6391c506",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-08-27T23:27:36Z",
      "side": 1,
      "message": "One more idea: could do \"x509_object_certificate\" and \"crypto_buffer_certificate\"? That\u0027s more representative of what the actual difference is and avoids the confusion.",
      "parentUuid": "a222fe7d_efa615c8",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9aff3750_c0f47eb6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-08-31T23:14:11Z",
      "side": 1,
      "message": "David, do you want to take one last look before I submit?",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e48bba5b_62fb7c31",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-09-07T11:28:21Z",
      "side": 1,
      "message": "found this week-old comment that I hadn\u0027t sent...",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "31a7fc47_d6edcd32",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-09-07T11:28:21Z",
      "side": 1,
      "message": "All certificates are X.509, so that\u0027s misleading.\n\nI *think* (haven\u0027t checked the code) the difference is that a crypto_buffer contains the uninterpreted bag-of-bits, and unpacks it only when it has to, while the non-crypto-buffer form contains some kind of decoded structure where it\u0027s easy to get at the various pieces of information in the cert.\n\nIf that\u0027s the difference, I might call them \"PreParsedCertificate\" and \"EncodedCertificate\", but keeping consistency with what the actual libs call them is rather important for maintainability.",
      "parentUuid": "da08d58b_6391c506",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b6698475_36f0fcb9",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Gosh we need to write a bssl::CertBuilder... :-(",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f1dcf85_ff5a08f8",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 22,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Unused?",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40082b2d_9f711884",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 22,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "I have no idea why, but without including this I get:\n\n../../third_party/boringssl/src/include/openssl/base.h:512:21: error: no member named \u0027Free\u0027 in \u0027bssl::internal::DeleterImpl\u003cunsigned char, void\u003e\u0027\n    DeleterImpl\u003cT\u003e::Free(ptr);\n                    ^\n../../buildtools/third_party/libc++/trunk/include/memory:2633:7: note: in instantiation of member function \u0027bssl::internal::Deleter\u003cunsigned char\u003e::operator()\u0027 requested here\n      __ptr_.second()(__tmp);\n      ^\n../../buildtools/third_party/libc++/trunk/include/memory:2587:19: note: in instantiation of member function \u0027std::__1::unique_ptr\u003cunsigned char, bssl::internal::Deleter\u003cunsigned char\u003e\u003e::reset\u0027 requested here\n  ~unique_ptr() { reset(); }\n                  ^\n../../rtc_base/boringssl_certificate.cc:221:28: note: in instantiation of member function \u0027std::__1::unique_ptr\u003cunsigned char, bssl::internal::Deleter\u003cunsigned char\u003e\u003e::~unique_ptr\u0027 requested here\n  bssl::UniquePtr\u003cuint8_t\u003e delete_tbs_cert_bytes(tbs_cert_bytes);\n\n\nI assume we do want to use bssl::UniquePtr so that BoringSSL frees memory that it allocates.",
      "parentUuid": "2f1dcf85_ff5a08f8",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3931bf12_61dedf54",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 22,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-30T21:17:17Z",
      "side": 1,
      "message": "Ah. I think you want to pull in \u003copenssl/mem.h\u003e, which picks up OPENSSL_free and the char/uint8_t bssl::UniquePtr definitions. And pem.h is probably working because it happens to pull it in.",
      "parentUuid": "40082b2d_9f711884",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fe487b25_e8c988f6",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 112,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "This is... a mess. RSA should include the NULL while ECDSA should omit it. Actual enforcement of this is a bit all over the place. :-(",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34c5b36a_9197dad3",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 112,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:35Z",
      "side": 1,
      "message": "(Er, by \"this\" I mean the situation, not your code. :-) )",
      "parentUuid": "fe487b25_e8c988f6",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c637c7ff_7131dd43",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 112,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Fixed.",
      "parentUuid": "34c5b36a_9197dad3",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b62bddb_28a13531",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 145,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "No need to flush rdns if you\u0027re already flushing cbb. It\u0027ll take care of the rest.",
      "range": {
        "startLine": 145,
        "startChar": 5,
        "endLine": 145,
        "endChar": 25
      },
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "37d65c79_4e830a46",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 145,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "7b62bddb_28a13531",
      "range": {
        "startLine": 145,
        "startChar": 5,
        "endLine": 145,
        "endChar": 25
      },
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05b7b16d_6dffc43e",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 153,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Since this is BoringSSL-specific already:\n\nbssl::UniquePtr\u003cASN1_TIME\u003e asn1_time(ASN1_TIME_new());\netc.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "43c32686_325f7fb1",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 153,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "05b7b16d_6dffc43e",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "db233970_5257cc41",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 292,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Note this does no parsing at all. Dunno if that matters for WebRTC.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "76bfbfe0_76968c21",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 292,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "I don\u0027t think it matters, it just means an error will occur further down the line. Plus, in chromium, this will only be used when a generated certificate is converted to PEM and back.",
      "parentUuid": "db233970_5257cc41",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "59e5f88a_fdb1a761",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 301,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Optional: This works, but you can probably avoid the macro by turning the CBS into an absl::Span\u003cconst uint8_t\u003e and using the equality function. (Although std::span took away equality[*], so I dunno what their plan is. Maybe we\u0027ll have absl::ranges::equal first.)\n\n[*] https://abseil.io/blog/20180531-regular-types",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8c66b7b0_96049e1e",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 301,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "WebRTC disallows Span over rtc::ArrayView, which doesn\u0027t do member-wise equality, so I\u0027ll just leave as is.",
      "parentUuid": "59e5f88a_fdb1a761",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98b189ec_ef340628",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 316,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "I expect we can drop all the DSA OIDs. While we do parse them, unless you go out of your way to do so, BoringSSL won\u0027t verify DSA signatures anyway.",
      "range": {
        "startLine": 316,
        "startChar": 59,
        "endLine": 316,
        "endChar": 71
      },
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "711fdd5a_46d29347",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 316,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "I\u0027m just handling the same list of OIDs that the vanilla OpenSSL implementation did, to be on the safe side: https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/rtc_base/openssl_certificate.cc;l\u003d169?q\u003dopenssl_certificate\u0026ss\u003dchromium%2Fchromium%2Fsrc:third_party%2Fwebrtc%2F",
      "parentUuid": "98b189ec_ef340628",
      "range": {
        "startLine": 316,
        "startChar": 59,
        "endLine": 316,
        "endChar": 71
      },
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7ebf3d4_3f0e4905",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 391,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Rather than making a CBS, you can just pass CRYPTO_BUFFER_data and CRYPTO_BUFFER_len to this function. Ditto below.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7a768db1_762324dd",
        "filename": "rtc_base/boringssl_certificate.cc",
        "patchSetId": 16
      },
      "lineNbr": 391,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f7ebf3d4_3f0e4905",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e468a57_a5104606",
        "filename": "rtc_base/boringssl_identity.cc",
        "patchSetId": 16
      },
      "lineNbr": 113,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "This doesn\u0027t handle newlines right, but I guess SSLIdentity::PemToDer doesn\u0027t either.\n\nI took a stab at documenting OpenSSL\u0027s PEM functions (probably no sense in bifurcating those, though we really should rewrite that parser), so you could also use that if you like.\nhttps://boringssl-review.googlesource.com/c/boringssl/+/43426/",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e8f8b8c5_fa27a894",
        "filename": "rtc_base/boringssl_identity.cc",
        "patchSetId": 16
      },
      "lineNbr": 113,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Switched to using PEM API.",
      "parentUuid": "6e468a57_a5104606",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3a359cb_c2533cba",
        "filename": "rtc_base/boringssl_identity.cc",
        "patchSetId": 16
      },
      "lineNbr": 114,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Not sure this line is reachable, since last_position + 1 starts out at 0.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b014c5db_94c962d2",
        "filename": "rtc_base/boringssl_identity.cc",
        "patchSetId": 16
      },
      "lineNbr": 114,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Not relevant anymore.",
      "parentUuid": "f3a359cb_c2533cba",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb4d6ce4_661d4149",
        "filename": "rtc_base/boringssl_identity.cc",
        "patchSetId": 16
      },
      "lineNbr": 118,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "It looks like this will find all instances of ---BEGIN CERTIFICATE---, except at position 0, and chop the string between them. So if position 0 is another instance, it works. But otherwise it\u0027ll get confused. That is, if certificate_chain is:\n\n  \"--BEGIN CERT--...---BEGIN CERT---...---BEGIN CERT---...\"\n\ncertificate_strings will be:\n\n  [\"---BEGIN CERT---...\", \"---BEGIN CERT---...\", \"---BEGIN CERT---...\"]\n\nBut if certificate_chain is, say:\n\n  \"blah--BEGIN PRIVATE KEY...---BEGIN CERT---...---BEGIN CERT---...\"\n\ncertificate_strings will be:\n\n  [\"blah--BEGIN PRIVATE KEY...\", \"---BEGIN CERT---...\", \"---BEGIN CERT---...\"]\n\nSeems that first one will fail to parse because there\u0027s no cert in there.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "38755466_e95b4def",
        "filename": "rtc_base/boringssl_identity.cc",
        "patchSetId": 16
      },
      "lineNbr": 118,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Not relevant anymore.",
      "parentUuid": "cb4d6ce4_661d4149",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "633c1ace_5d0e456e",
        "filename": "rtc_base/boringssl_identity.cc",
        "patchSetId": 16
      },
      "lineNbr": 166,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "(It\u0027ll only return 0 or 1, so also okay to treat it as a boolean. Whatever works. We\u0027d really like to return bool, but C...)",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c8cacb97_5d605b41",
        "filename": "rtc_base/openssl_adapter.cc",
        "patchSetId": 16
      },
      "lineNbr": 240,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Since rtc_builtin_ssl_root_certificates pulls in both SSLIdentity implementations, is there a risk of memory error if someone gets their hand on an OpenSSLIdentity?\n\nOn that note... when does rtc_builtin_ssl_root_certificates need OpenSSLIdentity? Seems that just controls WEBRTC_EXCLUDE_BUILT_IN_SSL_ROOT_CERTS, which in turn is used here. That seems to use X509 objects directly, so perhaps we don\u0027t need to pull it in at all?\nhttps://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/rtc_base/openssl_utility.cc;drc\u003d0e22286ee95d2bd711f81d73f1178343fbacc890;l\u003d105\n\nEdit: Ah, I see where it\u0027s pulled in.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0d293ba3_e22a78ea",
        "filename": "rtc_base/openssl_adapter.cc",
        "patchSetId": 16
      },
      "lineNbr": 240,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "OpenSSLIdentity is only constructed in ssl_identity.cc, so that shouldn\u0027t be an issue, at least not now. \n\nI think the only place the OpenSSLCertificate implementation is needed is when invoking the custom certificate callback... I could just create a CRYPTO_BUFFER there to avoid this weirdness. Take a look. Is there an easier way to get from X509_STORE_CTX to CRYPTO_BUFFER?",
      "parentUuid": "c8cacb97_5d605b41",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "64b4c81b_f208d1ed",
        "filename": "rtc_base/openssl_adapter.cc",
        "patchSetId": 16
      },
      "lineNbr": 847,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "(FWIW, this should be impossible. But no harm in checking.)",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bf31653b_958d4613",
        "filename": "rtc_base/openssl_adapter.cc",
        "patchSetId": 16
      },
      "lineNbr": 852,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "(I noticed this is all the interface supports, so nothing to change here, but if you\u0027re verifying against some roots, you probably want to keep the cert chain.)",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c7161c5a_ccf4eeaa",
        "filename": "rtc_base/openssl_adapter.cc",
        "patchSetId": 16
      },
      "lineNbr": 852,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Yeah, this callback is definitely inadequate, will probably deprecate it.",
      "parentUuid": "bf31653b_958d4613",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f0339c1_9af2d043",
        "filename": "rtc_base/openssl_adapter.cc",
        "patchSetId": 16
      },
      "lineNbr": 907,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "This is the one place where OpenSSL{Certificate,Identity} is used in an OPENSSL_IS_BORINGSSL build, right? Perhaps we should at least only include openssl_certificate.{h,cc} and not openssl_identity.{h,cc}.\n\nIt is still a little weird, though, that which SSLCertificate implementation is used for this callback depends on whether you pulled in the built-in roots. This is a public API I assume. Is that the interface we want to expose? (Another option would be to consistently use BoringSSLCertificate and just serialize the X509 to bytes if OPENSSL_IS_BORINGSSL.)",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "119d37cc_dee3ba71",
        "filename": "rtc_base/openssl_adapter.cc",
        "patchSetId": 16
      },
      "lineNbr": 907,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Fixed, I\u0027m just converting the X509 to a CRYPTO_BUFFER now",
      "parentUuid": "7f0339c1_9af2d043",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ed4ca72e_4a706ed1",
        "filename": "rtc_base/openssl_key_pair.cc",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Didn\u0027t look at this very carefully and assumed it was just moved over from openssl_identity.cc.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c702375e_ac815305",
        "filename": "rtc_base/openssl_key_pair.cc",
        "patchSetId": 16
      },
      "lineNbr": 0,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "You\u0027re correct",
      "parentUuid": "ed4ca72e_4a706ed1",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "05df81c6_c545f4f3",
        "filename": "rtc_base/openssl_stream_adapter.cc",
        "patchSetId": 16
      },
      "lineNbr": 1125,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "ssl_verify_retry will pause the handshake at that point. You\u0027ll then get SSL_ERROR_WANT_CERTIFICATE_VERIFY over in ContinueSSL(). The next time you call SSL_connect() or SSL_accept() it will, like if we\u0027re blocked on transport I/O, try this callback again. Dunno if that\u0027s what you want. (I\u0027m not familiar with when peer_certificate_digest_algorithm_ gets set up.)",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1ec1803e_ca10fe9b",
        "filename": "rtc_base/openssl_stream_adapter.cc",
        "patchSetId": 16
      },
      "lineNbr": 1125,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Under particular circumstances, the peer digest *may* be set after the handshake completes. I figure that using ssl_verify_retry, and calling ContinueSSL when the digest is set, would make it harder for a bug to be introduced where a certificate is accepted without verifying the digest.\n\nThis really should be covered by tests anyway, though. I verified that there is already a test for Write, and made sure it covers Read as well.",
      "parentUuid": "05df81c6_c545f4f3",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a234fc3f_04f70e62",
        "filename": "rtc_base/openssl_stream_adapter.cc",
        "patchSetId": 16
      },
      "lineNbr": 1125,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-30T21:17:17Z",
      "side": 1,
      "message": "Ah. Yeah, if the intent is that the connection isn\u0027t usable yet (which would make sense), ssl_verify_retry sounds like a good strategy.\n\nYou also could, external to the TLS library, just wait to start the handshake altogether. That might be a good fallback behavior, if you want both modes to be comparably safe. Though I guess running the handshake as far as you can might save you a round-trip.",
      "parentUuid": "1ec1803e_ca10fe9b",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6594925_179f793e",
        "filename": "rtc_base/openssl_utility.cc",
        "patchSetId": 16
      },
      "lineNbr": 53,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Oof. It\u0027d be nice if we didn\u0027t have to carry an extra implementation of name-matching and name-extracting logic. I can try to at least extract BoringSSL\u0027s into a separate function, if that\u0027d help. That wouldn\u0027t pull in the rest of crypto/x509.\n\nBut taking a step back, I\u0027m wondering if we\u0027re slicing this wrong. (I certainly didn\u0027t file the original bug intending we\u0027d reimplement that! :-( ) This is only reachable via OpenSSLAdapter::SSLPostConnectionCheck(), when it\u0027s actually verifying a certificate against a name, right? That is, this is doing a real certificate verification, instead of WebRTC\u0027s funny hash match? (Which is OpenSSLStreamAdapter.) I\u0027m assuming Chromium doesn\u0027t use this class, just OpenSSLStreamAdapter. Is that right?\n\nIIRC, you mentioned other WebRTC consumers also want the size gains, but still need real certificate verification. And thus the plan was for those consumers to call out to the OS since, X509 or CRYPTO_BUFFER, they need a source of roots.\n\nGiven that that rtc::SSLCertificateVerifier can\u0027t express a certificate chain, it seems the CRYPTO_BUFFER codepath isn\u0027t usable for this anyway. So we\u0027d need to adjust the interface anyway. If we do, why not move the hostname verification inside it too? If you\u0027re using, say, Android\u0027s verifier, you may as well use Android\u0027s name-matching logic. That leaves WebRTC not really needing to extract complex information out of a certificate, which is probably simpler all around.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60b5ee4d_11495617",
        "filename": "rtc_base/openssl_utility.cc",
        "patchSetId": 16
      },
      "lineNbr": 53,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "\u003e I can try to at least extract BoringSSL\u0027s into a separate function, if that\u0027d help.\n\nThat would be great; would it be difficult given that the current code is written for X509 objects? Should I wait for you to do this before submitting?\n\n\u003e This is only reachable via OpenSSLAdapter::SSLPostConnectionCheck(), when it\u0027s actually verifying a certificate against a name, right? That is, this is doing a real certificate verification, instead of WebRTC\u0027s funny hash match? (Which is OpenSSLStreamAdapter.) I\u0027m assuming Chromium doesn\u0027t use this class, just OpenSSLStreamAdapter. Is that right?\n\nCorrect on all counts.\n\n\u003e Given that that rtc::SSLCertificateVerifier can\u0027t express a certificate chain, it seems the CRYPTO_BUFFER codepath isn\u0027t usable for this anyway. So we\u0027d need to adjust the interface anyway. If we do, why not move the hostname verification inside it too?\n\nThat would be the plan. But we still need to fall back to the built-in roots and name matching on platforms where the OS verification is not implemented. At least that\u0027s what I was thinking.",
      "parentUuid": "e6594925_179f793e",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee0741a4_4f0ef1d4",
        "filename": "rtc_base/openssl_utility.cc",
        "patchSetId": 16
      },
      "lineNbr": 53,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-30T21:17:17Z",
      "side": 1,
      "message": "\u003e That would be the plan. But we still need to fall back to the built-in roots and name matching on platforms where the OS verification is not implemented. At least that\u0027s what I was thinking.\n\nRight, I guess what I\u0027m saying that, where we fallback to built-in roots, we\u0027re already shipping the built-in roots and built-in verifier anyway. At that point, it seems we may as well use the built-in name-matching algorithm too. And where we use OS or other application-supplied verification, that stack should already have a name-matching algorithm, so there\u0027s no sense in us replicating it.\n\nIt\u0027s a little goofy right now, since OpenSSLAdapter checks the name matches after certificate verification. But it seems doing that as part of verification would be preferable anyway (a valid certificate chain for the wrong name isn\u0027t any more useful of a certificate than an arbitrarily invalid chain).\n\nPerhaps this could be rearranged so that VerifyPeerCertMatchesHost() is part of the built-in verification process, and if you use a callback instead, we\u0027ll pass the name in or otherwise expect the callback to check for you. That might be simplest as a separate CL, so perhaps here we just create X509 objects (X509_parse_from_buffer is the most efficient way to go from CRYPTO_BUFFER to X509; we\u0027ll reuse some bits in memory since we know the CRYPTO_BUFFER is immutable.) And then as a follow CL, we get VerifyPeerCertMatchesHost() out of the non-built-in-roots path.",
      "parentUuid": "60b5ee4d_11495617",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51d4b039_7951c854",
        "filename": "rtc_base/openssl_utility.cc",
        "patchSetId": 16
      },
      "lineNbr": 328,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Probably check CBS_len(\u0026certificate) \u003d\u003d 0 to check for trailing data.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b1e45ee_7d188cde",
        "filename": "rtc_base/openssl_utility.cc",
        "patchSetId": 16
      },
      "lineNbr": 328,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "51d4b039_7951c854",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b386c9a8_1b6404a6",
        "filename": "rtc_base/openssl_utility.cc",
        "patchSetId": 16
      },
      "lineNbr": 404,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Similarly check CBS_len(\u0026tbs_certificate) is empty.",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9665cf71_394eb17c",
        "filename": "rtc_base/openssl_utility.cc",
        "patchSetId": 16
      },
      "lineNbr": 404,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b386c9a8_1b6404a6",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4e2fe8ad_3b05a3b0",
        "filename": "rtc_base/openssl_utility.cc",
        "patchSetId": 16
      },
      "lineNbr": 425,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "(If SSL_get0_peer_certificates returns non-NULL, it should never be empty. However, it *is* possible for it to return NULL if there is no peer certificate. This would happen if ssl is a server which either didn\u0027t request client certs, or requested them but allowed the client to remain anonymous. But if you\u0027ve configured it to require client certs then, yeah, there\u0027ll always be one.)",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cd0fe205_2609ce48",
        "filename": "rtc_base/openssl_utility.cc",
        "patchSetId": 16
      },
      "lineNbr": 454,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "FWIW, Chrome and most browsers no longer looks at this one. Although we haven\u0027t managed to get it out of BoringSSL yet. :-/",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2365141c_80d7c34c",
        "filename": "rtc_base/ssl_stream_adapter_unittest.cc",
        "patchSetId": 16
      },
      "lineNbr": 523,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "I ended up inlining this function so I can set the server identity, try sending/receiving a packet, then set the client identity. Initially I split SetPeerIdentitiesByDigest into two functions, \"SetClientPeerIdentitiesByDigest\"/\"SetServerPeerIdentitiesByDigest\". But that didn\u0027t work because setting an invalid peer identity causes the local identity to be freed, meaning that SetServerPeerIdentitiesByDigest crashes after SetClientPeerIdentitiesByDigest(false, false).",
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "81aa3f08_433cc6a5",
        "filename": "webrtc.gni",
        "patchSetId": 16
      },
      "lineNbr": 225,
      "author": {
        "id": 5602
      },
      "writtenOn": "2020-10-09T21:25:03Z",
      "side": 1,
      "message": "Optional / probably not the prevailing style: it\u0027s not in keeping with Chromium\u0027s style, but since BoringSSL gives you an OPENSSL_IS_BORINGSSL ifdef already, another option would be to always include boringssl_*.cc and just wrap the whole files in ifdefs.\n\n(That\u0027s what we usually do in BoringSSL. We have to support far too many buildsystems, so we try to put the build logic in the source as much as possible.)",
      "range": {
        "startLine": 225,
        "startChar": 2,
        "endLine": 225,
        "endChar": 26
      },
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "195b2ce4_4b62cd99",
        "filename": "webrtc.gni",
        "patchSetId": 16
      },
      "lineNbr": 225,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-10-27T21:54:19Z",
      "side": 1,
      "message": "Right, but this is also used to conditionally exclude the vanilla OpenSSL implementation:\n\n  if (!rtc_openssl_is_boringssl || rtc_builtin_ssl_root_certificates) {\n    sources +\u003d [\n      \"openssl_certificate.cc\",\n      \"openssl_certificate.h\",\n      \"openssl_identity.cc\",\n      \"openssl_identity.h\",\n    ]\n  }\n\nSo it feels slightly cleaner to me this way.",
      "parentUuid": "81aa3f08_433cc6a5",
      "range": {
        "startLine": 225,
        "startChar": 2,
        "endLine": 225,
        "endChar": 26
      },
      "revId": "30979c033cadf174bf196c22bf1ffdeb4b5c8c4c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}