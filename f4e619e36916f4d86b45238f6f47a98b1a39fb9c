{
  "comments": [
    {
      "key": {
        "uuid": "c1eed14c_d8388c08",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 12
      },
      "lineNbr": 0,
      "author": {
        "id": 5122
      },
      "writtenOn": "2020-09-28T15:35:42Z",
      "side": 1,
      "message": "Hi again Per,\n\nI\u0027ve created 2 intermediate CLs to remove clutter and keep a better focus in this one. The additional CLs are changes introduced to address part of your comments, so no new feature. It also helped me to find a bug due to which the default behavior was changing (now fixed). So, could you take a look at the diff between head and the last patchset instead of comparing to the last patchset with comments from you?\n\nCheers,\nAlessio",
      "revId": "f4e619e36916f4d86b45238f6f47a98b1a39fb9c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2c029135_93666ac8",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 12
      },
      "lineNbr": 123,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-29T09:50:04Z",
      "side": 1,
      "message": "Since this goes in both the if-statements on 123 and 127 I would instead write this as a nested if and discard the constant requires_adjacent_speech_frames (if you want to make it clear what that adjacent_speech_frames_threshold_ \u003e 1 means I think it is better to do that in a comment than using a constant with specified naming.\ni.e., as\nif (adjacent_speech_frames_threshold_ \u003e 1) {\n  if(num_adjacent_speech_frames_ \u003e\u003d adjacent_speech_frames_threshold_) {\n     ...\n  } else if ( num_adjacent_speech_frames_ \u003e 0) {\n    ...\n  }\n}\n\n\nI think this will make the logic in this statement more readable.",
      "range": {
        "startLine": 123,
        "startChar": 8,
        "endLine": 123,
        "endChar": 39
      },
      "revId": "f4e619e36916f4d86b45238f6f47a98b1a39fb9c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "19921bb5_b184d264",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 12
      },
      "lineNbr": 123,
      "author": {
        "id": 5122
      },
      "writtenOn": "2020-09-29T10:38:55Z",
      "side": 1,
      "message": "yes it reads better and I switched to that; I wanted to avoid nested IFs",
      "parentUuid": "2c029135_93666ac8",
      "range": {
        "startLine": 123,
        "startChar": 8,
        "endLine": 123,
        "endChar": 39
      },
      "revId": "f4e619e36916f4d86b45238f6f47a98b1a39fb9c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2d53e037_a3893d29",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 12
      },
      "lineNbr": 140,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-29T09:50:04Z",
      "side": 1,
      "message": "A concern with this approach is that all new updates will only go into the preliminary_state until a non-speech frame is received, at which the copy to the reliable_state_ is made.\n\nI think that if the code instead would make sure to instead use the most appropriately updated state for this that could be fully avoided, while still using the current approach of copying the states.",
      "range": {
        "startLine": 140,
        "startChar": 16,
        "endLine": 140,
        "endChar": 34
      },
      "revId": "f4e619e36916f4d86b45238f6f47a98b1a39fb9c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e84b85a9_f0966eb7",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 12
      },
      "lineNbr": 140,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-29T09:50:04Z",
      "side": 1,
      "message": "Please name the type instead of using auto. \nThe code will still fit into one line and since this is strongly typed the reader will benefit more from being able to read the type, instead of using an auto.",
      "range": {
        "startLine": 140,
        "startChar": 2,
        "endLine": 140,
        "endChar": 35
      },
      "revId": "f4e619e36916f4d86b45238f6f47a98b1a39fb9c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "78695185_a4c3ecc5",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 12
      },
      "lineNbr": 140,
      "author": {
        "id": 5122
      },
      "writtenOn": "2020-09-29T10:38:55Z",
      "side": 1,
      "message": "The price to pay for this approach, thanks to which the impl for `AdaptiveModeLevelEstimator::Update` became simpler, is visible in `AdaptiveModeLevelEstimator::IsConfident()` which is not trivial anymore.\n\nThe previous solution works as follows:\n 1. preliminary state is being updated as long as too few adjacent speech frames are observed\n 2. once enough frames are observed \"reliable state \u003c- preliminary state\" (copy op) in order to make sure that reliable state benefits from what we can learn from the initial speech frames (those analyzed in the preliminary phase)\n 3. once enough frames are observed reliable state is being updated\nI still don\u0027t see an option to avoid step 2 (namely, the copy op \"reliable \u003c- preliminary\"), which is now moved at the end of a long enough speech sequence.\nIf I understand correctly your initial proposal was to use mutable aliases to switch from preliminary to reliable during a speech sequence based on whether the number of adjacent speech frames is greater than the threshold. If this is what you suggested, note that it won\u0027t work as intended since the state updates that happened in the preliminary phase will be ignored slowing down the convergence of the level estimator.\n\nI don\u0027t have a strong preference between the previous and the current approach for `AdaptiveModeLevelEstimator::Update`; but if there is a more efficient (bit-exact) implementation that I still don\u0027t see, we could chat offline.",
      "parentUuid": "2d53e037_a3893d29",
      "range": {
        "startLine": 140,
        "startChar": 16,
        "endLine": 140,
        "endChar": 34
      },
      "revId": "f4e619e36916f4d86b45238f6f47a98b1a39fb9c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c2a05176_156375fc",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 12
      },
      "lineNbr": 140,
      "author": {
        "id": 5122
      },
      "writtenOn": "2020-09-29T10:38:55Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e84b85a9_f0966eb7",
      "range": {
        "startLine": 140,
        "startChar": 2,
        "endLine": 140,
        "endChar": 35
      },
      "revId": "f4e619e36916f4d86b45238f6f47a98b1a39fb9c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "54dfc1f9_5bc57f34",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 12
      },
      "lineNbr": 140,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-29T10:53:43Z",
      "side": 1,
      "message": "My concern with the current implementation is that if someone speaks continuously for a long time, the state will not be updated during that time\n\nI don\u0027t think the extra copy is needed to avoid this.\nDuring that speech period the preliminary_ state contains all the information that eventually will end up in the reliable_state_. Therefore the information in preliminary_state can meanwhile be used in place of reliable_state.\n\nMy previous comment about using a reference was to achieve that in a nice manner for the code, basically by using a state named reliable_state which is a reference to two underlying states.",
      "parentUuid": "78695185_a4c3ecc5",
      "range": {
        "startLine": 140,
        "startChar": 16,
        "endLine": 140,
        "endChar": 34
      },
      "revId": "f4e619e36916f4d86b45238f6f47a98b1a39fb9c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7cb71d1f_39d0e0f4",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 12
      },
      "lineNbr": 140,
      "author": {
        "id": 5122
      },
      "writtenOn": "2020-09-29T12:17:01Z",
      "side": 1,
      "message": "\u003e My concern with the current implementation is that if someone speaks continuously for a long time, the state will not be updated during that time\n\nNope, check lines 165-171.\nEven if `preliminary_state_` is used, we know when it becomes reliable and when so the level estimation is updated.\n\n\u003e \n\u003e I don\u0027t think the extra copy is needed to avoid this.\n\u003e During that speech period the preliminary_ state contains all the information that eventually will end up in the reliable_state_. Therefore the information in preliminary_state can meanwhile be used in place of reliable_state.\n\nThis is exactly what I do in the latest approach.\n\n\u003e \n\u003e My previous comment about using a reference was to achieve that in a nice manner for the code, basically by using a state named reliable_state which is a reference to two underlying states.\n\nAck.\n\nI think we\u0027re now on the same page. Feel free to reopen if there\u0027s any remaining concern.",
      "parentUuid": "54dfc1f9_5bc57f34",
      "range": {
        "startLine": 140,
        "startChar": 16,
        "endLine": 140,
        "endChar": 34
      },
      "revId": "f4e619e36916f4d86b45238f6f47a98b1a39fb9c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "08b08fc8_97fcb244",
        "filename": "modules/audio_processing/agc2/adaptive_mode_level_estimator.cc",
        "patchSetId": 12
      },
      "lineNbr": 140,
      "author": {
        "id": 5125
      },
      "writtenOn": "2020-09-29T13:09:43Z",
      "side": 1,
      "message": "True :-)\nThanks!",
      "parentUuid": "7cb71d1f_39d0e0f4",
      "range": {
        "startLine": 140,
        "startChar": 16,
        "endLine": 140,
        "endChar": 34
      },
      "revId": "f4e619e36916f4d86b45238f6f47a98b1a39fb9c",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}