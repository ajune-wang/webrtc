{
  "comments": [
    {
      "key": {
        "uuid": "6e87245f_ef4c9c47",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-11-06T10:37:02Z",
      "side": 1,
      "message": "I\u0027m not sure I agree... I think the api convention should be that callbacks like OnData are expected to return quickly, and that a callee that needs to do a lot of processing or take lots of locks should be responsible for posting to some worker thread or task queue.",
      "range": {
        "startLine": 12,
        "startChar": 1,
        "endLine": 14,
        "endChar": 65
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1edf4ce1_3f025d5f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 5599
      },
      "writtenOn": "2018-11-06T17:18:26Z",
      "side": 1,
      "message": "I think my commit message may have been poorly written.  I agree with everything you said here.  What I made async is *not* the LoopbackMediaTransport -\u003e Sink callback (for receiving data) but the local LoopbackMediaTransport -\u003e remote LoopbackMediaTransport call.\n\nI made this async because it will be async in production.  It goes over the network, so we really don\u0027t have a choice.  I have seen issues in the past (not necessarily in WebRTC, but elsewhere) where the mismatch between synchronous test utilities and async production code causes subtle issues.  I\u0027d rather avoid that.",
      "parentUuid": "6e87245f_ef4c9c47",
      "range": {
        "startLine": 12,
        "startChar": 1,
        "endLine": 14,
        "endChar": 65
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5e810a59_984188f4",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-11-06T10:37:02Z",
      "side": 1,
      "message": "And if you really think asynchronous callbacks are desirable, I\u0027d strongly prefer using a TaskQueue (owned by the MediaTransportPair if you\u0027re willing to share it between the two directions, otherwise each LoopbackMediaTransport can have its own).",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 147,
        "endChar": 31
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5e4261c_5cbcfce1",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 7704
      },
      "writtenOn": "2018-11-06T15:36:46Z",
      "side": 1,
      "message": "1) Can you explain why?\n2) Is there a way to drain a TaskQueue, or do you need to depend on weak pointers when destroying the object?",
      "parentUuid": "5e810a59_984188f4",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 147,
        "endChar": 31
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa159c31_56300c6b",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-11-06T15:51:12Z",
      "side": 1,
      "message": "\u003e 1) Can you explain why?\n\nBecause TQ is generally preferred for new code, and because AsyncInvoker is a hairy and brittle piece of code that I\u0027d like to move away from...\n\n\u003e 2) Is there a way to drain a TaskQueue, or do you need to depend on weak pointers when destroying the object?\n\nThe standard trick for test code is to post a task that sets an event, and wait for that event. Then you know that all tasks posted prior (and not posted using PostDelayedTask) have completed.\n\nWe also use the same trick in production code in a few places, but that\u0027s not so nice.\n\nDestroying a task queue will destroy pending tasks without running them, and block until any currently running task is completed. I think the weak pointers are intended for the case that *other* objects might be destroyed while the task queue and its tasks still are alive; they\u0027re an abstraction adopted from chromium, and so far haven\u0027t been that useful. You probably don\u0027t need any.",
      "parentUuid": "e5e4261c_5cbcfce1",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 147,
        "endChar": 31
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fc7d67a4_eafae123",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 5599
      },
      "writtenOn": "2018-11-06T17:18:26Z",
      "side": 1,
      "message": "I used AsyncInvoker and a thread because I think this will be cleaner when we actually set up a media transport in end-to-end tests.  MediaTransport gets an rtc::Thread* (the network thread) as one of its inputs.\n\n(As a side note, it\u0027s not practical to remove the network thread from media transport unless we rewrite the network layer to stop relying on the network thread--but that\u0027s a discussion for another thread.)\n\nIt made sense to me to do this on the network thread, as it\u0027s simulating the network transit.  But it\u0027s not strictly necessary.  It could use a completely separate TaskQueue, since it doesn\u0027t actually interact with networking objects.\n\nI have a change in the works that I think will use this (once I get far enough to worry about data transfer).  Why don\u0027t I finish that, show it to you, and you can let me know what you think of the thread use in that context.  If you look at the context and still don\u0027t think it\u0027s worth sharing the network thread, I can change it to own its own TaskQueue.",
      "parentUuid": "fa159c31_56300c6b",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 147,
        "endChar": 31
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fa7585a2_38556fe3",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-11-07T09:39:38Z",
      "side": 1,
      "message": "\u003e I used AsyncInvoker and a thread because I think this will be cleaner when we actually set up a media transport in end-to-end tests.  MediaTransport gets an rtc::Thread* (the network thread) as one of its inputs.\n\nThat the current MediaTransport gets an rtc::Thread is an implementation quirk that I don\u0027t think we need copy to the test class.\n\n\u003e I have a change in the works that I think will use this (once I get far enough to worry about data transfer).  Why don\u0027t I finish that, show it to you, and you can let me know what you think of the thread use in that context.  If you look at the context and still don\u0027t think it\u0027s worth sharing the network thread, I can change it to own its own TaskQueue.\n\nSGTM.",
      "parentUuid": "fc7d67a4_eafae123",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 147,
        "endChar": 31
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6d46f9a2_7ea3a0f1",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 5599
      },
      "writtenOn": "2018-11-07T22:57:23Z",
      "side": 1,
      "message": "It turned out I needed a bit more than just the changes in this cl to use the loopback for data channels.  The rest of the changes are bundled with the context in https://webrtc-review.googlesource.com/c/src/+/109740.\n\nI believe the crucial piece that really has to happen on the network thread is the callback when the loopback media transport\u0027s state changes.  I didn\u0027t realize this until I wrote the data channel change.  The state callback goes to JsepTransport, which requires that it fire on the network thread.  See this comment:\nhttps://webrtc-review.googlesource.com/c/src/+/108901/10/pc/jseptransport.cc#648\n\nUnfortunately, there\u0027s a mismatch between the threading model we want for media transport (callback may happen on any thread and the media transport shouldn\u0027t be aware of callee threading requirements) and the model in JsepTransport (everything happens on the network thread, including all the callbacks from transport objects).  This mismatch is part of what forced us to run QUIC media transport\u0027s callbacks on the network thread.\n\nI think we will need to correct that mismatch before we can use a TaskQueue here.  It looks like it will be more work than I expected.  I\u0027m likely to leave it alone in the short term, but if you still think it should be changed, I\u0027ll at least file bugs and TODOs to use TaskQueue.",
      "parentUuid": "fa7585a2_38556fe3",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 147,
        "endChar": 31
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b106e135_d66935cd",
        "filename": "api/test/loopback_media_transport_unittest.cc",
        "patchSetId": 4
      },
      "lineNbr": 71,
      "author": {
        "id": 7565
      },
      "writtenOn": "2018-11-07T23:11:35Z",
      "side": 1,
      "message": "I think FlushAsyncInvokes should be in destructor of  MediaTransportPair t",
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}