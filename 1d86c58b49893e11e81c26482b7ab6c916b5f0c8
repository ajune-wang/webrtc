{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a5417069_0401a741",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 3417290
      },
      "writtenOn": "2024-09-02T13:49:58Z",
      "side": 1,
      "message": "PTAL",
      "revId": "1d86c58b49893e11e81c26482b7ab6c916b5f0c8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b0404c8_da3cada6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 3417290
      },
      "writtenOn": "2024-09-02T13:52:20Z",
      "side": 1,
      "message": "If there are no other overlapping CLs, I split the remaining usage into multiple CLs to complete the migration.",
      "parentUuid": "a5417069_0401a741",
      "revId": "1d86c58b49893e11e81c26482b7ab6c916b5f0c8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "52c49589_5d11ac64",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5019
      },
      "writtenOn": "2024-09-02T13:56:30Z",
      "side": 1,
      "message": "Some of the WebRtc dependencies configured so that absl::string_view and std::string_view are two different types,\n\nso migration can\u0027t be too straight forward.\nIn particular virtual functions that take string_view need multi-step migration.\n\nLet me double check if this change is compatible with that other configuration.\n\nAnother difference is that absl::string_view(nullptr) is well defined to be empty string, but std::string_view(nullptr) is undefined behavior. So we need to double check that construct is not used in WebRTC (I do not remember seeing such code, but better to double check)",
      "revId": "1d86c58b49893e11e81c26482b7ab6c916b5f0c8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19d0bc7a_f1ddd4d5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5019
      },
      "writtenOn": "2024-09-02T14:09:30Z",
      "side": 1,
      "message": "taking a quick look, manually found an example that would break.",
      "revId": "1d86c58b49893e11e81c26482b7ab6c916b5f0c8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d889dd2_113029ef",
        "filename": "call/bitrate_estimator_tests.cc",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 5019
      },
      "writtenOn": "2024-09-02T14:09:30Z",
      "side": 1,
      "message": "This won\u0027t compile when absl::string_view and std::string_view are two different types as rtc::LogSink is not updated\n\n`ABSL_USES_STD_STRING_VIEW` macro\nfrom absl/base/config.h can help to detect which configuration is used.\nWhen defined, absl::string_view and std::string_view are the same type.",
      "revId": "1d86c58b49893e11e81c26482b7ab6c916b5f0c8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "778a9424_57cbf1d2",
        "filename": "call/bitrate_estimator_tests.cc",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 3417290
      },
      "writtenOn": "2024-09-02T14:33:26Z",
      "side": 1,
      "message": "Thanks for your review, can I modify the code here like this?\n\nAlso, I can compile this CL normally on Windows.\n\n```\n#if defined(ABSL_USES_STD_STRING_VIEW)\n#define STRING_VIEW_TYPE std::string_view\n#else\n#define STRING_VIEW_TYPE absl::string_view\n#endif\n\nnamespace webrtc {\nnamespace {\n// Note: If you consider to re-use this class, think twice and instead consider\n// writing tests that don\u0027t depend on the logging system.\nclass LogObserver {\n public:\n  LogObserver() { rtc::LogMessage::AddLogToStream(\u0026callback_, rtc::LS_INFO); }\n\n  ~LogObserver() { rtc::LogMessage::RemoveLogToStream(\u0026callback_); }\n\n  void PushExpectedLogLine(STRING_VIEW_TYPE expected_log_line) {\n    callback_.PushExpectedLogLine(expected_log_line);\n  }\n\n  bool Wait() { return callback_.Wait(); }\n\n private:\n  class Callback : public rtc::LogSink {\n   public:\n    void OnLogMessage(const std::string\u0026 message) override {\n      OnLogMessage(STRING_VIEW_TYPE(message));\n    }\n\n    void OnLogMessage(STRING_VIEW_TYPE message) override {\n      MutexLock lock(\u0026mutex_);\n      // Ignore log lines that are due to missing AST extensions, these are\n      // logged when we switch back from AST to TOF until the wrapping bitrate\n      // estimator gives up on using AST.\n      if (message.find(\"BitrateEstimator\") !\u003d STRING_VIEW_TYPE::npos \u0026\u0026\n          message.find(\"packet is missing\") \u003d\u003d STRING_VIEW_TYPE::npos) {\n        received_log_lines_.push_back(std::string(message));\n      }\n\n      int num_popped \u003d 0;\n      while (!received_log_lines_.empty() \u0026\u0026 !expected_log_lines_.empty()) {\n        std::string a \u003d received_log_lines_.front();\n        std::string b \u003d expected_log_lines_.front();\n        received_log_lines_.pop_front();\n        expected_log_lines_.pop_front();\n        num_popped++;\n        EXPECT_TRUE(a.find(b) !\u003d STRING_VIEW_TYPE::npos) \u003c\u003c a \u003c\u003c \" !\u003d \" \u003c\u003c b;\n      }\n      if (expected_log_lines_.empty()) {\n        if (num_popped \u003e 0) {\n          done_.Set();\n        }\n        return;\n      }\n    }\n\n    bool Wait() {\n      return done_.Wait(test::VideoTestConstants::kDefaultTimeout);\n    }\n\n    void PushExpectedLogLine(STRING_VIEW_TYPE expected_log_line) {\n      MutexLock lock(\u0026mutex_);\n      expected_log_lines_.emplace_back(expected_log_line);\n    }\n\n   private:\n    typedef std::list\u003cstd::string\u003e Strings;\n    Mutex mutex_;\n    Strings received_log_lines_ RTC_GUARDED_BY(mutex_);\n    Strings expected_log_lines_ RTC_GUARDED_BY(mutex_);\n    rtc::Event done_;\n  };\n\n  Callback callback_;\n};\n}\n```",
      "parentUuid": "3d889dd2_113029ef",
      "revId": "1d86c58b49893e11e81c26482b7ab6c916b5f0c8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70627b01_f9b7ac2a",
        "filename": "call/bitrate_estimator_tests.cc",
        "patchSetId": 1
      },
      "lineNbr": 56,
      "author": {
        "id": 5019
      },
      "writtenOn": "2024-09-02T14:41:27Z",
      "side": 1,
      "message": "I do not think that would be helpful:\n\n```\n#if defined(ABSL_USES_STD_STRING_VIEW)\n#define STRING_VIEW_TYPE std::string_view\n#else\n#define STRING_VIEW_TYPE absl::string_view\n#endif\n```\n\nthis way `STRING_VIEW_TYPE` would always be `absl::string_view`\n(and sometimes would also be `std::string_view`)\n\nSee\nhttps://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/abseil-cpp/absl/strings/string_view.h#47 to line 57\n\nSure, this CL compiles normally in stand-alone WebRTC and in Chromium, and in any dependencies where absl::string_view is aliased to std::string_view.\nBut if in `abseil-cpp/absl/base/options.h` you would change `ABSL_OPTION_USE_STD_STRING_VIEW` to 0, then this CL won\u0027t compile.",
      "parentUuid": "778a9424_57cbf1d2",
      "revId": "1d86c58b49893e11e81c26482b7ab6c916b5f0c8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}