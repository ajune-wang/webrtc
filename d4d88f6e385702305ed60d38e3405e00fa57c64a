{
  "comments": [
    {
      "key": {
        "uuid": "e7706b91_1645a498",
        "filename": "video/rtp_video_stream_receiver.cc",
        "patchSetId": 12
      },
      "lineNbr": 384,
      "author": {
        "id": 5527
      },
      "writtenOn": "2020-02-06T12:37:31Z",
      "side": 1,
      "message": "WDYT about instead of removing RtpGenericFrameDescriptor::GetByteRepresentation, we instead templatize it. So for example instead of calling GetRawExtension we would call\n\n  auto raw \u003d generic_descriptor-\u003eGetByteRepresentation\u003cRtpGenericFrameDescriptorExtension00\u003e();\n\nOr we could just create a free helper function that does the same thing, like:\n\n  auto raw \u003d GetByteRepresentation\u003cRtpGenericFrameDescriptorExtension00\u003e(*generic_descriptor);",
      "range": {
        "startLine": 383,
        "startChar": 0,
        "endLine": 384,
        "endChar": 75
      },
      "revId": "d4d88f6e385702305ed60d38e3405e00fa57c64a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e04601f6_25496ebf",
        "filename": "video/rtp_video_stream_receiver.cc",
        "patchSetId": 12
      },
      "lineNbr": 384,
      "author": {
        "id": 5019
      },
      "writtenOn": "2020-02-06T13:06:51Z",
      "side": 1,
      "message": "first options would add backward dependency RtpGenericFrameDescriptor -\u003e RtpGenericFrameDescriptorExtension0x. Prefer to avoid adding circular dependency.\nSecond proposal avoids that. \nI\u0027m not sure how templates are helping here. it seems a bit more reasonable to have\nRtpGenericFrameDescriptorExtension00::GetByteRepresentation(*generic_descriptor) in that case.\n\nor may be even bunch of free functions:\nGetByteRepresentationV0(*generic_descriptor)\nGetByteRepresentationV1(*generic_descriptor)\nGetByteRepresentationV2(*dependency_descriptor)\n\nBut why that would be better? to share code between sending and receving?\nto hide byte manipulation next to the Write/Parse functions ?\n\nGuess I need to think a bit more about that direction.",
      "parentUuid": "e7706b91_1645a498",
      "range": {
        "startLine": 383,
        "startChar": 0,
        "endLine": 384,
        "endChar": 75
      },
      "revId": "d4d88f6e385702305ed60d38e3405e00fa57c64a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "71391e76_1ea039b8",
        "filename": "video/rtp_video_stream_receiver.cc",
        "patchSetId": 12
      },
      "lineNbr": 384,
      "author": {
        "id": 5527
      },
      "writtenOn": "2020-02-06T13:23:47Z",
      "side": 1,
      "message": "\u003e first options would add backward dependency RtpGenericFrameDescriptor -\u003e RtpGenericFrameDescriptorExtension0x. Prefer to avoid adding circular dependency.\n\nRight, we should not create a circular dependency.\n\n\u003e Second proposal avoids that. \n\u003e I\u0027m not sure how templates are helping here.\n\nUsed templates in the first case to avoid having to set a state on the RtpGenericFrameDescriptor object for it to know how to create the byte representation, but you are right, it doesn\u0027t really add anything in the second case.\n\n\u003e it seems a bit more reasonable to have RtpGenericFrameDescriptorExtension00::GetByteRepresentation(*generic_descriptor) in that case.\n\nTrue\n\n\u003e or may be even bunch of free functions:\n\u003e GetByteRepresentationV0(*generic_descriptor)\n\u003e GetByteRepresentationV1(*generic_descriptor)\n\u003e GetByteRepresentationV2(*dependency_descriptor)\n\u003e \n\u003e But why that would be better? to share code between sending and receving?\n\u003e to hide byte manipulation next to the Write/Parse functions ?\n\n- Yes hiding the bit manipulation is nice.\n- When we start using 02 we would not use GetRawExtension, we would do it some other way.\n  Can we make it uniform?\n- We could get rid of GetRawExtension function which I remember that we added back because\n  of 00. This would of course mean that we would first parse a 00 extension to an\n  RtpGenericFrameDescriptor, only to then generate the almost exact same representation\n  again.\n\n\u003e Guess I need to think a bit more about that direction.",
      "parentUuid": "e04601f6_25496ebf",
      "range": {
        "startLine": 383,
        "startChar": 0,
        "endLine": 384,
        "endChar": 75
      },
      "revId": "d4d88f6e385702305ed60d38e3405e00fa57c64a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6cf8c596_9347ec92",
        "filename": "video/rtp_video_stream_receiver.cc",
        "patchSetId": 12
      },
      "lineNbr": 384,
      "author": {
        "id": 5019
      },
      "writtenOn": "2020-02-06T14:26:46Z",
      "side": 1,
      "message": "to make it uniform, how about this solution:\nAdd single function\nAuthenticationBytes(\n    const RTPVideoHeader::GenericDescriptorInfo\u0026 descritpor);\n\nThat would automagically adds authentication of the GFD02 compatible with GFD00.\nThat would break authentication of GFD01 (afaik it is not used), but would make it compatible with GFD00 should we decide to use it.\n\n(Note, this is a draft, if that function looks good, I need to search a better place for it. may be just own file)",
      "parentUuid": "71391e76_1ea039b8",
      "range": {
        "startLine": 383,
        "startChar": 0,
        "endLine": 384,
        "endChar": 75
      },
      "revId": "d4d88f6e385702305ed60d38e3405e00fa57c64a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "48a6ddb3_469107b6",
        "filename": "video/rtp_video_stream_receiver.cc",
        "patchSetId": 12
      },
      "lineNbr": 396,
      "author": {
        "id": 5527
      },
      "writtenOn": "2020-02-06T12:37:31Z",
      "side": 1,
      "message": "This should only be done for the 00 and 01 version right? For 02 we want to have a function that give us the byte representation.",
      "range": {
        "startLine": 390,
        "startChar": 0,
        "endLine": 396,
        "endChar": 49
      },
      "revId": "d4d88f6e385702305ed60d38e3405e00fa57c64a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afcc5175_636de809",
        "filename": "video/rtp_video_stream_receiver.cc",
        "patchSetId": 12
      },
      "lineNbr": 396,
      "author": {
        "id": 5019
      },
      "writtenOn": "2020-02-06T13:06:51Z",
      "side": 1,
      "message": "Sure, that why it is in the block\nif (generic_descriptor !\u003d absl::nullopt)\nwhere generic_descriptor is a type specific for 00 and 01.",
      "parentUuid": "48a6ddb3_469107b6",
      "range": {
        "startLine": 390,
        "startChar": 0,
        "endLine": 396,
        "endChar": 49
      },
      "revId": "d4d88f6e385702305ed60d38e3405e00fa57c64a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "678b47a8_86c8dd04",
        "filename": "video/rtp_video_stream_receiver.cc",
        "patchSetId": 12
      },
      "lineNbr": 396,
      "author": {
        "id": 5527
      },
      "writtenOn": "2020-02-06T13:23:47Z",
      "side": 1,
      "message": "Oops, I misunderstood the if/else cases around here, this is correct.",
      "parentUuid": "afcc5175_636de809",
      "range": {
        "startLine": 390,
        "startChar": 0,
        "endLine": 396,
        "endChar": 49
      },
      "revId": "d4d88f6e385702305ed60d38e3405e00fa57c64a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}