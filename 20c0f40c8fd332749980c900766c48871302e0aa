{
  "comments": [
    {
      "key": {
        "uuid": "c8dce7a6_83b8d9cf",
        "filename": "api/video/encoded_image.h",
        "patchSetId": 4
      },
      "lineNbr": 94,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-03-20T08:52:29Z",
      "side": 1,
      "message": "Should one or the other of these two data() overloads be renamed? Having two overloads differing only in constness is fine, but these also differ in side effect. Now,\n\n  const uint8_t* p \u003d encoded_image.data();\n\nmay behave very differently depending on whether or not encoded_image is const; if it isn\u0027t, we may get an unwanted copy operation. One alternative is to delete the non-const version, and require modification via buffer().data().\n\nI see no obvious way to get this right without a lot of changes to EncodedImage usage. Advice appreciated.",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 94,
        "endChar": 67
      },
      "revId": "20c0f40c8fd332749980c900766c48871302e0aa",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b6f60eb1_e1ece593",
        "filename": "api/video/encoded_image.h",
        "patchSetId": 4
      },
      "lineNbr": 94,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-03-20T09:32:20Z",
      "side": 1,
      "message": "The change is only in whether the buffer is copied or not, right? Apart from performance, that should be ~invisible to users.\n\nThat said, you could have cdata (always const) and data (always non-const). I think that would prevent any confusion at the call sites.",
      "parentUuid": "c8dce7a6_83b8d9cf",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 94,
        "endChar": 67
      },
      "revId": "20c0f40c8fd332749980c900766c48871302e0aa",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97004d13_b3bb7c48",
        "filename": "api/video/encoded_image.h",
        "patchSetId": 4
      },
      "lineNbr": 94,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-03-20T10:13:50Z",
      "side": 1,
      "message": "I\u0027m thinking performance will be pretty important for most users.\n\nChanging the name of the const method to cdata will affect lots of users. But we could do it gradually by adding cdata (guaranteed to never copy) and also keep a const data() method for the time being.",
      "parentUuid": "b6f60eb1_e1ece593",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 94,
        "endChar": 67
      },
      "revId": "20c0f40c8fd332749980c900766c48871302e0aa",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2fc2b266_0b35b8d5",
        "filename": "api/video/encoded_image.h",
        "patchSetId": 4
      },
      "lineNbr": 94,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-03-28T09:40:42Z",
      "side": 1,
      "message": "What about implicit conversion to ArrayView? ArrayView has implicit conversions from types with data() and size() methods. But it doesn\u0027t have implicit conversion using cdata() and size(), right?\n\nIf we don\u0027t want an implicit conversion to ArrayView to ever imply a copy, data() must by the const method, and we\u0027d need something different (mutable_data() ?) for the non-const version.",
      "parentUuid": "97004d13_b3bb7c48",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 94,
        "endChar": 67
      },
      "revId": "20c0f40c8fd332749980c900766c48871302e0aa",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "725f75ad_be03e9f5",
        "filename": "api/video/encoded_image.h",
        "patchSetId": 4
      },
      "lineNbr": 94,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-03-28T10:37:14Z",
      "side": 1,
      "message": "You could define operator ArrayView... but I see your point. Either one takes the approach that COW should happen invisibly, in which case it\u0027s fine to do it in the non-const data overload; or one takes the approach that it\u0027s expensive and should only happen deliberately and explicitly.\n\nI wonder if a good way to do the latter might be to guarantee that all normal methods never mutate the data, except for one Mutate() method that returns a reference to the mutable stuff.\n\n  class MutableFoo;\n\n  class Foo {\n    const uint8_t* data() {...}\n    MutableFoo\u0026 Mutable() { return static_cast\u003cMutableFoo\u003e(*this); }\n  };\n\n  class MutableFoo : public Foo {\n    uint8_t* data() {...}\n  };\n  static_assert(sizeof(MutableFoo) \u003d\u003d sizeof(Foo));  // MutableFoo adds no new state.\n\nThen you could use foo of class Foo without risking a copy as long as you never called foo.Mutable(), but you could e.g. easily call foo.Mutable().data() or SomeMethodThatTakesArrayView(foo.Mutable()) when necessary.",
      "parentUuid": "2fc2b266_0b35b8d5",
      "range": {
        "startLine": 93,
        "startChar": 0,
        "endLine": 94,
        "endChar": 67
      },
      "revId": "20c0f40c8fd332749980c900766c48871302e0aa",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}