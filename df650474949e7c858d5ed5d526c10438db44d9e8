{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "725269df_48994fa3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "I think it is a step in the right direction, but it is not there yet to claim scalability mode support is queried correctly.",
      "range": {
        "startLine": 7,
        "startChar": 24,
        "endLine": 7,
        "endChar": 33
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "796f8803_be4e5702",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-17T14:48:54Z",
      "side": 1,
      "message": "I see your point, correctly is a strong word. I removed it from the commit message.",
      "parentUuid": "725269df_48994fa3",
      "range": {
        "startLine": 7,
        "startChar": 24,
        "endLine": 7,
        "endChar": 33
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3c54040f_2c978bf0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-16T13:48:34Z",
      "side": 1,
      "message": "Danil, can you take a look at this CL if it makes sense.\nQueryCodecSupport() is called by the MediaCapabilities API to determine what modes are supported. The primary reason to have scalability_mode here is to be able to determine if there\u0027s HW support for spatial layers. So the implementation in RTCVideoDecoderFactory/RTCVideoEncoderFactory will return unsupported for most platform if the configuration requires spatial layers.",
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6f614ded_38b86d12",
        "filename": "api/video_codecs/spatial_layer.cc",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "or absl::string_view - it also can be constexpr and also has a trivial destructor.",
      "range": {
        "startLine": 20,
        "startChar": 2,
        "endLine": 20,
        "endChar": 13
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3203456a_37dddd0f",
        "filename": "api/video_codecs/spatial_layer.cc",
        "patchSetId": 3
      },
      "lineNbr": 34,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "what this list maps to?\nit has more modes than currently CreateScalabilityStructure supports,\nbut doesn\u0027t list all modes from the webrtc-svc spec (e.g. L3T3_KEY_SHIFT is missing)\n\nMore importantly, how this list can be kept in sync?",
      "range": {
        "startLine": 25,
        "startChar": 5,
        "endLine": 34,
        "endChar": 62
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9b14288d_940e36b8",
        "filename": "api/video_codecs/spatial_layer.cc",
        "patchSetId": 3
      },
      "lineNbr": 34,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-17T14:48:54Z",
      "side": 1,
      "message": "The list came from\nhttps://www.w3.org/TR/webrtc-svc/#scalabilitymodes*\n\nL3T3_KEY_SHIFT must have been accidentally lost during my cut and paste.",
      "parentUuid": "3203456a_37dddd0f",
      "range": {
        "startLine": 25,
        "startChar": 5,
        "endLine": 34,
        "endChar": 62
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5784f26a_d2712eeb",
        "filename": "api/video_codecs/spatial_layer.cc",
        "patchSetId": 3
      },
      "lineNbr": 56,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "may be for now this hack might be ok (with proper comment):\n  if (scalability_mode.size() \u003e\u003d4 \u0026\u0026 \n      scalability_mode[1] \u003e\u003d \u00271\u0027 \u0026\u0026\n      scalability_mode[1] \u003c\u003d \u00273\u0027) {\n    return scalability_mode[1] - \u00270\u0027;\n  }\n  return absl::nullopt;\nIt is also future proof for future structures that would uses similar naming (e.g. \"L3T1h\" is not mentioned in the standard, but is a reasonable structure)\n\nBut I\u0027m worried about plans to add vp9 screenshare scalability structures that are not in the list above (and do not have a name in the svc standard).\nGuess will need to remember about this function while adding them.\n\nlater it might be expanded to \n  if (some_fast_check) { return scalability_mode[1] - \u00270\u0027; }\n  if (scalability_mode \u003d\u003d \"NONE\") return 1;\n  // expensive extract, may be LOG WARNING to remind adding a fast check or extending a list of known structures above.\n  if (auto structure \u003d CreateScalabilityStructure(scalability_mode)) {\n    return structure-\u003eStreamConfig().num_spatial_layers;\n  }\n  return absl::nullopt;",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 56,
        "endChar": 23
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5d9f3aa_20be49d9",
        "filename": "api/video_codecs/spatial_layer.cc",
        "patchSetId": 3
      },
      "lineNbr": 56,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-17T14:48:54Z",
      "side": 1,
      "message": "I\u0027ll update the code according to your first suggestion with the additional constraint that scalability_mode[0] \u003d\u003d \u0027L\u0027 or \u0027S\u0027 and scalability_mode[2] \u003d\u003d \u0027T\u0027",
      "parentUuid": "5784f26a_d2712eeb",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 56,
        "endChar": 23
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3834ea68_889a6a24",
        "filename": "api/video_codecs/spatial_layer.cc",
        "patchSetId": 3
      },
      "lineNbr": 56,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-18T15:03:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f5d9f3aa_20be49d9",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 56,
        "endChar": 23
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5acb23c7_875588a7",
        "filename": "api/video_codecs/spatial_layer.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "may be add documentation for this api function.\nin particular what does result of nullopt mean.\n\nI\u0027m also a bit concern of the name that suggests it is convert function, or function that does something with the struct just above.\nmay be name like this one is better: \u0027NumSpatialLayersInScalabilityMode\u0027",
      "range": {
        "startLine": 36,
        "startChar": 31,
        "endLine": 36,
        "endChar": 61
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "65b11bb9_8d3e3211",
        "filename": "api/video_codecs/spatial_layer.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-17T14:48:54Z",
      "side": 1,
      "message": "Good suggestion, will update.",
      "parentUuid": "5acb23c7_875588a7",
      "range": {
        "startLine": 36,
        "startChar": 31,
        "endLine": 36,
        "endChar": 61
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d64b0576_b2090cfc",
        "filename": "api/video_codecs/spatial_layer.h",
        "patchSetId": 3
      },
      "lineNbr": 36,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-18T15:03:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "65b11bb9_8d3e3211",
      "range": {
        "startLine": 36,
        "startChar": 31,
        "endLine": 36,
        "endChar": 61
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a154792_ae2ec1b0",
        "filename": "api/video_codecs/spatial_layer.h",
        "patchSetId": 3
      },
      "lineNbr": 37,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "absl::string_view usually better parameter type than reference to std::string\nhttps://abseil.io/tips/1",
      "range": {
        "startLine": 37,
        "startChar": 4,
        "endLine": 37,
        "endChar": 22
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c050b2dc_5830f6fe",
        "filename": "api/video_codecs/spatial_layer.h",
        "patchSetId": 3
      },
      "lineNbr": 37,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-18T15:03:28Z",
      "side": 1,
      "message": "Fixed. My first implementation was in chromium, where absl::string_view is not allowed yet. Maybe should push for that.",
      "parentUuid": "9a154792_ae2ec1b0",
      "range": {
        "startLine": 37,
        "startChar": 4,
        "endLine": 37,
        "endChar": 22
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c3b4689d_78b31c2b",
        "filename": "api/video_codecs/spatial_layer.h",
        "patchSetId": 3
      },
      "lineNbr": 37,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-21T10:27:01Z",
      "side": 1,
      "message": "absl::string_view in chromium was already pushed back:\nhttp://chromium-cpp.appspot.com/#absl-blocklist\n(But sure, nothing is final)",
      "parentUuid": "c050b2dc_5830f6fe",
      "range": {
        "startLine": 37,
        "startChar": 4,
        "endLine": 37,
        "endChar": 22
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b6e2978_921b73fc",
        "filename": "api/video_codecs/spatial_layer.h",
        "patchSetId": 3
      },
      "lineNbr": 37,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-22T09:07:54Z",
      "side": 1,
      "message": "I see, thanks for the info!",
      "parentUuid": "c3b4689d_78b31c2b",
      "range": {
        "startLine": 37,
        "startChar": 4,
        "endLine": 37,
        "endChar": 22
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f8bb220_f9972001",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "why Decoder is queried for scalability mode support?\nIf encoder can produce valid bitstream using certain scalability mode, decoder should be able to understand it.\n(there are still exceptions.... e.g. some hardwarde vp9 decoders do not support KSVC structure, but that is more like a bug than something to design around)",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c480a58_1a0e67b6",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-17T14:48:54Z",
      "side": 1,
      "message": "My goal is this:\nGiven a video configuration I want to be able to determine if the video will playback smoothly or not, and similarly for the encode side. Currently, spatial layers will make the video flow through SW decoding/encoding even though there is HW support (there are some exceptions). \nSo for now it appears to me that I must consider the exceptions and query the decoder to get this information.",
      "parentUuid": "2f8bb220_f9972001",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9abd789b_658ed532",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-17T15:40:22Z",
      "side": 1,
      "message": "I doubt scalability mode is important for the question \u0027video will playback smoothly\u0027. scalability_mode is really for encoder to decide how to organise frame dependencies and layers. Decoder doesn\u0027t need to know about layers.\n\ncurrent code seems to return false for configuration that encoder won\u0027t be able to produce, configurations decoder would never ever see.\n\nfor av1 I know there are levels and tiers to communicate decoder capabilities (see Annex A in https://aomediacodec.github.io/av1-spec/av1-spec.pdf for more details)",
      "parentUuid": "0c480a58_1a0e67b6",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3837830_9ed5c2e7",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-18T07:51:49Z",
      "side": 1,
      "message": "I will try to rephrase myself:\nA particular client has a weak CPU but a GPU that can do HW decoding of VP9 without spatial layers. This means that the client can handle VP9 without spatial layers smoothly at a certain resolution, however it cannot handle VP9 with spatial layers since this will be done in SW. Because of this scalability mode is important to answer the question if it will play smoothly. Although it\u0027s an exception, it\u0027s an important one and will be so for quite some time.",
      "parentUuid": "9abd789b_658ed532",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66fc88b1_8e38ea8f",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-21T10:27:01Z",
      "side": 1,
      "message": "Are there any other special cases where choice between SW and HW decoders depend on structure?\n\nafaik vp9 HW decoder not supporting spatial layers is a bug (crbug.com/1022359)\nIf you want to have a workaround for that particular bug, may be call the functions accordingly, make it clear it is just about this case.\n\nBesides, the answer is a bit more nuanced even in that case:\nwhen sender produces structure S3Tx, the receiving side should see only single spatial layer (other two spatial layers should be filtered somewhere). That spatial layer should be decodable with HW decoding.\nsimilarly, HW decoding is possible when client receivers only bottom spatial layer of L3Tx(_KEY)? structures, i.e. whenever there are no spatial dependencies.",
      "parentUuid": "a3837830_9ed5c2e7",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1eb6abc9_b8f9da0e",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-22T09:07:54Z",
      "side": 1,
      "message": "There are no other special cases that I know of.\n\nThanks for the clarification of S3Tx, so the check in the equivalent function for the hardware decoder factory should be if there are spatial dependent layers.\n\nThere\u0027s also another bug related to this, https://crbug.com/webrtc/9304\n\nAgain, although it is a bug, it will remain for years to come. What do you mean with \"call the functions accordingly\"? Although the decode side could be narrowed down to perhaps have num_spatial_layers or something like that as input parameter, I think that there are some benefits to have similar APIs for the encoder and decoder.",
      "parentUuid": "66fc88b1_8e38ea8f",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08cd3d4c_795091ea",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-22T11:23:35Z",
      "side": 1,
      "message": "This function, does it guess support for software or hardware decoder?\n\nIt if is software, then I do not understand the point of the function. All it does is duplicate check of the encoder support, which doesn\u0027t make sense to me on the decoder side (all legal streams encoder can produce should be supported by the software decoder. I do not understand value in returning \u0027false\u0027 for VP8 L2T2 structures because VP8 encoder is unable to produce such structure anyway. Even if it can, it would produce it in such a way software decoder can understand it.)\nMore practical example: if later (or different) browser adds support for temporal layering in H264 (e.g. using DD extension), then decoder should be able to understand that stream.\n\nif it is hardware, then I would prefer it to be just about vp9:\n  bool SupportVp9SpatialLayers() { return software_ || !chipset.IsOld(); }\n\nIf this function has to keep current signature (why?)\nthen probably it should be simpler:\n  if (scalability_mode \u0026\u0026\n    NumSpatialLayersInScalabilityMode(*scalability_mode) \u003e 1 \u0026\u0026\n    StrCaseCmp(format.name,cricket::Vp9) \u003d\u003d 0) {\n    // Due to the bugs crbug.com/123 and bugs.webrtc.org/567 VP9 hardware doesn\u0027t\n    // support spatial scalability.\n    return {false, false};\n  }\n\n(then again, this check likely should be more complicated: \ncrbug.com/1022359 is about predicting from different resolution. Multiple spatial layers with the same resolution are supported)",
      "parentUuid": "1eb6abc9_b8f9da0e",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f8b991d_daa20f9a",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-22T12:32:18Z",
      "side": 1,
      "message": "The MediaCapabilities API is called by the user from JavaScript, so that\u0027s why it seems relevant to be able to respond correctly to VP8 L2T2 even though there\u0027s no encoder that can produce it.\n\nThere should be as little guessing as possible, RTCVideoDecoderFactory responds about HW capabilities and InternalDecoderFactory responds about SW capabilities.\n\nI just read https://www.w3.org/TR/webrtc-svc/#intro again, and it seems to be in line with that document that decoders may list there supported scalability modes as well.",
      "parentUuid": "08cd3d4c_795091ea",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d3896f4_5d6005c4",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-22T17:23:07Z",
      "side": 1,
      "message": "Reading the introduction, I understand the part\n\"Since ... codecs implemented in browsers require that compliant decoders be capable of decoding any legal encoding sent by an encoder, this specification does not support decoder configuration.\"\nnormally decoder is not even aware of the used scalability mode.\n\nnext sentence sort of contradicts the previous one, I\u0027m still trying to understand it.\n\"However, it is possible for decoders that cannot decode any legal bitstream to describe the supported scalability modes\".\n\nlet me think a bit more about it...\nIn my mind scalability_mode plays negligible role in deciding if stream can be decoded smoothly, resolution and framerate, cpu capabilities and cpu load, hw decoder capabilities plays much higher roles. (I\u0027m not sure any hw decoder can smoothly decode 4k stream without scalability)",
      "parentUuid": "0f8b991d_daa20f9a",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c562cf5_6705c1c8",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-28T13:04:52Z",
      "side": 1,
      "message": "I read through the webrtc-svc spec a bit more to find clarification about decoder capabilities. As I understand it, it is not supposed to be used for codecs like VP8 and VP9, but might be feasible for other codecs (H264?)\n\n\"Codecs such as VP8, VP9 and AV1 mandate support for SVC and require a compliant decoder to be able to decode any compliant encoding that an encoder can send. Therefore, for these codecs there is no need to configure the decoder or to negotiate SVC support within Offer/Answer\"\"\n\nLater same is repeated with the different words:\n\"In response to a call to RTCRtpReceiver.getCapabilities(kind), decoders that do not support decoding of scalability modes or that are required to decode any scalability mode (such as compliant VP8, VP9 and AV1 decoders) omit the scalabilityModes member.\"\n\nIt seems there is a gray area because there are non-compliant HW VP9 decoders.\nHowever software decoder is complaint and thus doesn\u0027t need to explicitly list supported scalability modes.\n\nSuggestion: ignore scalability_mode parameter when codec is VP8, VP9 or AV1.",
      "parentUuid": "2d3896f4_5d6005c4",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "027c84e8_a181d111",
        "filename": "media/engine/internal_decoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-08-31T14:02:27Z",
      "side": 1,
      "message": "It\u0027s left to see where the spec discussion ends up, but I\u0027m now using the new signature with reference_scaling internally in WebRTC at least.",
      "parentUuid": "0c562cf5_6705c1c8",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 52,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3e20b9d7_833e67fe",
        "filename": "media/engine/internal_decoder_factory_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "it is right to remove \u0027Test\u0027 prefix from the name of the test.\nMay be also move it as suffix of the suite name:\nTEST(InternalDecoderFactoryTest, Vp8)",
      "range": {
        "startLine": 42,
        "startChar": 29,
        "endLine": 42,
        "endChar": 31
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06285a5d_78889a09",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "That is just a guess. and sometimes it is wrong.\nTo make it correct, EncoderFactory really should ask the encoder implementation.\nE.g. hardware vp9 encoder probably doesn\u0027t support multiple spatial layers.\n(but then chromium vp9 hardward encoder with temporal layers use some own structure, not the L1T3 or any other from the webrtc-svc standard)\nSimulcast Vp8 encoder might be able to support S3Tx structures (and decode won\u0027t even need to know how many spatial layers there were before filtering)\nVp9 encoders likely won\u0027t ever support KEY_SHIFT structures (incompatible with the vp9 rtp descriptor)\nav1 encoder haven\u0027t yet implemented L3T3_KEY_SHIFT structure (I will add it eventually, but right now it is not there)",
      "range": {
        "startLine": 71,
        "startChar": 4,
        "endLine": 73,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c37360c_ecc69bcb",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-17T14:48:54Z",
      "side": 1,
      "message": "If there is a hardware encoder/decoder it will be queried first to see if it supports the codec and selected mode.\n\nIt sounds like I need a hardcoded list per encoder?",
      "parentUuid": "06285a5d_78889a09",
      "range": {
        "startLine": 71,
        "startChar": 4,
        "endLine": 73,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c44cbf5c_7f2c4fb3",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-17T15:40:22Z",
      "side": 1,
      "message": "Yep, I think each encoder implementations should have a function that returns list of supported structures. (it is then up to that encoder wrapper to decide if the list is hardcoded or assembled on the fly)\nI.e. something that would be propagated to \nhttps://w3c.github.io/webrtc-svc/#rtcrtpcodeccapability*\n\nCurrent code is okeish first approximation: I think it is ok to submit it and leave a TODO to pull more accurate list from the encoders.",
      "parentUuid": "6c37360c_ecc69bcb",
      "range": {
        "startLine": 71,
        "startChar": 4,
        "endLine": 73,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f97f861_c596f228",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-18T07:51:49Z",
      "side": 1,
      "message": "Thanks, I\u0027ll add a TODO.\n\nWhen I proposed the extension of MediaCapabilties to WebRTC, it was also considered to instead put this functionality in RTCRtpSender/RTCRtpReceiver.getCapabilities(), but it seemed to be a consensus that getCapabilities() has some problems due to it being synchronous and that it was better to take the MediaCapabilities path.",
      "parentUuid": "c44cbf5c_7f2c4fb3",
      "range": {
        "startLine": 71,
        "startChar": 4,
        "endLine": 73,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5d36e8b0_8ebc117f",
        "filename": "media/engine/internal_encoder_factory.cc",
        "patchSetId": 3
      },
      "lineNbr": 73,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-18T15:03:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8f97f861_c596f228",
      "range": {
        "startLine": 71,
        "startChar": 4,
        "endLine": 73,
        "endChar": 39
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fec6680c_bd3d778f",
        "filename": "media/engine/internal_encoder_factory_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 41,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "move into unnamed namespace, before the constants\n\nhttps://abseil.io/tips/119#summary\n\n\"Declare namespace aliases and using-declarations inside the innermost namespace, whether named or anonymous\"",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 41,
        "endChar": 0
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "399e36c8_a5d6a8fd",
        "filename": "media/engine/internal_encoder_factory_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 41,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-18T15:03:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fec6680c_bd3d778f",
      "range": {
        "startLine": 37,
        "startChar": 0,
        "endLine": 41,
        "endChar": 0
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e8c37856_c4df65ed",
        "filename": "media/engine/internal_encoder_factory_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "name it InternalEncoderFactoryTest\n(otherwise there might be name collision with the object under test)",
      "range": {
        "startLine": 42,
        "startChar": 5,
        "endLine": 42,
        "endChar": 27
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17bdd310_2fd59cd4",
        "filename": "media/engine/internal_encoder_factory_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-18T15:03:28Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e8c37856_c4df65ed",
      "range": {
        "startLine": 42,
        "startChar": 5,
        "endLine": 42,
        "endChar": 27
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d68e174_74455d5e",
        "filename": "media/engine/internal_encoder_factory_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 5019
      },
      "writtenOn": "2021-06-16T14:45:07Z",
      "side": 1,
      "message": "should we already support the av1 using registered \u0027AV1\u0027 name\n(and for legacy reason keep accepting name \u0027AV1X\u0027 too)",
      "range": {
        "startLine": 58,
        "startChar": 29,
        "endLine": 58,
        "endChar": 32
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b5c18dfe_e3f7c367",
        "filename": "media/engine/internal_encoder_factory_unittest.cc",
        "patchSetId": 3
      },
      "lineNbr": 58,
      "author": {
        "id": 7641
      },
      "writtenOn": "2021-06-18T15:03:28Z",
      "side": 1,
      "message": "I have no idea about AV1X vs AV1 and how that transition will happen. I\u0027ll change to use cricket::kAv1CodecName.",
      "parentUuid": "3d68e174_74455d5e",
      "range": {
        "startLine": 58,
        "startChar": 29,
        "endLine": 58,
        "endChar": 32
      },
      "revId": "df650474949e7c858d5ed5d526c10438db44d9e8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}