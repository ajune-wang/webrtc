{
  "comments": [
    {
      "key": {
        "uuid": "d360ef8b_d977c0e2",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 1
      },
      "lineNbr": 68,
      "author": {
        "id": 5531
      },
      "writtenOn": "2018-03-02T13:16:16Z",
      "side": 1,
      "message": "Note that we now have six different configurated bitrates: min_bitrate, max_bitrate, start_bitrate, min_send_bitrate, max_padding_bitrate, and total_bitrate.\n\nIt\u0027s not obvious to me what the total bitrate represents from the bitrate estimation perspective. In practice it seems to be used as a way to request a bitrate probe at a level in between the current estimate and the max_bitrate, but only when the value changes?\n\nMaybe the intent is to repeat the probe periodically if it is not reached? If so, maybe it can be considered a target bitrate? The bitrate target we will try to reach if it is not fulfilled.\n\nHowever, than we can start wondering, what is the difference between this bitrate and the max bitrate? I\u0027d say that the max bitrate is the maximum we will report as encoder target if detected while the target bitrate is the maximum we will spend resources, such as a probe, to get. The default for target bitrate would then naturally be max_bitrate, but set lower by this interface. Is this a correct understanding?",
      "range": {
        "startLine": 68,
        "startChar": 8,
        "endLine": 68,
        "endChar": 25
      },
      "revId": "d7f818d4432b6d601c0a37cfacbaa4cce489fc20",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ea79a0a_98872ebd",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 1
      },
      "lineNbr": 68,
      "author": {
        "id": 5527
      },
      "writtenOn": "2018-03-05T14:28:15Z",
      "side": 1,
      "message": "|total_bitrate_bps| is the sum of bitrates for all active streams, and it\u0027s updated as soon as any stream is activated/deactivated or any configured bitrate for a stream has been updated.\n\nThe ProbeController is the class that decides what to do with this information, and it will probe at min(total_bitrate_bps, max_bitrate_bps) if the estimated is not already equal or higher to that bitrate.",
      "parentUuid": "d360ef8b_d977c0e2",
      "range": {
        "startLine": 68,
        "startChar": 8,
        "endLine": 68,
        "endChar": 25
      },
      "revId": "d7f818d4432b6d601c0a37cfacbaa4cce489fc20",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "88af15f0_4e317cb5",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 1
      },
      "lineNbr": 68,
      "author": {
        "id": 5531
      },
      "writtenOn": "2018-03-05T17:02:31Z",
      "side": 1,
      "message": "Ok, I see what you mean, if we consider it the Probe Controllers responsibility to act on this value I think the name should show that it is the maximum possible bitrate that can be allocated to the send streams.\n\nIn this context the function name actually tells us that it is allocated send bitrate limits that are set, so max_total_bitrate_bps would probably be enough. It would probably be appropriate to add more information to SSCC function name though, for instance SetMaxTotalAllocatedBitrate.",
      "parentUuid": "9ea79a0a_98872ebd",
      "range": {
        "startLine": 68,
        "startChar": 8,
        "endLine": 68,
        "endChar": 25
      },
      "revId": "d7f818d4432b6d601c0a37cfacbaa4cce489fc20",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e991d2d3_f794a578",
        "filename": "call/rtp_transport_controller_send.cc",
        "patchSetId": 1
      },
      "lineNbr": 71,
      "author": {
        "id": 5531
      },
      "writtenOn": "2018-03-02T13:16:16Z",
      "side": 1,
      "message": "Just a note, the new SSCC implements SetSendBitrateLimits, so total bitrate can probably be given as an extra argument there. For the legacy SSCC this variant seems right.",
      "range": {
        "startLine": 70,
        "startChar": 0,
        "endLine": 71,
        "endChar": 0
      },
      "revId": "d7f818d4432b6d601c0a37cfacbaa4cce489fc20",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4f79443_dbdf8d2a",
        "filename": "modules/congestion_controller/probe_controller.cc",
        "patchSetId": 1
      },
      "lineNbr": 128,
      "author": {
        "id": 5531
      },
      "writtenOn": "2018-03-02T13:16:16Z",
      "side": 1,
      "message": "This method doesn\u0027t seem to actually set any total bitrate property on the probe controller, which is what I woul expect given this name. It triggers a probe under the condition that there is a set estimated bitrate lower than max bitrate and the given bitrate. Could this be better reflected in the name?\n\nSomething like TriggerProbeIfEstimateLowerThanBitrate(int64_t bitrate) would be clearer, possibly a bit long. I\u0027d say that clarity beats terseness though.",
      "range": {
        "startLine": 128,
        "startChar": 22,
        "endLine": 128,
        "endChar": 37
      },
      "revId": "d7f818d4432b6d601c0a37cfacbaa4cce489fc20",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f6c8498a_1e8ef579",
        "filename": "modules/congestion_controller/probe_controller.cc",
        "patchSetId": 1
      },
      "lineNbr": 128,
      "author": {
        "id": 5527
      },
      "writtenOn": "2018-03-05T14:28:15Z",
      "side": 1,
      "message": "Agree that the name is a bit confusing, but it\u0027s up to the ProbeController to decide what to do, so TriggerProbeIfEstimateLowerThanBitrate is to explicit.\n\nWDYT about UpdateTotalBitrate or NewTotalBitrate?",
      "parentUuid": "a4f79443_dbdf8d2a",
      "range": {
        "startLine": 128,
        "startChar": 22,
        "endLine": 128,
        "endChar": 37
      },
      "revId": "d7f818d4432b6d601c0a37cfacbaa4cce489fc20",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0d21aae_a2835f0e",
        "filename": "modules/congestion_controller/probe_controller.cc",
        "patchSetId": 1
      },
      "lineNbr": 128,
      "author": {
        "id": 5531
      },
      "writtenOn": "2018-03-05T17:02:31Z",
      "side": 1,
      "message": "I think I understand what you mean, it can make sense that it\u0027s up to the ProbeController to decide what to do. I think the simple implementation made me assume that the probe side effect was part of the intended interface. \n\nWhat about using On...? That doesn\u0027t imply anything about how probe controller will use the value, only that it for some reason listens to it and might want to do something with it.\n\nCould it be named ...MaxTotalAllocatedBitrate to make it easier to understand it\u0027s context. Might even make sense to add a comment in the header file about why we have two different maximum values?",
      "parentUuid": "f6c8498a_1e8ef579",
      "range": {
        "startLine": 128,
        "startChar": 22,
        "endLine": 128,
        "endChar": 37
      },
      "revId": "d7f818d4432b6d601c0a37cfacbaa4cce489fc20",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1513a20_15ba81e5",
        "filename": "modules/congestion_controller/probe_controller.cc",
        "patchSetId": 1
      },
      "lineNbr": 130,
      "author": {
        "id": 5531
      },
      "writtenOn": "2018-03-05T17:02:31Z",
      "side": 1,
      "message": "Could you add a comment explaining why it only needs to send the probe when receiving a new value and why the value is not saved for use in ALR probing?",
      "revId": "d7f818d4432b6d601c0a37cfacbaa4cce489fc20",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ea480dc_498e17c3",
        "filename": "modules/congestion_controller/probe_controller_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 270,
      "author": {
        "id": 5531
      },
      "writtenOn": "2018-03-02T13:16:16Z",
      "side": 1,
      "message": "Should be LegacyProbeControllerTest if added to this file.",
      "range": {
        "startLine": 270,
        "startChar": 7,
        "endLine": 270,
        "endChar": 26
      },
      "revId": "d7f818d4432b6d601c0a37cfacbaa4cce489fc20",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "302f4202_1eb3d431",
        "filename": "modules/congestion_controller/probe_controller_unittest.cc",
        "patchSetId": 1
      },
      "lineNbr": 270,
      "author": {
        "id": 5527
      },
      "writtenOn": "2018-03-05T14:28:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1ea480dc_498e17c3",
      "range": {
        "startLine": 270,
        "startChar": 7,
        "endLine": 270,
        "endChar": 26
      },
      "revId": "d7f818d4432b6d601c0a37cfacbaa4cce489fc20",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}