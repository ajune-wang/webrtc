{
  "comments": [
    {
      "key": {
        "uuid": "a2ed9e6b_5438f5f4",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 5126
      },
      "writtenOn": "2017-10-23T19:51:14Z",
      "side": 1,
      "message": "Right, here we have the only three lines that touch posted_frames_waiting_for_encode_.\n\n* We don\u0027t initialize the variable anywhere. Isn\u0027t that required? (And might that be the difference between std::atomic\u003cint\u003e and Atomic32 that you were looking for?\n\n* On line 134, we increment at the end of the constructor. OK\n\n* On line 141, we load the value to check that it\u0027s \u003e 0. Then we decrement it on line 145, and do different things depending on if the value reached 0 or not. This should probably be done with a single atomic operation; if we simply save the result of --video_stream_encoder_-\u003eposted_frames_waiting_for_encode_ in a local, we can first DCHECK that it\u0027s \u003e\u003d 0, and then do the same if condition that line 145 already does.\n\n* As for optimizing this by using a more relaxed memory ordering, I believe line 134 could use .fetch_add(1, std:: memory_order_release), and line 145 could use .fetch_sub(1, std::memory_order_acquire) (which returns the value of the variable immediately before the decrement). So,\n\n  video_stream_encoder_-\u003eposted_frames_waiting_for_encode_\n      .fetch_add(1, std:: memory_order_release);\n\nand\n\n  const int posted_frames_waiting_for_encode \u003d\n      video_stream_encoder_-\u003eposted_frames_waiting_for_encode_\n      .fetch_sub(1, std::memory_order_acquire);\n  RTC_DCHECK_GT(posted_frames_waiting_for_encode, 0);\n  if (posted_frames_waiting_for_encode \u003d\u003d 1) {\n\nI\u0027m pretty sure that release-acquire ordering is what we want, but it\u0027s probably a great idea for you too to read http://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering (and maybe the rest of that page...) to get a sanity check.",
      "revId": "c1bf560cddb8037043bbbaeea189f9d4661ca06d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a0a4d9fe_d4b228a4",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 5234
      },
      "writtenOn": "2017-10-24T07:05:26Z",
      "side": 1,
      "message": "\u003e Right, here we have the only three lines that touch posted_frames_waiting_for_encode_.\n\u003e \n\u003e * We don\u0027t initialize the variable anywhere. Isn\u0027t that required? (And might that be the difference between std::atomic\u003cint\u003e and Atomic32 that you were looking for?\n\nGood catch. And the linux_memcheck bot seems to agree. We\u0027ll see if it works better with this fixed.\n \n\u003e I\u0027m pretty sure that release-acquire ordering is what we want, but it\u0027s probably a great idea for you too to read http://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering (and maybe the rest of that page...) to get a sanity check.\n\nI\u0027m thinking that maybe memory_order_relaxed is sufficient. As far as I understand, the purpose of the counter is just to drop frames if we have more than one in flight; synchronization of the data accessed by the task should be provided by the TaskQueue machinery.\n\nBut I\u0027m not sure I want to introduce subtle changes to memory order in this cl.",
      "parentUuid": "a2ed9e6b_5438f5f4",
      "revId": "c1bf560cddb8037043bbbaeea189f9d4661ca06d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1ab75d8_6c41dde1",
        "filename": "video/video_stream_encoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 145,
      "author": {
        "id": 5126
      },
      "writtenOn": "2017-10-24T09:12:37Z",
      "side": 1,
      "message": "You may be right, but at that point it\u0027s getting messy. I think generally the right thing to do is to provide abstractions, like your reference counter class, and do our best to try to avoid using atomics directly in code like this. It\u0027s kind of the same thing as with memory management---the only place where you should do manual memory management is when you implement things like unique_ptr, whose only job is to abstract away the details of memory management.\n\nI guess the abstraction we want here is something like this:\n\n  // A companion to a synchronized data structure, referred to as a \"jar\". Tracks\n  // the number of \"beans\" that we have put in the jar; because the BeanCounter isn\u0027t\n  // tightly synchronized with the jar, the actual number of beans in the jar may be\n  // more (but never less) than what the BeanCounter thinks, and thus WillRemoveABean()\n  // may sometimes falsely claim that we are about to remove the last bean, but it\n  // will never falsely claim that the bean that we\u0027re about to remove will not be the\n  // last one.\n  class BeanCounter {\n   public:\n    // Call after having added one bean to the jar.\n    void HaveAddedABean() { beans_.fetch_add(1, std::memory_order_relaxed); }\n\n    // Call before removing one bean from the jar. Returns true if the jar\n    // may now be empty.\n    bool WillRemoveABean() {\n      const int beans_before \u003d beans_.fetch_sub(1, std::memory_order_relaxed);\n      return beans_before \u003c\u003d 1;\n    }\n\n   private:\n    // Lower bound on the number of beans in the jar. Note that this may temporarily\n    // be negative, in case a WillRemoveABean() call is reordered before a\n    // HaveAddedABean() call.\n    std::atomic\u003cint\u003e beans_ \u003d 0;\n  };",
      "parentUuid": "a0a4d9fe_d4b228a4",
      "revId": "c1bf560cddb8037043bbbaeea189f9d4661ca06d",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}