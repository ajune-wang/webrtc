{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "24040f44_0a53272c",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 4
      },
      "lineNbr": 309,
      "author": {
        "id": 14634
      },
      "writtenOn": "2023-04-11T19:28:39Z",
      "side": 1,
      "message": "maybe I\u0027m reading this wrong - but low_limit was previously TargetLevelMs * (3 / 4) - doesn\u0027t this raise the low_limit, and thus make us decelerate more often?",
      "revId": "adfc1601c1262c5c83bfae5287fff0ee015f8a9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91f6777d_ad328fd1",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 4
      },
      "lineNbr": 309,
      "author": {
        "id": 8038
      },
      "writtenOn": "2023-04-11T20:21:00Z",
      "side": 1,
      "message": "Correct. It\u0027s possible that keeping the low limit would further reduce deceleration (note that the overall change is a very big improvement). I removed it to simplify things, it doesn\u0027t make as much sense conceptually anymore since we increase the high limit instead, but I can run a few more tests to see if it is worth keeping.",
      "parentUuid": "24040f44_0a53272c",
      "revId": "adfc1601c1262c5c83bfae5287fff0ee015f8a9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a907be6_6f824671",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 4
      },
      "lineNbr": 309,
      "author": {
        "id": 14634
      },
      "writtenOn": "2023-04-12T00:22:12Z",
      "side": 1,
      "message": "Ah I see - you\u0027re talking about the deceleration reduction we get by not immediately accelerating after receiving a spike, when followed by another spike.\n\nI was picturing a slightly different case - of preventing deceleration when \u0027riding\u0027 spikes smaller than TargetLevelMs. \nLets say we often get spikes of 150ms delay, and our target delay is calculated at 200ms. \nThen, if we currently 100ms into a spike, and thus playout_delay_ms is currently 100, it\u0027s debatable whether we actually need to start decelerating, even though playout delay is far below the target level - if 90% of spikes are less than 150ms, its likely we will get the packet we need in 50ms, and won\u0027t underrun, with no time scaling needed. \nOr maybe we\u0027re thinking of the same thing, just smearing the gap in different directions..",
      "parentUuid": "91f6777d_ad328fd1",
      "revId": "adfc1601c1262c5c83bfae5287fff0ee015f8a9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c1a599e_abb57c4c",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 4
      },
      "lineNbr": 309,
      "author": {
        "id": 8038
      },
      "writtenOn": "2023-04-12T01:11:13Z",
      "side": 1,
      "message": "Ah I see what you mean. That case is handled by the way the way we measure the playout delay. Assuming the delay spike is shorter than 2s (size of the packet history which is somewhat arbitrarily chosen), then the estimated playout delay will not change.",
      "parentUuid": "9a907be6_6f824671",
      "revId": "adfc1601c1262c5c83bfae5287fff0ee015f8a9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "37d50e40_132b4884",
        "filename": "modules/audio_coding/neteq/decision_logic.cc",
        "patchSetId": 4
      },
      "lineNbr": 309,
      "author": {
        "id": 14634
      },
      "writtenOn": "2023-04-12T01:23:17Z",
      "side": 1,
      "message": "Right, its coming back to me now - this is the whole point of stable playout delay in the first place. I was thinking of the old \u0027buffer_level_samples\u0027 when thinking of GetPlayoutDelayMs, not the new way",
      "parentUuid": "1c1a599e_abb57c4c",
      "revId": "adfc1601c1262c5c83bfae5287fff0ee015f8a9e",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}