{
  "comments": [
    {
      "key": {
        "uuid": "9b2a5e9d_09e0efd9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-14T15:15:51Z",
      "side": 1,
      "message": "What does this mean? What happens to the queued task? Which thread deletes its resources?",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "52b6b60e_cafb695e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T08:02:23Z",
      "side": 1,
      "message": "It\u0027s similar to TaskQueue::PostTask(...): The TaskQueue/MessageQueue takes ownership of the the thing posted. If the task gets to run, it is deleted on the TaskQueue thread. If it doesn\u0027t get to run, it is nevertheless deleted, but that may happen at some unspecified time on some unspecified thread. In the case that caused trouble, I think destruction happens on the main thread, from the AutoThread destructor, invoked just before main returns.",
      "parentUuid": "9b2a5e9d_09e0efd9",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2dc7d093_dbf64829",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 13,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-16T09:03:14Z",
      "side": 1,
      "message": "This breaks the contract.\n\n// Posts a task to invoke the functor on |this| thread asynchronously, i.e.\n// without blocking the thread that invoked PostTask(). Ownership of |functor|\n// is passed and destroyed on |this| thread after it is invoked.\n...\n\nWe can change the contract to not hold in the case of thread shutdown, but I\u0027m afraid we would hide real races.\n\nOne of the use cases I want PostTask to support is:\n\n// Delete |foo| on |thread_|.\nvoid DeleteFoo(std::unique_ptr\u003cFoo\u003e foo) {}\nthread_-\u003ePostTask(\n  FROM_HERE,\n  rtc::Bind(\u0026DeleteFoo, std::move(foo));\n\nThis allows Foo to have destructors with DCHECKs that it is destroyed on the right thread, and allows the destructor to have dependency on things that live on the target thread, and so on.\n\nIf the message is deleted (including its arguments) then we can no longer use PostTask to clean things up on the desired thread.",
      "parentUuid": "52b6b60e_cafb695e",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a083879a_ee3a1cf5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-16T09:03:14Z",
      "side": 1,
      "message": "I think I know what the leak is, and that this is a real bug.\n\nRTCStatsCollector::ProducePartialResultsOnNetworkThread posts a task to perform MergeNetworkReport_s on the signaling thread. Normally, we rely on this task being run, and a test would not quit until all pending stats requests have completed.\n\nHowever, when PeerConnection::Close() is called, there is a special code path that triggers completing the task request, without waiting for the posted task to run. Close() calls RTCStatsCollector::WaitForPendingRequest(). This performs the work of MergeNetworkReport_s, and when/if the previously posted MergeNetworkReport_s runs after that it is a NO-OP.\n\nIf we want to be able to shut down the thread after PeerConnection::Close() there are a few options...\n1. Make posted tasks cancellable, and WaitForPendingRequest would cancel the posted task since it is no longer needed.\n2. When a thread is shutting down, make sure it runs all of the tasks in its queue before quitting.\n3. Change the contract of PostTask, and make the caller responsible for either making sure the task has time to run before thread is shut down or be prepared for the message to be deleted on the wrong thread without the task running.",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "580ee8a3_ae9bafc8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 17,
      "author": {
        "id": 5142
      },
      "writtenOn": "2019-05-16T09:05:38Z",
      "side": 1,
      "message": "Do we not do 2) already?\nWhat does https://webrtc-review.googlesource.com/c/src/+/39680 change with regards to tasks running?",
      "parentUuid": "a083879a_ee3a1cf5",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "467d6623_f42f7905",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 264,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-13T16:22:15Z",
      "side": 1,
      "message": "This can be `auto`, I think.",
      "range": {
        "startLine": 264,
        "startChar": 11,
        "endLine": 264,
        "endChar": 54
      },
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "73646b6b_70907782",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 264,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T08:02:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "467d6623_f42f7905",
      "range": {
        "startLine": 264,
        "startChar": 11,
        "endLine": 264,
        "endChar": 54
      },
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8f631694_e7c577ea",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-13T16:17:04Z",
      "side": 1,
      "message": "Why not just\n\n  static rtc_thread_internal::MessageHandlerWithTask handler;\n\n?",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "650bfcb3_05c308e5",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-13T16:22:15Z",
      "side": 1,
      "message": "Ah, because it has a nontrivial destructor.",
      "parentUuid": "8f631694_e7c577ea",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "264bb51b_8a5c0b12",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T08:02:23Z",
      "side": 1,
      "message": "Exactly. Why it\u0027s \"non-trivial\" isn\u0027t clear to me, maybe because the vtable pointer is supposed to be updated during the destruction sequence? If there\u0027s any reasonable way we could arrange to make constructor and destructor trivial, I\u0027d prefer that.",
      "parentUuid": "650bfcb3_05c308e5",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "6a66990e_5313a8ee",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-05-16T08:49:32Z",
      "side": 1,
      "message": "Basically, a trivial destructor is one that is guaranteed to not to have to execute any instructions. But MessageHandlerWithTask has a virtual destructor, which means that the compiler needs to look up the actual destructor in the vtable and then execute that.\n\nIn theory, the compiler could realize that MessageHandlerWithTask is final and that its destructor (and that of its parent, MessageHandler) are both no-ops, but the standard doesn\u0027t work that way. Since destructor triviality is an observable property, there is a need to mandate exactly when it happens---otherwise, code that assumes triviality would work in one compiler and fail in another.",
      "parentUuid": "264bb51b_8a5c0b12",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3cef2bc7_5605db15",
        "filename": "rtc_base/thread.h",
        "patchSetId": 3
      },
      "lineNbr": 265,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-05-16T08:58:40Z",
      "side": 1,
      "message": "Is there a good reason why an abstract interface, like MessageHandler, needs to implement a destructor at all? If it were declared like\n\n  virtual ~MessageHandler() \u003d 0;\n\nthen it should be pretty clear to the compiler that it can\u0027t generate any code to call it.",
      "parentUuid": "6a66990e_5313a8ee",
      "revId": "99ac84962bf0e8174f9e302a6f02046960bd7765",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}