{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "daae658a_f209330e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-02-20T15:30:21Z",
      "side": 1,
      "message": "This CL propagates the absolute capture time identifier to the decoded image object so it can be exposed in requestVideoFrameCallback API.",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fe37abe7_c35c532d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5117
      },
      "writtenOn": "2024-02-20T16:00:15Z",
      "side": 1,
      "message": "agpalak@ you\u0027ve been adding capture_time_identifier on the send side. Is it normal to put absolute_time on the recieve side there?\n\nLooks pretty weird to me.",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b0db218e_390524c7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8392
      },
      "writtenOn": "2024-02-23T01:06:59Z",
      "side": 1,
      "message": "I think it\u0027s desirable to have the `absolute capture timestamp` on each video frame but there are some problems with how that is defined and how the specs define `VideoFrameCallbackMetadata`\u0027s `captureTime` right now. In particular:\n\n1) `absolute capture timestamp` uses the capture system\u0027s global monotonic clock as reference. `captureTime`, on the other hand, is hinted at using  the receiving system\u0027s global monotonic clock as reference.\n\nIf the requirements in the specs are relaxed and `captureTime` doesn\u0027t use the receiving system\u0027s global monotonic clock as reference, then it becomes meaningless for a caller to ever compare `captureTime` with its adjacent `receiveTime` property in `VideoFrameCallbackMetadata` since they may be based on vastly different epochs.\n\n2) If `absolute capture timestamp` is exposed through an API, then it\u0027s most likely a good idea to also expose its `estimated capture clock offset` sibling. Particularly if the latter is adjusted to include the clock offset between the last sender system and the receiving system.\n\nAlternatively, instead of exposing the `absolute capture timestamp` and `estimated capture clock offset` pairs from the packets, a combined `absolute capture timestamp + estimated capture clock offset` (after adjustment) is exposed. This summed value ends up with the same epoch as `receiveTime` and hence is a suitable substitute for `captureTime` without any changes to the specs.",
      "parentUuid": "daae658a_f209330e",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7c3ba934_ad669440",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-02-26T18:11:01Z",
      "side": 1,
      "message": "for 1) It is not clear to me what which clock is used, you may be right and that could be the meaning fo \"clock synchronization\" in the \"capture time is based on the RTP timestamp of the frame and estimated using clock synchronization\". I will raise an issue in the w3c github repo. If that is the case, i think it would make sense to add a `captureTimestamp` to the vrfc instead which will have consistent naming.\n\nfor 2), yes, I agree that exposing the `estimated capture clock offset`, but I have not seen an appropriate attribute in the videoframe object to include that info. I am not sure about what would be the value of the `absolute capture timestamp + estimated capture clock offset` in case of SFU scenario (Sender-\u003eSFU-\u003eReceiver).\n\nIn that case, the Sender will populate both the `absolute capture timestamp` and the `estimated capture clock offset` if using an external capture clock instead of the Sender system clock. When the header extension is received on the SFU, I don\u0027t expect the SFU to change any of the values of the header extension, hence I am not sure if it would be valid to adjust the `absolute capture timestamp + estimated capture clock offset` based on the SFU clock for the RTCP SR/RR. \n\nGiven said that, I still think that propagating as much metadata from the rtp packets to the decoded frame is usefull, and will not only be applicable not only for the rvfc but also could be used in the insertable streams api and for sure on native development.",
      "parentUuid": "b0db218e_390524c7",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "056886fb_a55adf99",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8392
      },
      "writtenOn": "2024-02-26T19:00:16Z",
      "side": 1,
      "message": "Note that the specs at http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time distinguish between the \"capture system\" (e.g. the original sender with the webcam) and the \"sender system\" (e.g. the last SFU).\n\nEach RTCP-terminating receiver (e.g. SFU) is supposed to add the estimated clock offset between it and its previous hop into `estimated capture clock offset`. This will allow the final receiver to see the full clock offset between itself and the capture system.\n\nIf an RTCP-terminating receiver is unable to make such an update (e.g. not enough information from RTCP SR/RR), then the `estimated capture clock offset` part of the header extension must be omitted. The final receiver will then know that it can\u0027t calculate the full clock offset between itself and the capture system.",
      "parentUuid": "7c3ba934_ad669440",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a0419de_d983eb2b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-02-27T13:34:59Z",
      "side": 1,
      "message": "\u003e  an RTCP-terminating receiver is unable to make such an update (e.g. not enough information from RTCP SR/RR), then the estimated capture clock offset part of the header extension must be omitted. The final receiver will then know that it can\u0027t calculate the full clock offset between itself and the capture system.\n\nI missed that part of the draft, it makes sense.\n\nI am currently using the abs capture time for synchronizing metadata and having accurate frame time info without having to use insertable streams for parsing SEI timing messages on h264, so knowing what was the timestamp at capture time is a must for me. \n\nI also see the value of adding the combined `absolute capture timestamp + estimated capture clock offset`(after adjustment).\n\nMaybe the best proposal would be adding `captureTimestamp` `senderCaptureTimeOffset` to the `VideoFrameCallbackMetadata` and have the `absolute capture timestamp + estimated capture clock offset` be used as `captureTime` in case of uniderectional streams. \n\nMoving forward, this CL only propagates the metadata from the rtp packets to the decoded video frame, using the proper `capture_time_identifier` attribute, which I think should be done regardless of the decision made about the vrfc api.\n\nHow would you feel about continuing the discussion on the vrfc specifics on the github issue?\n\nhttps://github.com/WICG/video-rvfc/issues/86",
      "parentUuid": "056886fb_a55adf99",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4194dfee_90744a2a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2024-02-27T13:54:08Z",
      "side": 1,
      "message": "Worried about no test, but looks simple enough.",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2974a9de_59812513",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 8392
      },
      "writtenOn": "2024-02-27T14:39:50Z",
      "side": 1,
      "message": "I want to stress that even if I think there\u0027s value in exposing `capture timestamp` and `estimated capture clock offset` as separate properties and/or exposing the combined `capture timestamp + estimated capture clock offset` as a single value in `VideoFrameCallbackMetadata.captureTime`, I acknowledge that this will likely involve quite a bit of extra work (and discussions).\n\nI would therefore be happy if we only aim for the smaller change of setting `VideoFrameCallbackMetadata.captureTime \u003d captureTimestamp`. We just have to first change the language at https://wicg.github.io/video-rvfc/#dom-videoframecallbackmetadata-capturetime:\n\n\u003e For video frames coming from a local source, this is the time at which the frame was captured by the camera. For video frames coming from remote source, the capture time is based on the RTP timestamp of the frame and estimated using clock synchronization. This is best effort and can use methods like using RTCP SR as specified in RFC 3550 Section 6.4.1, or by other alternative means if use by RTCP SR isnâ€™t feasible.\n\n... to instead be something like:\n\n\u003e For video frames coming from a local source, this is the time at which the frame was captured by the camera. For video frames coming from a remote source, this is timestamp set by the system that originally captured the frame and with its reference clock being the capture system\u0027s NTP clock (same clock used to generate NTP timestamps for RTCP sender reports on that system).\n\nI\u0027m happy to continue the conversation on GitHub!",
      "parentUuid": "5a0419de_d983eb2b",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "26514151_b5557ffc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2024-03-08T19:01:51Z",
      "side": 1,
      "message": "Trying to ensure Sergio\u0027s getting what he needs for his use case and not something different..",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2776c1b2_c3a89972",
        "filename": "modules/video_coding/generic_decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 20324
      },
      "writtenOn": "2024-02-28T11:58:16Z",
      "side": 1,
      "message": "This capture_time_identifier is not the one that corresponds to the absolute capture timestamp. But instead it\u0027s the one corresponding to the media timestamp. \n\nIt\u0027s exposed in RTCEncodedVideoFrame here: https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/modules/peerconnection/rtc_encoded_video_frame_metadata.idl;l\u003d37;drc\u003df47e96fc819d9a711a0f1076ccf03a7f61bcfe29",
      "range": {
        "startLine": 134,
        "startChar": 19,
        "endLine": 134,
        "endChar": 46
      },
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb967bb7_d0dd0acb",
        "filename": "modules/video_coding/generic_decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-02-28T14:03:18Z",
      "side": 1,
      "message": "Please correct me if I am mistaken, but the  `VideoFrame::capture_time_identifier()` is only set and used currently on the sending/encoding side:\n\nI have been tracking the `RTCEncodedVideoFrame` usae of the capture_time_identifier as presentation timestamp and I have only been able to find that it is set on: third_party/webrtc/modules/rtp_rtcp/source/rtp_sender_video_frame_transformer_delegate.h\n\nCould you point me how/if it is used on the receiver side as well?",
      "parentUuid": "2776c1b2_c3a89972",
      "range": {
        "startLine": 134,
        "startChar": 19,
        "endLine": 134,
        "endChar": 46
      },
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b48ab29f_5d034867",
        "filename": "modules/video_coding/generic_decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 20324
      },
      "writtenOn": "2024-02-29T14:03:51Z",
      "side": 1,
      "message": "Yes, we have not implemented it yet for the receiver side. But the problem here is if we use this CL, the `capture_time_identifier` would mean different things on the encoding and decoding side, which is confusing.",
      "parentUuid": "fb967bb7_d0dd0acb",
      "range": {
        "startLine": 134,
        "startChar": 19,
        "endLine": 134,
        "endChar": 46
      },
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38c88377_e5e49934",
        "filename": "modules/video_coding/generic_decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 5117
      },
      "writtenOn": "2024-02-29T14:11:56Z",
      "side": 1,
      "message": "I think you could reuse ntp_timestamp for this. It\u0027s used exactly for estimated capture timestamp. The estimation is happening here: https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/video/rtp_video_stream_receiver2.cc;l\u003d827;drc\u003df4a00cc248dd2dc8ec8759fb51620d47b5114090\n\nabsolute_capture_time is a newer and more accurate mechanism, so it makes sense that it should overwrite this if available.\nBut make sure that it\u0027s translated into the receiver\u0027s clock first.",
      "parentUuid": "b48ab29f_5d034867",
      "range": {
        "startLine": 134,
        "startChar": 19,
        "endLine": 134,
        "endChar": 46
      },
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "795d88a1_00e01240",
        "filename": "modules/video_coding/generic_decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-03-05T14:10:04Z",
      "side": 1,
      "message": "@agpalak@chromium.org I kind of disagree, the `capture_time_identifier` will always refer to the capture time in the capturer clock. In case of the sending side, it will probably match the sender clock (although in theory the capture time could be retrieved from the camera instead, for example on NDI sources) and in the receiver side it won\u0027t match the local clock.\n\n@ilnik@google.com if the `estimated capture clock offset` of the abs-capture-time is set, we definitively could reuse `ntp_timestamp` after converting to the local receiver clock. However, for my use case the local timestamp is irrelevant as I want to be able to match frames and metadata (sent over datachannel or ws) both using the same capturer clock.",
      "parentUuid": "38c88377_e5e49934",
      "range": {
        "startLine": 134,
        "startChar": 19,
        "endLine": 134,
        "endChar": 46
      },
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f6dd1fd1_380d0948",
        "filename": "modules/video_coding/generic_decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 5634
      },
      "writtenOn": "2024-03-08T19:01:51Z",
      "side": 1,
      "message": "Seems that we need to ensure that the spec APIs are fit for purpose, then .... we need a timestamp that is consistent between something the sender puts into a datachannel (which means relays don\u0027t see it or adjust it) and something that we can extract from the RTP frame (which might be touched by intermediate nodes).\n\nIs it the unadjusted capture timestamp, in the opinion of the original sender, in the sender\u0027s clock, we\u0027re looking to extract here?",
      "parentUuid": "795d88a1_00e01240",
      "range": {
        "startLine": 134,
        "startChar": 19,
        "endLine": 134,
        "endChar": 46
      },
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "438d7eda_95086fe8",
        "filename": "modules/video_coding/generic_decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-03-11T19:34:48Z",
      "side": 1,
      "message": "IMHO, ideally we should try to expose as much metadata as possible, but for my use case, I just need the unadjusted values of the header extensions, as exposed in:\n\nhttps://w3c.github.io/webrtc-extensions/#rtcrtpcontributingsource-attributes\n  DOMHighResTimeStamp captureTimestamp;\n  DOMHighResTimeStamp senderCaptureTimeOffset;\n\nI don\u0027t have an use case for the adjusted times (maybe for showing the glass to glass delay?). I have explained my use case here: \nhttps://github.com/w3c/webrtc-nv-use-cases/issues/130\n\nFor more context, in one of the use cases, I am receiving a H264 stream via SRT containing SEI pic_timing messages with the timestamp of the h264 frame and SCTE35 with splice information adjusted to the same clock for client side ad insertion. \n\nOn the SRT-\u003ewebrtc gateway I am using the SEI pic_timing info and passing it as abs-capture-header extension and propagating the SCTE35 messages via datachannels. \n\nOn the receiver I want to be able to match the datachannel timestamp and the frame captureTimestamp gathered on the rvfc.\n\nNote that this CL does not change the behaviour of the rvfc or the insertable streams/breack out box apis. I just tries to copy some metadata from the rtp packets to the decoded video frame which I thing would be beneficial.",
      "parentUuid": "f6dd1fd1_380d0948",
      "range": {
        "startLine": 134,
        "startChar": 19,
        "endLine": 134,
        "endChar": 46
      },
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "312f585d_d69f0681",
        "filename": "modules/video_coding/generic_decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 134,
      "author": {
        "id": 20324
      },
      "writtenOn": "2024-03-15T10:16:50Z",
      "side": 1,
      "message": "On the sender side, where we fill capture_time_identifier with the value from media::VideoFrame::timestamp(), the value is actually relative to the first frame of the stream and not the absolute capture time. https://source.chromium.org/chromium/chromium/src/+/main:media/base/video_frame.h;l\u003d657;drc\u003dc292340f0c721cd88f9b14c453c877c55d13ce6b",
      "parentUuid": "438d7eda_95086fe8",
      "range": {
        "startLine": 134,
        "startChar": 19,
        "endLine": 134,
        "endChar": 46
      },
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "703543e5_77b678dd",
        "filename": "modules/video_coding/generic_decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 136,
      "author": {
        "id": 5634
      },
      "writtenOn": "2024-02-27T13:54:08Z",
      "side": 1,
      "message": "No test exercises this codepath?",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9ff9eed_69e1d1b9",
        "filename": "modules/video_coding/generic_decoder.cc",
        "patchSetId": 1
      },
      "lineNbr": 136,
      "author": {
        "id": 5963
      },
      "writtenOn": "2024-02-27T14:59:15Z",
      "side": 1,
      "message": "Fair enough, I will add some tests to the generic_decoder_unittest.cc",
      "parentUuid": "703543e5_77b678dd",
      "revId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ],
  "submitRequirementResults": [
    {
      "submitRequirement": {
        "name": "Code-Review",
        "description": {
          "value": "At least one maximum vote for label \u0027Code-Review\u0027 is required"
        },
        "applicabilityExpression": {},
        "submittabilityExpression": {
          "expressionString": "label:Code-Review\u003dMAX,user\u003dnon_uploader AND -label:Code-Review\u003dMIN"
        },
        "overrideExpression": {
          "value": {
            "expressionString": "label:Bot-Commit\u003d+1 AND -label:Code-Review\u003dMIN"
          }
        },
        "allowOverrideInChildProjects": true
      },
      "applicabilityExpressionResult": {},
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"label:Code-Review=MAX,user=non_uploader AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":["label:Code-Review=MAX,user=non_uploader","label:Code-Review=MIN"],"failingAtoms":[]}
      },
      "overrideExpressionResult": {
        "value": {"expression":{"expressionString":"label:Bot-Commit=+1 AND -label:Code-Review=MIN"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":["label:Code-Review=MIN"],"failingAtoms":["label:Bot-Commit=+1"]}
      },
      "patchSetCommitId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    },
    {
      "submitRequirement": {
        "name": "Review-Enforcement",
        "description": {
          "value": "Two Google employees must approve the change. Uploading the change or voting positively on Code-Review count as approval."
        },
        "applicabilityExpression": {
          "value": {
            "expressionString": "is:review-enforced_gerrit"
          }
        },
        "submittabilityExpression": {
          "expressionString": "is:review-enforcement-satisfied_gerrit"
        },
        "overrideExpression": {},
        "allowOverrideInChildProjects": false
      },
      "applicabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforced_gerrit"},"status":"FAIL","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":["is:review-enforced_gerrit"]}
      },
      "submittabilityExpressionResult": {
        "value": {"expression":{"expressionString":"is:review-enforcement-satisfied_gerrit"},"status":"NOT_EVALUATED","errorMessage":{"value":null},"passingAtoms":[],"failingAtoms":[]}
      },
      "overrideExpressionResult": {},
      "patchSetCommitId": "97e0990bbfa19f3c46efcc96a143a6873fef7d7b",
      "legacy": {
        "value": false
      },
      "forced": {},
      "hidden": {}
    }
  ]
}