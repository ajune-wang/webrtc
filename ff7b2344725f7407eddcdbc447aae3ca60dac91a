{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5b6656b7_4caa24c4",
        "filename": "pc/channel.cc",
        "patchSetId": 5
      },
      "lineNbr": 308,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-12-07T23:44:21Z",
      "side": 1,
      "message": "This will be even harder to fix now. Have any ideas? This is currently thread-safe because it\u0027s always called from a network_thread-\u003eInvoke *while on the worker thread*, but there\u0027s no way to enforce that.\n\nI could call a method \"GetRtpDemuxerCriteria\" on the worker thread, and then pass that as an argument to UpdateRtpTransport on the network thread. Though that breaks encapsulation even more.\n\nAnother idea: SetLocalContent/SetRemoteContent could return an std::function\u003cRTCError()\u003e representing the work still remaining to be done on the network thread.",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3132996_466889f5",
        "filename": "pc/channel.cc",
        "patchSetId": 5
      },
      "lineNbr": 308,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-12-08T08:05:03Z",
      "side": 1,
      "message": "The standard solution to this kind of issue is to install a copy on the other thread, but that doesn\u0027t work in this case.\n\nThe complication with demuxer_criteria_ isn\u0027t really the installation, it\u0027s that the criteria are modified based on incoming RTP data when we register non-negotiated tracks, so the data we should start changing when updating isn\u0027t the same data as when we installed it.\nShows what happens when you don\u0027t start off with thread annotations, and people make ad-hoc changes that work \"nearly all the time\".\n\nSuggest to leave in the TODO for now.",
      "parentUuid": "5b6656b7_4caa24c4",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87146a12_d194e49d",
        "filename": "pc/channel.cc",
        "patchSetId": 5
      },
      "lineNbr": 308,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-12-08T22:50:01Z",
      "side": 1,
      "message": "\u003e the criteria are modified based on incoming RTP data when we register non-negotiated tracks\n\nThat happens with the Call-level RtpDemuxer; the criteria here are only modified on the worker thread as a result of SetLocalContent/SetRemoteContent.\n\nThe \"install a copy on the other thread\" solution is basically what I was suggesting. The complication is that SdpOfferAnswerHandler must be involved in this copying; it can\u0027t happen internally without adding an Invoke.",
      "parentUuid": "a3132996_466889f5",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3280615c_63f48f3b",
        "filename": "pc/channel.cc",
        "patchSetId": 5
      },
      "lineNbr": 576,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-12-08T08:05:03Z",
      "side": 1,
      "message": "Apparently AsyncInvoker is not a Good Thing (see https://docs.google.com/document/d/1XM5JnI9ypQA1SSgGXEpmYfpxVmr2E5iTMkqj8J55mCE/edit#heading\u003dh.r0c0dd7omzj8). Can you do this using PostTask?\n\nAlso - I don\u0027t understand what prevents this from being entered again before the task finishes - will that throw things into confusion, or will it Just Work?",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0445d019_182d3b4a",
        "filename": "pc/channel.cc",
        "patchSetId": 5
      },
      "lineNbr": 576,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-12-08T22:50:01Z",
      "side": 1,
      "message": "Using PostTask would also require a WeakPtrFactory; can we get rid of invoker_ altogether in a separate CL?\n\n\u003e I don\u0027t understand what prevents this from being entered again before the task finishes \n\nDo you mean what prevents ChannelWritable_n from being entered again before UpdateMediaSendRecvState_w is called? Well, due to was_ever_writable_n_, the PostTask will only happen once, but even if it didn\u0027t it wouldn\u0027t be an issue.",
      "parentUuid": "3280615c_63f48f3b",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "197951ff_29537d85",
        "filename": "pc/channel.h",
        "patchSetId": 5
      },
      "lineNbr": 143,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-12-08T08:05:03Z",
      "side": 1,
      "message": "Nit: afterwords -\u003e afterwards.",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "663f463e_5425474c",
        "filename": "pc/channel.h",
        "patchSetId": 5
      },
      "lineNbr": 143,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-12-08T22:50:01Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "197951ff_29537d85",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "77b6c467_fbd1470e",
        "filename": "pc/channel.h",
        "patchSetId": 5
      },
      "lineNbr": 372,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-12-08T08:05:03Z",
      "side": 1,
      "message": "Can you add an RTC_GUARDED_BY on this variable?",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd616a64_f55fe8f2",
        "filename": "pc/channel.h",
        "patchSetId": 5
      },
      "lineNbr": 372,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-12-08T22:50:01Z",
      "side": 1,
      "message": "It\u0027s in the same situation as demuxer_criteria_; updated the comment above.",
      "parentUuid": "77b6c467_fbd1470e",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e713cb21_82d2c3f3",
        "filename": "pc/channel_interface.h",
        "patchSetId": 5
      },
      "lineNbr": 56,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-12-08T08:05:03Z",
      "side": 1,
      "message": "Is this ever called from out-of-class? If not, can we make it private and an implementation matter?\nI see that you have calls in the unittests, always with a nullptr arg - can you add an UpdateRtpTransportForTesting method?",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e39fd00_e29a2766",
        "filename": "pc/channel_interface.h",
        "patchSetId": 5
      },
      "lineNbr": 56,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-12-08T22:50:01Z",
      "side": 1,
      "message": "It is called from out-of-class; this is what allows SdpOfferAnswerHandler to perform all the operations that need to occur on the network thread in a single Invoke. If it was called internally, that would mean one Invoke for each BaseChannel.",
      "parentUuid": "e713cb21_82d2c3f3",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "316a6b2a_a24773b7",
        "filename": "pc/sdp_offer_answer.cc",
        "patchSetId": 5
      },
      "lineNbr": 1296,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-12-08T08:05:03Z",
      "side": 1,
      "message": "I don\u0027t think you should have the exact same text in two different TRACE_EVENT0 calls.",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48302257_000ed73b",
        "filename": "pc/sdp_offer_answer.cc",
        "patchSetId": 5
      },
      "lineNbr": 1296,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-12-08T22:50:01Z",
      "side": 1,
      "message": "This was just used for debugging, see latest patch set.",
      "parentUuid": "316a6b2a_a24773b7",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "41e234be_ac5dd46e",
        "filename": "pc/sdp_offer_answer.cc",
        "patchSetId": 5
      },
      "lineNbr": 4230,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-12-08T08:05:03Z",
      "side": 1,
      "message": "any particular reason to use emplace_back rather than push_back?\nemplace_back constructs its argument before copying it in, but when it\u0027s a simple pointer, I don\u0027t think it makes a difference.\n\n(repeat comment for other usages below)",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa635754_0bbc0a23",
        "filename": "pc/sdp_offer_answer.cc",
        "patchSetId": 5
      },
      "lineNbr": 4230,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-12-08T22:50:01Z",
      "side": 1,
      "message": "In this case it\u0027s an std::pair, not just the pointer. Ended up switching to push_back with brazen initialization for convenience though, after switching from pair to a struct.",
      "parentUuid": "41e234be_ac5dd46e",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b702235_a69f1815",
        "filename": "pc/sdp_offer_answer.cc",
        "patchSetId": 5
      },
      "lineNbr": 5030,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-12-08T08:05:03Z",
      "side": 1,
      "message": "Here using emplace_back makes sense, since it\u0027s  complex type being constructed.",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9263d56_fead1685",
        "filename": "pc/sdp_offer_answer.h",
        "patchSetId": 5
      },
      "lineNbr": 467,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-12-07T23:44:21Z",
      "side": 1,
      "message": "If you don\u0027t like passing these vectors of pairs around, I could use std::vector\u003cstd::function\u003cRTCError()\u003e\u003e instead, representing the list of operations to be performed on the worker thread. I like that the more I think about it.",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25c76fc3_c04e8c07",
        "filename": "pc/sdp_offer_answer.h",
        "patchSetId": 5
      },
      "lineNbr": 467,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-12-08T08:05:03Z",
      "side": 1,
      "message": "I think I prefer the current approach - passing a std::function gives the caller the power to do *anything*, while just passing the data gives a particular set of instructions to the callee.",
      "parentUuid": "e9263d56_fead1685",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4ce22da_2bab2612",
        "filename": "pc/sdp_offer_answer.h",
        "patchSetId": 5
      },
      "lineNbr": 564,
      "author": {
        "id": 5634
      },
      "writtenOn": "2020-12-08T08:05:03Z",
      "side": 1,
      "message": "The double template is a bit concerning here. Can you either typedef this or make it a struct?\n\nI\u0027m a bit confused about the bool, though - the idea that you can enable payload type demuxing on some channels and not other channels would seem to only make sense if the channels are on different transports. Is this a flag giving \"payload type demux is OK/ot OK for this channel, please look at all channels for this transport before deciding if it\u0027s allowed\"?",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30d3fdbd_e6077545",
        "filename": "pc/sdp_offer_answer.h",
        "patchSetId": 5
      },
      "lineNbr": 564,
      "author": {
        "id": 5053
      },
      "writtenOn": "2020-12-08T22:50:01Z",
      "side": 1,
      "message": "The way it\u0027s currently coded, you can have payload type demuxing for audio but not video or vice versa since audio and video use distinct payload types.",
      "parentUuid": "b4ce22da_2bab2612",
      "revId": "ff7b2344725f7407eddcdbc447aae3ca60dac91a",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}