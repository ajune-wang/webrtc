{
  "comments": [
    {
      "key": {
        "uuid": "96942ee0_c6378dbb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-10-06T09:03:45Z",
      "side": 1,
      "message": "PTAL. The android failure is a DCHECK\n\n10-06 08:04:18.157  5572  5672 E rtc     : #\n10-06 08:04:18.157  5572  5672 E rtc     : # Fatal error in: ../../modules/video_coding/codecs/vp8/libvpx_vp8_encoder.cc, line 958\n10-06 08:04:18.157  5572  5672 E rtc     : # last system error: 11\n10-06 08:04:18.157  5572  5672 E rtc     : # Check failed: frame.width() \u003d\u003d codec_.width (320 vs. 160)\n10-06 08:04:18.157  5572  5672 E rtc     : # \n\nI think the reason is that when the ToI420 call is postponed, and no longer done in VideoStreamEncoder the crop-and-scale logic in VideoStreamEncoder stops working, see https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/video/video_stream_encoder.cc;drc\u003d895556e19c081ba9a5f0e015f0fe95745d677b55;l\u003d1343.\n\nThis may work better after https://webrtc-review.googlesource.com/c/src/+/186303 is landed and properly integrated with android jni code.",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "36db0950_ee286f9d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-10-06T09:08:31Z",
      "side": 1,
      "message": "This would break scaling logic.\n\nE.g. here:\nhttps://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/video/video_stream_encoder.cc;l\u003d1343;drc\u003d895556e19c081ba9a5f0e015f0fe95745d677b55\n\nThe frame is already converted to I420, because SW encoders don\u0027t support native.\n\nThe same happens in SimulcastEncoderAdater:\nhttps://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/media/engine/simulcast_encoder_adapter.cc;l\u003d425;drc\u003dc5a74ffba49e90a9382c9eb6a795fe7d6abd74a1\n\nTo make this work you need to also copy all scaling logic in to each individual encoder.",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9d144382_11536735",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2020-10-06T09:32:15Z",
      "side": 1,
      "message": "I wouldn\u0027t want scaling logic in encoders, but I was hoping that your cl (linke din previous comment) to add VideoFramebuffer::CropAndScale would let us keep the logic in VideoStreamEncoder, but make it work fine also with kNative.",
      "parentUuid": "36db0950_ee286f9d",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "010cf70a_56cf9fa2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 8683
      },
      "writtenOn": "2020-10-06T09:52:17Z",
      "side": 1,
      "message": "Native frames could implement this in theory I think, returning their underlying data type scaled.",
      "parentUuid": "9d144382_11536735",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "588ecf0f_eaf08b3b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5117
      },
      "writtenOn": "2020-10-06T10:02:36Z",
      "side": 1,
      "message": "Yes, but that can only work if all clients (chrome, android apps) implement it, otherwise the code path would be inefficient, as they will convert to memory I420 meanwhile. Or we have CropAndScale which can sometimes return nullptr\n\nAll in all, \"supports kNative\" should mean \"Pass the frame without touching it at all\". Therefore all the encoders would have to handle scaling/converting themselves.",
      "parentUuid": "010cf70a_56cf9fa2",
      "revId": "47d9b59fd576556a16d67491d302545f8526f6ce",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}