{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9c30ee4e_5bbe28cf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5122
      },
      "writtenOn": "2021-03-01T10:31:50Z",
      "side": 1,
      "message": "Hi Per,\nCould you PTAL?\nAlessio",
      "revId": "b0c887f2fe5169f7bdbf6b9b1da20ce9aa244fea",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2ccfc42b_2cba6663",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5125
      },
      "writtenOn": "2021-03-02T13:53:58Z",
      "side": 1,
      "message": "Thanks for adding this!!!\nlgtm",
      "revId": "b0c887f2fe5169f7bdbf6b9b1da20ce9aa244fea",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5d9949d5_24f8b417",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5122
      },
      "writtenOn": "2021-03-02T15:52:02Z",
      "side": 1,
      "message": "Hi Zhaoliang,\nCould you PTAL?\nAlessio",
      "revId": "b0c887f2fe5169f7bdbf6b9b1da20ce9aa244fea",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "46ecbf65_01df1a13",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 9741
      },
      "writtenOn": "2021-03-03T06:52:34Z",
      "side": 1,
      "message": "Hi Alessio, Thanks for your point of view.\n\nI think in common_audio \u0026 aec3, the avx2 code doesn\u0027t mixed with sse instructions if we can remove the sse intrinsic code from the avx2 file, also these avx2 files would not call other sse functions or libraries, so in my understanding, maybe we don\u0027t need _mm256_zeroupper() in these file if we remove the sse code.\n\nAnd for agc2, IMHO, we don\u0027t need _mm256_zeroupper() if the sse code can be removed and DotProductAvx2 doesn\u0027t call sse functions or libbraries. Otherwise, the avx code is mixed with sse code, so adding calls to `_mm256_zeroupper` is needed.\n\n_mm256_zeroupper can be added if the performance still improved after we remove the sse code in avx2 file. WDYT? Thanks!!!",
      "parentUuid": "5d9949d5_24f8b417",
      "revId": "b0c887f2fe5169f7bdbf6b9b1da20ce9aa244fea",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32404242_ddc20e5b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5122
      },
      "writtenOn": "2021-03-05T15:54:57Z",
      "side": 1,
      "message": "\u003e Hi Alessio, Thanks for your point of view.\n\nThank you for your review!\n\n\u003e \n\u003e I think in common_audio \u0026 aec3, the avx2 code doesn\u0027t mixed with sse instructions \n\nUnfortunately that\u0027s the case: AEC3 uses https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/common_audio/third_party/ooura/fft_size_128/ooura_fft_sse2.cc. It\u0027s also the case for other APM sub-modules and in general I think a defensive approach is needed since WebRTC (Chromium) code outside of APM that uses SSE2 would cost transition penalties anyways.\n\nBTW, I tried to measure the transitions with https://software.intel.com/content/www/us/en/develop/articles/intel-software-development-emulator.html, but unfortunately I cannot setup the OS to correctly run the tool.\n\n\u003e if we can remove the sse intrinsic code from the avx2 file, also these avx2 files would not call other sse functions or libraries, so in my understanding, maybe we don\u0027t need _mm256_zeroupper() in these file if we remove the sse code.\n\nTrue, I will for sure switch to a full AVX2 implementation; that\u0027s a great suggestion; however, the problem remains since AGC2 uses PFFFT which is optimized with SSE2.\n\n\u003e \n\u003e And for agc2, IMHO, we don\u0027t need _mm256_zeroupper() if the sse code can be removed and DotProductAvx2 doesn\u0027t call sse functions or libbraries. Otherwise, the avx code is mixed with sse code, so adding calls to `_mm256_zeroupper` is needed.\n\u003e \n\u003e _mm256_zeroupper can be added if the performance still improved after we remove the sse code in avx2 file. WDYT? Thanks!!!\n\nI sent on this CL without benchmarking, but as soon as I have time and suitable hardware I will try again with the SDE tool and I will also benchmark.",
      "parentUuid": "46ecbf65_01df1a13",
      "revId": "b0c887f2fe5169f7bdbf6b9b1da20ce9aa244fea",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "96152b30_e2b1f483",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5122
      },
      "writtenOn": "2021-03-05T15:54:57Z",
      "side": 1,
      "message": "Hi Zhaoliang,\nThanks a lot for your input.\nI have replied.\nAlessio",
      "revId": "b0c887f2fe5169f7bdbf6b9b1da20ce9aa244fea",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "04b7eadf_e3283f5d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 9741
      },
      "writtenOn": "2021-03-30T02:24:40Z",
      "side": 1,
      "message": "Alessio, I am really sorry for the delay.",
      "parentUuid": "96152b30_e2b1f483",
      "revId": "b0c887f2fe5169f7bdbf6b9b1da20ce9aa244fea",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "75499622_e8fd3f4a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 9741
      },
      "writtenOn": "2021-03-30T02:24:40Z",
      "side": 1,
      "message": "I\u0027m sorry I misunderstood that, when the  cflags (-mavx2, -mfma) are used the compiler will automatically generate VEX-encoded instructions rather than legacy Intel® SSE instructions where appropriate, which removes the transition between Intel® AVX and Intel® SSE within those files. So we don\u0027t need to switch to a full AVX2 implementation...\nI am not sure if there are really a lot of transition penalties, do you have some data? maybe I can try to use VTune to analysis the transition.",
      "parentUuid": "32404242_ddc20e5b",
      "revId": "b0c887f2fe5169f7bdbf6b9b1da20ce9aa244fea",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2e268df_2b204ffd",
        "filename": "modules/audio_processing/agc2/rnn_vad/vector_math_avx2.cc",
        "patchSetId": 2
      },
      "lineNbr": 45,
      "author": {
        "id": 9741
      },
      "writtenOn": "2021-03-03T06:52:34Z",
      "side": 1,
      "message": "Can we convert these sse intrinsic code to avx2?",
      "range": {
        "startLine": 38,
        "startChar": 2,
        "endLine": 45,
        "endChar": 41
      },
      "revId": "b0c887f2fe5169f7bdbf6b9b1da20ce9aa244fea",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}