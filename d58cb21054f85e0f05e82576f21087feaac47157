{
  "comments": [
    {
      "key": {
        "uuid": "c2e9f6a3_661a2846",
        "filename": "modules/audio_coding/codecs/opus/audio_encoder_opus.cc",
        "patchSetId": 1
      },
      "lineNbr": 662,
      "author": {
        "id": 12214
      },
      "writtenOn": "2020-06-04T20:00:03Z",
      "side": 1,
      "message": "this is needed for RED things where the offset *may* be non-zero.",
      "revId": "d58cb21054f85e0f05e82576f21087feaac47157",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ada17a2b_2220665b",
        "filename": "modules/audio_coding/codecs/opus/audio_encoder_opus.cc",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 6876
      },
      "writtenOn": "2020-06-05T08:33:27Z",
      "side": 1,
      "message": "This would work for the case when the configuration bits in the TOC byte is equal to 0 meaning that there is just one frame in the packet (section 3.1 rfc6716). \nWhen you have more than one frame per packet this byte might not point out to the beginning of the Silk payload. Specifically, for configuration 2 and 3, that byte does not corresponds with the beginning of the Silk payload. Furthermore, when there are more than one frame in the Opus payload we might want to take a join decision for the VAD flag, for example, equal to speech if any of the frames have activity. \nIt would also be nice to include the option when more than 1 Silk frame has been coded in the frame. For example, the Silk payload could contain 2 subframes of 20 ms each and that bit would just give information of the first frame. You have here, https://source.chromium.org/chromium/chromium/src/+/master:third_party/opus/src/silk/dec_API.c;drc\u003d4481cd115f2c232c7d01a17898b5c6a62a21a2f8;l\u003d389?originalUrl\u003dhttps:%2F%2Fcs.chromium.org%2F and example on how can be done for extracting the VAD information of each individual SILK subframe. And the TOC byte gives us the number of Silk frames in the Silk payload.\n\nIn summary, I think that your code works fine for the configurations on the TOC byte equal to 0 and 1. However, for the configuration equal to 1 is not taking into account all the frames in the payload. This current version would fail for the configuration 2 and 3. \n\nIn spite of the details that I just wrote, I think that this change is moving in the right direction for getting a more reliable VAD flag.",
      "range": {
        "startLine": 704,
        "startChar": 5,
        "endLine": 704,
        "endChar": 70
      },
      "revId": "d58cb21054f85e0f05e82576f21087feaac47157",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e54577e4_a3ce2e66",
        "filename": "modules/audio_coding/codecs/opus/audio_encoder_opus.cc",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 12214
      },
      "writtenOn": "2020-06-05T09:02:55Z",
      "side": 1,
      "message": "in those cases, won\u0027t https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/modules/audio_coding/codecs/opus/opus_interface.cc;l\u003d734?q\u003dwebrtc_opus_\u0026ss\u003dchromium\u0026originalUrl\u003dhttps:%2F%2Fcs.chromium.org%2F be wrong too?\n\nIn configuration 2+3 is the first frame guaranteed to be a SILK frame? If yes this would extract from it and we\u0027d get *some* information out of it and we could take the VAD bits for the other channels into account too.\nIf not we might try limiting this to the SILK-only modes 0-11 but I think i\u0027ve seen webrtc switch into the hybrid modes quite often.\n\nI don\u0027t think we have a good way to extract the position of the second frame (other than parsing the bitstream which I\u0027d rather not) so if the first frame is not a SILK frame getting access to the first byte of the SILK layer would be quite tricky.",
      "parentUuid": "ada17a2b_2220665b",
      "range": {
        "startLine": 704,
        "startChar": 5,
        "endLine": 704,
        "endChar": 70
      },
      "revId": "d58cb21054f85e0f05e82576f21087feaac47157",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72180a87_3ca307f6",
        "filename": "modules/audio_coding/codecs/opus/audio_encoder_opus.cc",
        "patchSetId": 1
      },
      "lineNbr": 704,
      "author": {
        "id": 6876
      },
      "writtenOn": "2020-06-05T12:00:09Z",
      "side": 1,
      "message": "that frame_data in https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/modules/audio_coding/codecs/opus/opus_interface.cc;l\u003d734?q\u003dwebrtc_opus_\u0026ss\u003dchromium\u0026originalUrl\u003dhttps:%2F%2Fcs.chromium.org%2F seems to be the beginning of the opus frames after the headers (TOC byte plus extra bytes for the configs 2 and 3). \n\nI was actually not aware of that opus_packet_parse function (https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/modules/audio_coding/codecs/opus/opus_interface.cc;drc\u003d422f9dd5df8e70ecca1e0aff83b0e2e114bc70aa;l\u003d699?originalUrl\u003dhttps:%2F%2Fcs.chromium.org%2F), that function seems to give you all the information that you need as it seems to divide the opus payload in individual frames. The first byte of those frames would be the first byte on the Silk payload. In a similar way as done in the function WebRtcOpus_PacketHasFec you can get the number of Silk frames in the Silk payload. Once you know the number of Silk frames in the payload the vad flag can be something like, \nint vad_flags \u003d first_byte \u003e\u003e (8 - numberSilkFrames);\nbool speech \u003d vad_flags !\u003d 0;\n\n\nAnother option is that we limit your code to the configs that are guarantee to work like you suggested.",
      "parentUuid": "e54577e4_a3ce2e66",
      "range": {
        "startLine": 704,
        "startChar": 5,
        "endLine": 704,
        "endChar": 70
      },
      "revId": "d58cb21054f85e0f05e82576f21087feaac47157",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}