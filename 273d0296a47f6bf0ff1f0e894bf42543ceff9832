{
  "comments": [
    {
      "key": {
        "uuid": "6e87245f_ef4c9c47",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-11-06T10:37:02Z",
      "side": 1,
      "message": "I\u0027m not sure I agree... I think the api convention should be that callbacks like OnData are expected to return quickly, and that a callee that needs to do a lot of processing or take lots of locks should be responsible for posting to some worker thread or task queue.",
      "range": {
        "startLine": 12,
        "startChar": 1,
        "endLine": 14,
        "endChar": 65
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5e810a59_984188f4",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-11-06T10:37:02Z",
      "side": 1,
      "message": "And if you really think asynchronous callbacks are desirable, I\u0027d strongly prefer using a TaskQueue (owned by the MediaTransportPair if you\u0027re willing to share it between the two directions, otherwise each LoopbackMediaTransport can have its own).",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 147,
        "endChar": 31
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5e4261c_5cbcfce1",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 7704
      },
      "writtenOn": "2018-11-06T15:36:46Z",
      "side": 1,
      "message": "1) Can you explain why?\n2) Is there a way to drain a TaskQueue, or do you need to depend on weak pointers when destroying the object?",
      "parentUuid": "5e810a59_984188f4",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 147,
        "endChar": 31
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa159c31_56300c6b",
        "filename": "api/test/loopback_media_transport.h",
        "patchSetId": 4
      },
      "lineNbr": 147,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-11-06T15:51:12Z",
      "side": 1,
      "message": "\u003e 1) Can you explain why?\n\nBecause TQ is generally preferred for new code, and because AsyncInvoker is a hairy and brittle piece of code that I\u0027d like to move away from...\n\n\u003e 2) Is there a way to drain a TaskQueue, or do you need to depend on weak pointers when destroying the object?\n\nThe standard trick for test code is to post a task that sets an event, and wait for that event. Then you know that all tasks posted prior (and not posted using PostDelayedTask) have completed.\n\nWe also use the same trick in production code in a few places, but that\u0027s not so nice.\n\nDestroying a task queue will destroy pending tasks without running them, and block until any currently running task is completed. I think the weak pointers are intended for the case that *other* objects might be destroyed while the task queue and its tasks still are alive; they\u0027re an abstraction adopted from chromium, and so far haven\u0027t been that useful. You probably don\u0027t need any.",
      "parentUuid": "e5e4261c_5cbcfce1",
      "range": {
        "startLine": 147,
        "startChar": 0,
        "endLine": 147,
        "endChar": 31
      },
      "revId": "273d0296a47f6bf0ff1f0e894bf42543ceff9832",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}