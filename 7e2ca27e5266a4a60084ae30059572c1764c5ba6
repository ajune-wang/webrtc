{
  "comments": [
    {
      "key": {
        "uuid": "982816f3_62d42e3c",
        "filename": "modules/congestion_controller/rtp/include/send_side_congestion_controller.h",
        "patchSetId": 14
      },
      "lineNbr": 180,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-03-07T08:34:13Z",
      "side": 1,
      "message": "I think these two should be a single variable. It should be written only on the task queue, but may be read by other threads (with the pretty weak synchronization provided by std::atomic). Not sure if there are any thread annotation to use for that. Usage requirements are similar to read-copy-update (any one can do lockless reads, but writes require synchronization).",
      "range": {
        "startLine": 179,
        "startChar": 0,
        "endLine": 180,
        "endChar": 54
      },
      "revId": "7e2ca27e5266a4a60084ae30059572c1764c5ba6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c674a7a4_c9cc7af6",
        "filename": "modules/congestion_controller/rtp/send_side_congestion_controller.cc",
        "patchSetId": 14
      },
      "lineNbr": 429,
      "author": {
        "id": 5234
      },
      "writtenOn": "2018-03-07T08:34:13Z",
      "side": 1,
      "message": "This seems to be the only use if this flag, and it looks like it caches \"network up\" state.\n\nWhy can\u0027t we query the pacer unconditionally? Since there\u0027s no real synchronization, we may well call the pacer just after network_available_synced becomes false. If that isn\u0027t dangerous, why not do that always?",
      "range": {
        "startLine": 429,
        "startChar": 9,
        "endLine": 429,
        "endChar": 34
      },
      "revId": "7e2ca27e5266a4a60084ae30059572c1764c5ba6",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}