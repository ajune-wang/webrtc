{
  "comments": [
    {
      "key": {
        "uuid": "4b412bf6_06577a8c",
        "filename": "rtc_base/thread.cc",
        "patchSetId": 6
      },
      "lineNbr": 895,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-06-29T13:00:17Z",
      "side": 1,
      "message": "Is this the right place to be checking?  I would expect the policy to be applied on the thread that is being blocked.\n\nI.e. here:\n\nauto* current \u003d Thread::Current();\nauto* other_thread \u003d SomeOtherThread();\nother_thread-\u003eInvoke(...);  \u003c--- Here, we should check the policy for |current|\n\n\nSo, in my mind, I\u0027m more concerned about the thread that ends up being blocked, and less concerned about whether or not the thread that does the work knows if the work is being waited on.",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7de1af5b_5e57e7f7",
        "filename": "rtc_base/thread.cc",
        "patchSetId": 6
      },
      "lineNbr": 895,
      "author": {
        "id": 6337
      },
      "writtenOn": "2020-06-29T14:09:38Z",
      "side": 1,
      "message": "IIUC what you said is similar to what is done here. |current_thread| is the one, which is executed and will be blocked and |this| is the thread where to which we are going to send a request.",
      "parentUuid": "4b412bf6_06577a8c",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c441f1c9_8fcfaf11",
        "filename": "rtc_base/thread.h",
        "patchSetId": 6
      },
      "lineNbr": 344,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-06-29T13:00:17Z",
      "side": 1,
      "message": "move implementations to the .cc file",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e97ee2ce_25f7ffc0",
        "filename": "rtc_base/thread.h",
        "patchSetId": 6
      },
      "lineNbr": 344,
      "author": {
        "id": 6337
      },
      "writtenOn": "2020-06-29T14:09:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c441f1c9_8fcfaf11",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "345b2951_56524638",
        "filename": "rtc_base/thread.h",
        "patchSetId": 6
      },
      "lineNbr": 346,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-06-29T13:00:17Z",
      "side": 1,
      "message": "instead of locking, can we require that the policy be set on the thread itself? If not on the thread, we can just post a task.\n\nI\u0027m thinking that modifying the policy will be very rare, but checking the policy will be very frequent, so not needing a lock for that case would be better.",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aaca2de4_1b722b44",
        "filename": "rtc_base/thread.h",
        "patchSetId": 6
      },
      "lineNbr": 346,
      "author": {
        "id": 6337
      },
      "writtenOn": "2020-06-29T14:09:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "345b2951_56524638",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3a5c440d_6dfd185f",
        "filename": "rtc_base/thread.h",
        "patchSetId": 6
      },
      "lineNbr": 360,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-06-29T13:00:17Z",
      "side": 1,
      "message": "do we need this?",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "16329e9d_5932b15e",
        "filename": "rtc_base/thread.h",
        "patchSetId": 6
      },
      "lineNbr": 360,
      "author": {
        "id": 6337
      },
      "writtenOn": "2020-06-29T14:09:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3a5c440d_6dfd185f",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "825be526_1c6158e2",
        "filename": "rtc_base/thread.h",
        "patchSetId": 6
      },
      "lineNbr": 611,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-06-29T13:00:17Z",
      "side": 1,
      "message": "any reason for choosing a std::set? It\u0027s a rather high cost container for something that\u0027ll just contain one or two items. std::vector should do I think.",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "399955dd_718a5d14",
        "filename": "rtc_base/thread.h",
        "patchSetId": 6
      },
      "lineNbr": 611,
      "author": {
        "id": 6337
      },
      "writtenOn": "2020-06-29T14:09:38Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "825be526_1c6158e2",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "97f7a374_576d9817",
        "filename": "rtc_base/thread.h",
        "patchSetId": 6
      },
      "lineNbr": 612,
      "author": {
        "id": 5508
      },
      "writtenOn": "2020-06-29T13:00:17Z",
      "side": 1,
      "message": "same as !allowed_thread_.empty()?",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "570db36f_df008da7",
        "filename": "rtc_base/thread.h",
        "patchSetId": 6
      },
      "lineNbr": 612,
      "author": {
        "id": 6337
      },
      "writtenOn": "2020-06-29T14:09:38Z",
      "side": 1,
      "message": "We need to distinguish 2 cases:\n1. No policies set, then we need do default allow, because downstream projects won\u0027t have any policy set and we don\u0027t want to break them\n2. Explicit disallow to any thread policy is set.\n\nSo when |allowed_threads_| is empty and |invoke_policy_enabled_| is true it means explicit disallow is set, otherwise if |invoke_policy_enabled_| is false, then it means that no policies were applied to this thread and we need allow always.",
      "parentUuid": "97f7a374_576d9817",
      "revId": "b9eecb2f0f2173da221886e009b67844040be31b",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}