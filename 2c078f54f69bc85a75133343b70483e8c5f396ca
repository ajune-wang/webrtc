{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "832d12cf_043bad40",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-22T05:59:50Z",
      "side": 1,
      "message": "I\u0027d like your commentary on the new API async_dns_resolver.h before I commit the time to use that interface internally in WebRTC.\n",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e76496d_5f78eb2c",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 26,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-03-22T07:39:31Z",
      "side": 1,
      "message": "Can you add documentation that explains in what context |callback| will run?\n(same thread/task queue as issued the call to Start?)\n\nAlso explain what implementations of callback are expected to do.",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6f352fe4_67427095",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 26,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-22T08:15:43Z",
      "side": 1,
      "message": "Added a documentation example.\nAn interim design criterion for this class is that it should be able to wrap the existing functionality so that we don\u0027t have to replace the Chromium implementation at the same time.",
      "parentUuid": "7e76496d_5f78eb2c",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff11582f_bb2d85e7",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-03-22T07:39:31Z",
      "side": 1,
      "message": "This implies that the AsyncDnsResolverInterface implementation will own and hold state that it needs to protect against potential misuse, which likely means some sort of synchronization, and I\u0027m wondering if we can avoid that.\n\nGetResolvedAddress doesn\u0027t specify what context is OK to call it from. If the context is \u0027any\u0027, then that could force implementations to use locks. If it needs to be the same context as calls Start(), then we still need to make sure to handle the case when it\u0027s called while Start() is in progress.\n\nHow about reporting the results via callback() instead?",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4ad098e5_9d2fed20",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-22T08:15:43Z",
      "side": 1,
      "message": "As I read it, it\u0027s actually single-threaded.\n\nThe old implementation will post to the internal thread to resolve the address, and then post back the result (with a std::move) to the original thread. So this was a monothread class; I don\u0027t see a reason to depart from that",
      "parentUuid": "ff11582f_bb2d85e7",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d8a63405_3701a47b",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-03-23T10:41:18Z",
      "side": 1,
      "message": "I think it is poor practice to capture current thread with rtc::Thread::Current() and then post tasks to it. If the callback is supposed to be called on a particular thread, it\u0027s cleaner to pass that as an explicit argument to the factory. But as I\u0027ve said, my own preference would be to allow the callback from any internal thread in the resolver, and leave to the callback itself to post to any thread of its choice (or use locks, if that\u0027s for some reason preferred in some context).\n\nRequiring incoming methods calls to all be on the same thread make sense.",
      "parentUuid": "4ad098e5_9d2fed20",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fe4629aa_a223d2d7",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-23T11:38:01Z",
      "side": 1,
      "message": "Ensuring all callers are OK with being called back on a different thread when they are \"used to\" being called on the same thread seems a bit complex to me.",
      "parentUuid": "d8a63405_3701a47b",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5361991d_64eb7823",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-03-23T11:47:38Z",
      "side": 1,
      "message": "I have a very vague picture of the transition. Maybe callers could be fixed as they are transitioned to use the new interface? Ideally, that would just be an additional PostTask or similar in the provided callback.",
      "parentUuid": "fe4629aa_a223d2d7",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "643766ba_7867ab09",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 33,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-23T12:50:08Z",
      "side": 1,
      "message": "Yes, it\u0027s more code at every callsite. As a rule I don\u0027t like code repetition - and calling the callback on the resolver thread exposes the resolver thread to the outside world, something I also don\u0027t see an advantage of.\n\nIf it\u0027s always the right thing to jump back to the thread that called the interface, forcing all users to code this for themselves has no advantage that I can see. (And control has to get back there in order to delete the object too.)\n\nI can see the general principle (don\u0027t jump until you know where you should jump, and the callee knows better than the caller), but I don\u0027t think I agree with applying it in this instance.",
      "parentUuid": "5361991d_64eb7823",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1474b95b_6b27a037",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-03-22T07:39:31Z",
      "side": 1,
      "message": "Given that there\u0027s a requirement to call Stop() before deleting and also the requirement of holding state in the AsyncDnsResolverInterface implementation, I\u0027m wondering if we can avoid that altogether and have a single method in the interface:\n\nclass AsyncDnsResolverInterface {\n public:\n  // Deleting the resolver before Resolve() completes, will cancel\n  // the operation.\n  // Construction/deletion and Resolve() must all occur in the same\n  // execution context. The callback will be issued in that same\n  // execution context.\n  virtual ~AsyncDnsResolverInterface() \u003d 0;\n\n  // Here we\u0027d have a std::function based definition of a function\n  // that accepts (and owns) the results of the resolution. \n  typedef Callback;\n\n  virtual void Resolve(rtc::SocketAddress addr,\n                       Callback callback) \u003d 0\n};",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82170db2_13df7ff8",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 38,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-22T08:15:43Z",
      "side": 1,
      "message": "My preferred interface would be:\n\nclass AsyncDnsResolverFactory {\n  public:\n    std::unique_ptr\u003cAsyncResolver\u003e Create(Address, callback);\n}\n\nclass AsyncDnsResolver {\n  bool done();\n}\n\nwhere callback returns the address.\nBut that\u0027s a bigger redesign than the proposal.",
      "parentUuid": "1474b95b_6b27a037",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e0b2ba2d_6db75530",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 48,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-03-22T07:39:31Z",
      "side": 1,
      "message": "s/Destroy/Stop ?",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4507e92f_58ba7b39",
        "filename": "api/async_dns_resolver.h",
        "patchSetId": 2
      },
      "lineNbr": 48,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-03-22T08:15:43Z",
      "side": 1,
      "message": "Removed comment. It\u0027s repeated on the Stop() method above.",
      "parentUuid": "e0b2ba2d_6db75530",
      "revId": "2c078f54f69bc85a75133343b70483e8c5f396ca",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}