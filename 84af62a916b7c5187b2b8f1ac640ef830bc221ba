{
  "comments": [
    {
      "key": {
        "uuid": "55a99e37_e83f9614",
        "filename": "api/video/encoded_image.cc",
        "patchSetId": 6
      },
      "lineNbr": 20,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-06-14T11:03:56Z",
      "side": 1,
      "message": "We don\u0027t generally even dcheck for OOM. It happens rarely, and we get a reasonably clean crash when trying to deref nullptr.",
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1150e930_0a499e04",
        "filename": "api/video/encoded_image.cc",
        "patchSetId": 6
      },
      "lineNbr": 20,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-14T11:45:04Z",
      "side": 1,
      "message": "Ok, deleted. That\u0027s a very strange convention to me, though. And I\u0027m not sure what happens if allocation for C++ new fails, with our configuration? Will it return null (and crash later, on first access), or crash immediately with an error message?",
      "parentUuid": "55a99e37_e83f9614",
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "211e4fea_09f75ced",
        "filename": "api/video/encoded_image.h",
        "patchSetId": 6
      },
      "lineNbr": 37,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-06-14T11:03:56Z",
      "side": 1,
      "message": "Shouldn\u0027t this be RefCountedInterface? Otherwise this interface won\u0027t be pure or even stateless.",
      "range": {
        "startLine": 37,
        "startChar": 43,
        "endLine": 37,
        "endChar": 62
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e12b9438_e8bd9111",
        "filename": "api/video/encoded_image.h",
        "patchSetId": 6
      },
      "lineNbr": 37,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-14T11:45:04Z",
      "side": 1,
      "message": "Maybe. I thought it would be simpler this way; as I\u0027ve understood it, the point of RefCountedInterface is to allow a concrete class to implement multiple refcounted interfaces and add refcount at the bottom of the inheritance tree. Which shouldn\u0027t be an issue here. \n\nBut I\u0027ve changed to RefCountInterface; that is more consistent with the VideoFrameBuffer interface.",
      "parentUuid": "211e4fea_09f75ced",
      "range": {
        "startLine": 37,
        "startChar": 43,
        "endLine": 37,
        "endChar": 62
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "35258d2b_d164e1fe",
        "filename": "api/video/encoded_image.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 5126
      },
      "writtenOn": "2019-06-14T11:03:56Z",
      "side": 1,
      "message": "No.",
      "range": {
        "startLine": 50,
        "startChar": 56,
        "endLine": 50,
        "endChar": 75
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "64103f71_c397705b",
        "filename": "api/video/encoded_image.h",
        "patchSetId": 6
      },
      "lineNbr": 50,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-14T11:45:04Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "35258d2b_d164e1fe",
      "range": {
        "startLine": 50,
        "startChar": 56,
        "endLine": 50,
        "endChar": 75
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0e926fb6_47c82865",
        "filename": "sdk/android/src/jni/android_media_encoder.cc",
        "patchSetId": 6
      },
      "lineNbr": 99,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-11T11:19:20Z",
      "side": 1,
      "message": "If I\u0027ve understood this correctly, AndroidMediaDecoder is the old way of doing hardware encoding on android. The new way is VideoEncoderWrapper, and in this case, releaseOutputBuffer is called on the java side, here: https://cs.chromium.org/chromium/src/third_party/webrtc/sdk/android/src/java/org/webrtc/HardwareVideoEncoder.java?q\u003dHardwareVideoEncoder\u0026sq\u003dpackage:chromium\u0026dr\u003dCSs\u0026l\u003d537\n\nI\u0027d like to do a followup cl to delete this memcpy: https://cs.chromium.org/chromium/src/third_party/webrtc/sdk/android/src/jni/video_encoder_wrapper.cc?l\u003d230. But to do that, control of releaseOutputBuffer must be given to the C++ code, possibly as a method on the java class EncodedImage. \n\nSami, do you think that is feasible, and do you have any advice?",
      "range": {
        "startLine": 99,
        "startChar": 1,
        "endLine": 99,
        "endChar": 69
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1b2c0679_f4182f60",
        "filename": "sdk/android/src/jni/android_media_encoder.cc",
        "patchSetId": 6
      },
      "lineNbr": 99,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-12T11:20:15Z",
      "side": 1,
      "message": "I think we need to:\n1. Add a way to add a release callback to EncodedImage interface / add reference counting\n2. Update all encoders to allow holding the buffer while the reference is alive\n3. Update wrapper to remove the memcpy",
      "parentUuid": "0e926fb6_47c82865",
      "range": {
        "startLine": 99,
        "startChar": 1,
        "endLine": 99,
        "endChar": 69
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "68339696_8164c9a9",
        "filename": "sdk/android/src/jni/android_media_encoder.cc",
        "patchSetId": 6
      },
      "lineNbr": 99,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-12T11:38:30Z",
      "side": 1,
      "message": "This cl tries to do (1). EncodedImage holds a scoped_refptr\u003cEncodedImageBufferInterface\u003e. My question is how to implement that interface to get an object representing what\u0027s passed to VideoEncoderWrapper::OnEncodedFrame from java.\n\nI\u0027d like to do something similar to the JavaEncodedImageBuffer class here, which invokes the java releaseOutputBuffer on destruction. It\u0027s just that I don\u0027t see any way to do that in VideoEncoderWrapper, without also doing some changes on the java side.\n\nWe\u0027d need some kind of release callback passed from java to C++, and invoked from the appropriate C++ destructor. Hmm, what is the |j_caller| argument to VideoEncoderWrapper::OnEncodedFrame? It\u0027s currently unused.",
      "parentUuid": "1b2c0679_f4182f60",
      "range": {
        "startLine": 99,
        "startChar": 1,
        "endLine": 99,
        "endChar": 69
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce1cb509_9ce3d3c0",
        "filename": "sdk/android/src/jni/android_media_encoder.cc",
        "patchSetId": 6
      },
      "lineNbr": 99,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-12T11:49:01Z",
      "side": 1,
      "message": "By (1) I meant doing the necessary changes on the Java side. And by (2) updating the encoder code on the Java side also.\n\nj_caller is the object that the method is called on. (Think this pointer but Java object.)\n\nI think here instead of doing any specific logic for releasing a specific buffer, it should just trigger a callback attached to the Java EncodedImage object that can do the correct cleanup on the Java side. This should be introduced in step 1.\n\nThe logic in JavaEncodedImageBuffer should similar to AndroidVideoBuffer:\nhttps://cs.chromium.org/chromium/src/third_party/webrtc/sdk/android/src/jni/video_frame.h?type\u003dcs\u0026q\u003dAndroidVideoBuffer\u0026sq\u003dpackage:chromium\u0026g\u003d0\u0026l\u003d56",
      "parentUuid": "68339696_8164c9a9",
      "range": {
        "startLine": 99,
        "startChar": 1,
        "endLine": 99,
        "endChar": 69
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1bd3ac03_7cef4858",
        "filename": "sdk/android/src/jni/android_media_encoder.cc",
        "patchSetId": 6
      },
      "lineNbr": 99,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-12T12:22:28Z",
      "side": 1,
      "message": "Call to nativeOnEncodedFrame is here: https://cs.chromium.org/chromium/src/third_party/webrtc/sdk/android/src/java/org/webrtc/VideoEncoderWrapper.java?q\u003dcreateEncoderCallback\u0026sq\u003dpackage:chromium\u0026dr\u003dCSs\u0026l\u003d40, which unpacks the java EncodedImage and passes relevant attributes to C++. Should this be changed to pass the complete EncodedImage? Or should the release callback be a separate argument, and if so, of what type?\n\nIt\u0027s the border between java and C++ I find most difficult. I\u0027ll see if I can move the releaseOutputBuffer thing to a callback on the java side.",
      "parentUuid": "ce1cb509_9ce3d3c0",
      "range": {
        "startLine": 99,
        "startChar": 1,
        "endLine": 99,
        "endChar": 69
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e188be25_61b1e31f",
        "filename": "sdk/android/src/jni/android_media_encoder.cc",
        "patchSetId": 6
      },
      "lineNbr": 99,
      "author": {
        "id": 5112
      },
      "writtenOn": "2019-06-12T12:38:55Z",
      "side": 1,
      "message": "I would expect the release callback to just be a runnable. And yes, I think passing the whole instance is the correct approach. Then you can simply call retain/release on this instance.",
      "parentUuid": "1bd3ac03_7cef4858",
      "range": {
        "startLine": 99,
        "startChar": 1,
        "endLine": 99,
        "endChar": 69
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8a5a1ef_090d137a",
        "filename": "sdk/android/src/jni/android_media_encoder.cc",
        "patchSetId": 6
      },
      "lineNbr": 99,
      "author": {
        "id": 5234
      },
      "writtenOn": "2019-06-13T09:37:59Z",
      "side": 1,
      "message": "First java/jni cl here: https://webrtc-review.googlesource.com/c/src/+/141861",
      "parentUuid": "e188be25_61b1e31f",
      "range": {
        "startLine": 99,
        "startChar": 1,
        "endLine": 99,
        "endChar": 69
      },
      "revId": "84af62a916b7c5187b2b8f1ac640ef830bc221ba",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": false
    }
  ]
}