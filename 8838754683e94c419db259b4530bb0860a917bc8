{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a310e5c4_8c2262aa",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-11-01T11:07:58Z",
      "side": 1,
      "message": "Nit: unsued -\u003e unused",
      "revId": "8838754683e94c419db259b4530bb0860a917bc8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "933a581c_05aac17f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-11-01T11:14:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a310e5c4_8c2262aa",
      "revId": "8838754683e94c419db259b4530bb0860a917bc8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "adb2a961_cd3e92e3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-10-29T08:22:07Z",
      "side": 1,
      "message": "This gets a bit inconsistent with tcp client sockets, where BasicPacketSocketFactory sets OPT_NODELAY on the underlying rtc::Socket, before wrapping in in one of many possible ways in other classes.\n\nA possible later refactoring might be to let BasicPacketSocket factory somwhow be responsible for listening on the socket and move its wrapping to the accept path, but that\u0027s for after (if ever) we get an rtc::ListenSocket class, separate from rtc::Socket (I have a wip branch for that).",
      "revId": "8838754683e94c419db259b4530bb0860a917bc8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "77e4ae36_658eaf60",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-11-01T11:07:58Z",
      "side": 1,
      "message": "Where\u0027s the test that shows that the options are applied to incoming sockets?\nI\u0027m somewhat at a loss to see how these options got applied in the right place before this CL. Is it changing behavior?\n",
      "revId": "8838754683e94c419db259b4530bb0860a917bc8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89bf8bf8_d5f99ffb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-11-01T11:14:03Z",
      "side": 1,
      "message": "As far as I can tell, options weren\u0027t applied to incoming sockets, so this is a bug fix, not just a refactoring. There were no tests, I could look into adding one.",
      "parentUuid": "77e4ae36_658eaf60",
      "revId": "8838754683e94c419db259b4530bb0860a917bc8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cb8bf40_bb082c69",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-11-01T11:23:03Z",
      "side": 1,
      "message": "I would be happy to see a test. (Always nice to see a test that fails before the fix and succeeds afterwards - gives assurance that the change in behavior is properly understood.)",
      "parentUuid": "89bf8bf8_d5f99ffb",
      "revId": "8838754683e94c419db259b4530bb0860a917bc8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7cd7b1f4_d4f75475",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5234
      },
      "writtenOn": "2021-11-01T14:29:00Z",
      "side": 1,
      "message": "Any advice on how to extend the PostTest.TestTcpNoDelay, at https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/p2p/base/port_unittest.cc;drc\u003dd30ece1804dc91e84850cf07100c27a8e7b00d81;l\u003d1503 ?\n\nI can create a client socket and attempt to connect (client \u003d ss_-\u003eCreateSocket, client-\u003eConnect(kLocalAddr1), but not so clear how reliably wait for accept. I would have to call TCPPort::CreateConnection, but not sure I understand its arguments, and it looks like it must be called *after* the socket has been accepted (via callbacks originating in VirtualSocketServer), or it will enter the code path for outgoing connections. I also had a look at the test method PortTest::TestConnectivity, and that\u0027s quite a lot of complexity I don\u0027t quite understand.",
      "parentUuid": "7cb8bf40_bb082c69",
      "revId": "8838754683e94c419db259b4530bb0860a917bc8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f89e36d_1824fc9e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5634
      },
      "writtenOn": "2021-11-01T15:16:36Z",
      "side": 1,
      "message": "In a WebRTC test, use EXPECT_TRUE_WAIT(variable flipped by the callback).\nAdd an observer that flips the state variable when the connection is accepted. Then loook at the resulting socket to see what status it has.",
      "parentUuid": "7cd7b1f4_d4f75475",
      "revId": "8838754683e94c419db259b4530bb0860a917bc8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5b4cbb9_8b7c16b1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 5686
      },
      "writtenOn": "2021-11-01T19:48:13Z",
      "side": 1,
      "message": "The important parts of TestConnectivity are: \n\n* Create two ports, wait for them to be ready\n* Call CreateConnection on one of them and wait for it to get connected\n* Send a connectivity check. This will result in SignalUnknownAddress firing with the address of the outgoing socket, which we need for CreateConnection.\n* Call CreateConnection on the other socket with the above address, which should use the incoming connection (TestChannel listens for SignalUnknownAddress and inserts this address when you call AcceptConnection)\n\nSo I think you can just do:\n  \n  rtc::ScopedFakeClock clock;\n  // Not sure if this is even needed\n  port1-\u003eset_component(cricket::ICE_CANDIDATE_COMPONENT_DEFAULT);\n  port2-\u003eset_component(cricket::ICE_CANDIDATE_COMPONENT_DEFAULT);\n\n  // Set up channels and ensure both ports will be deleted.\n  TestChannel ch1(std::move(port1));\n  TestChannel ch2(std::move(port2));\n\n  // Acquire addresses.\n  ch1.Start();\n  ch2.Start();\n  ASSERT_EQ_SIMULATED_WAIT(1, ch1.complete_count(), kDefaultTimeout, clock);\n  ASSERT_EQ_SIMULATED_WAIT(1, ch2.complete_count(), kDefaultTimeout, clock);\n\n  // Connect and send a ping from src to dst.\n  ch1.CreateConnection(GetCandidate(ch2.port()));\n  ASSERT_TRUE(ch1.conn() !\u003d NULL);\n  EXPECT_TRUE_SIMULATED_WAIT(ch1.conn()-\u003econnected(), kDefaultTimeout,\n                             clock);  // for TCP connect\n  ch1.Ping();\n  SIMULATED_WAIT(!ch2.remote_address().IsNil(), kShortTimeout, clock);\n  \n  // Accept the connection.\n  ch2.AcceptConnection(GetCandidate(ch1.port()));\n  ASSERT_TRUE(ch2.conn() !\u003d NULL);\n  \n  // Can now inspect the options of ch2.conn().socket()",
      "parentUuid": "0f89e36d_1824fc9e",
      "revId": "8838754683e94c419db259b4530bb0860a917bc8",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}