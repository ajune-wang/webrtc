/*
 *  Copyright 2017 The WebRTC Project Authors. All rights reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree. An additional intellectual property rights grant can be found
 *  in the file PATENTS.  All contributing project authors may
 *  be found in the AUTHORS file in the root of the source tree.
 */

#ifndef P2P_LOGGING_STRINGIFIED_ENUM_H_
#define P2P_LOGGING_STRINGIFIED_ENUM_H_

#include <algorithm>
#include <functional>
#include <map>
#include <set>
#include <string>
#include <vector>

// This file defines utilities to define scoped enumerated types, of which the
// enumerated values can be stringified in compile-time using a user-defined
// formatter.
//
// The defined enum type has two helper methods, EnumToStr and StrToEnum,
// which can
//  1) stringify the enumerated value to a corresponding string
//  representation and also
//  2) translate a string representation to an enumerated value if such a
//  mapping exists; otherwise this string is recorded for reference in case
//  any ad-hoc value can appear in tests and applications.
//
// The stringifying rule from an enumerated value to a string is given by
// the user and the string-to-enum inverse mapping is automatically generated.
//
// Usage:
// 1. Declare an scoped enum using the statement
// DEFINE_STRINGIFIED_ENUM(name-of-the-enum, enum-val-1, enum-val-2);
// e.g.,
// DEFINE_STRINGIFIED_ENUM(Fruit, kApple, kBanana, kCranberry);
//
// 2. The above declaration exports enumerated values that can be used as scoped
// enum, scoped within name-of-the-enum::Value, e.g., Fruit::Value::kApple.
//
// 3. After the definition of the enum, the stringified enum name can be
// obtained using the EnumToStr method, e.g.,
// Fruit::EnumToStr(Fruit::Value::kApple), which returns "apple".

namespace webrtc {

namespace icelog {

// Tokenize an arguments string "arg1, arg2, ..., argN" to
// {"arg1", "arg2", ... "argN"}.
std::vector<std::string> TokenizeArgString(const std::string& args_str);

// The default formatter that reformats the string "kNameInCamelCase" generated
// from naming convention of enum values to an "nameInCamelCase" string.
auto const defaultFormatter = [](std::string s) {
  if (!s.empty() && s[0] == 'k') {
    s = s.substr(1);
  }
  s[0] = ::tolower(s[0]);
  return s;
};

// InternalEnum is supposed to be a C++ scoped enum and StringifiedEnumInternal
// serves as a wrapper around InternalEnum to provide the stringifying
// utilities. enum_val_str is supposed to be a string consisting of all
// enumerated values of InternalEnum as string tokens separated by commas. The
// instantiation of StringifiedEnumInternal is done via the macro
// DEFINE_STRINGIFIED_ENUM where enum_val_str is auto-generated by the compiler.

template <typename InternalEnum, const char* enum_val_str>
class StringifiedEnumInternal {
 public:
  using Value = InternalEnum;

  StringifiedEnumInternal() : value_(Value::kUndefined) {}
  explicit StringifiedEnumInternal(Value other_value) { Init(other_value); }
  StringifiedEnumInternal(const StringifiedEnumInternal& other) { Init(other); }

  virtual StringifiedEnumInternal& operator=(
      const StringifiedEnumInternal& other);
  virtual StringifiedEnumInternal& operator=(Value other_value);

  virtual bool operator==(const StringifiedEnumInternal& other) const;

  // Enum to string.
  static std::map<Value, std::string> etos;
  // String to enum.
  static std::map<std::string, Value> stoe;

  static std::string EnumToStr(Value enum_val);
  static Value StrToEnum(const std::string& str);

  static std::string undefined_encountered();
  Value value() const { return value_; }

  using Formatter = std::function<std::string(std::string&)>;
  void set_formatter(Formatter formatter) { formatter_ = formatter; }

  virtual ~StringifiedEnumInternal() = default;

 private:
  static bool reflected_;
  static std::set<std::string> undefined_set_str_;
  static Formatter formatter_;
  Value value_;
  static void Reflect();
  void Init(const StringifiedEnumInternal& other);
  void Init(Value other_value);
};

#define DEFINE_VARIADIC_ENUM(enum_name, ...) \
  enum class enum_name { kUndefined = 0, __VA_ARGS__, kNumElementsPlusOne }

// Implementation detail via the example
// DEFINE_STRINGIFIED_ENUM(Fruit, kApple, kBanana, kCranberry)
//
// The string "kApple, kBanana, kCranberry" is stored as the basis for
// reflection, which converts it to an string array
// {"kApple", "kBanana", "kCranberry"}, which is further reformatted by the
// formatter to, e.g. by default {"apple", "banana", "cranberry"} and
// the mapping between enum and string is populated afterwards.

#define DEFINE_STRINGIFIED_ENUM(enum_name, ...)                      \
  DEFINE_VARIADIC_ENUM(enum_name##InternalEnum, __VA_ARGS__);        \
  const char enum_name##InternalEnum_val_str[] = #__VA_ARGS__;       \
  using enum_name = StringifiedEnumInternal<enum_name##InternalEnum, \
                                            enum_name##InternalEnum_val_str>

// Definition of template static members and implementation of template methods.
#define StringifiedEnumInternalType \
  StringifiedEnumInternal<InternalEnum, enum_val_str>

template <typename InternalEnum, const char* enum_val_str>
bool StringifiedEnumInternalType::reflected_ = false;

template <typename InternalEnum, const char* enum_val_str>
typename StringifiedEnumInternalType::Formatter
    StringifiedEnumInternalType::formatter_ = defaultFormatter;

template <typename InternalEnum, const char* enum_val_str>
std::map<typename StringifiedEnumInternalType::Value, std::string>
    StringifiedEnumInternalType::etos = {};

template <typename InternalEnum, const char* enum_val_str>
std::map<std::string, typename StringifiedEnumInternalType::Value>
    StringifiedEnumInternalType::stoe = {};

template <typename InternalEnum, const char* enum_val_str>
std::set<std::string> StringifiedEnumInternalType::undefined_set_str_;

template <typename InternalEnum, const char* enum_val_str>
void StringifiedEnumInternalType::Reflect() {
  reflected_ = true;
  std::string cs(enum_val_str);
  std::vector<std::string> enum_val_tokens =
      webrtc::icelog::TokenizeArgString(cs);
  etos[Value::kUndefined] = "undefined";
  for (int i = 1; i < static_cast<int>(Value::kNumElementsPlusOne); i++) {
    StringifiedEnumInternalType::Value e =
        (StringifiedEnumInternalType::Value)i;
    std::string s = formatter_(enum_val_tokens[i - 1]);
    etos[e] = s;
    stoe[s] = e;
  }
}

template <typename InternalEnum, const char* enum_val_str>
std::string StringifiedEnumInternalType::EnumToStr(
    typename StringifiedEnumInternalType::Value enum_val) {
  if (!reflected_) {
    StringifiedEnumInternalType::Reflect();
  }
  if (enum_val == Value::kUndefined) {
    return undefined_encountered();
  }
  return etos[enum_val];
}

template <typename InternalEnum, const char* enum_val_str>
typename StringifiedEnumInternalType::Value
StringifiedEnumInternalType::StrToEnum(const std::string& str) {
  if (!reflected_) {
    StringifiedEnumInternalType::Reflect();
  }
  if (stoe.find(str) != stoe.end()) {
    return stoe[str];
  }
  undefined_set_str_.insert(str.empty() ? "null" : str);
  return Value::kUndefined;
}

template <typename InternalEnum, const char* enum_val_str>
std::string StringifiedEnumInternalType::undefined_encountered() {
  std::string ret;
  for (std::string s : undefined_set_str_) {
    ret += s + ", ";
  }
  ret = ret.substr(0, ret.size() - 2);
  return ret;
}

template <typename InternalEnum, const char* enum_val_str>
StringifiedEnumInternalType& StringifiedEnumInternalType::operator=(
    const StringifiedEnumInternalType& other) {
  Init(other);
  return *this;
}

template <typename InternalEnum, const char* enum_val_str>
StringifiedEnumInternalType& StringifiedEnumInternalType::operator=(
    Value other_value) {
  Init(other_value);
  return *this;
}

template <typename InternalEnum, const char* enum_val_str>
bool StringifiedEnumInternalType::operator==(
    const StringifiedEnumInternalType& other) const {
  return value_ == other.value();
}

template <typename InternalEnum, const char* enum_val_str>
void StringifiedEnumInternalType::Init(
    const StringifiedEnumInternalType& other) {
  value_ = other.value();
}

template <typename InternalEnum, const char* enum_val_str>
void StringifiedEnumInternalType::Init(Value other_value) {
  value_ = other_value;
}

}  // namespace icelog

}  // namespace webrtc

#endif  // P2P_LOGGING_STRINGIFIED_ENUM_H_
