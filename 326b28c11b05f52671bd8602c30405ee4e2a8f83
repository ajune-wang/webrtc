{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "69ac6a26_1c8ad476",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 31
      },
      "lineNbr": 0,
      "author": {
        "id": 5578
      },
      "writtenOn": "2021-01-19T12:20:12Z",
      "side": 1,
      "message": "Jonas, would you mind reviewing this instead of me? I have very little knowledge about this part of the code?",
      "revId": "326b28c11b05f52671bd8602c30405ee4e2a8f83",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a9d59d73_d79b2c14",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 31
      },
      "lineNbr": 0,
      "author": {
        "id": 5613
      },
      "writtenOn": "2021-01-19T12:44:36Z",
      "side": 1,
      "message": "LGTM on the actual patch.\n\nSome comment on the project/bug: sorry for being late to the party.\n\nThe \"old\" sigslot code had the nice feature of being easy to read as it was \nnamed similarly, and structured similarly.\nIs there a proposal on how that should be done wrt to CallbackList too ?\n\ne.g\n1) definition:\nsigslot SignalPortDestroyed \u003d\u003e port_destroyed_\ncomment: how about port_destroyed_callback_list_\n\n2) invokation:\nSignalPortDestroyed(args); \u003d\u003e port_destroyed_.Send(args);\ncomment: ok\n\n3) subscription\nSignalPortDestroyed.connect(args) \u003d\u003e MyClass::SubscribePortDestroyed()\ncomment: why not \"connect\" like before ?\n",
      "revId": "326b28c11b05f52671bd8602c30405ee4e2a8f83",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0a90e333_034566ff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 31
      },
      "lineNbr": 0,
      "author": {
        "id": 5508
      },
      "writtenOn": "2021-01-19T13:20:31Z",
      "side": 1,
      "message": "Before submitting - can we have assurances around avoiding uaf?\n(temporarily -1ing in case of accidental submit)",
      "revId": "326b28c11b05f52671bd8602c30405ee4e2a8f83",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7dcb788_e4bf3976",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 31
      },
      "lineNbr": 0,
      "author": {
        "id": 5087
      },
      "writtenOn": "2021-01-19T13:57:08Z",
      "side": 1,
      "message": "Yes, this is a great point and it is good we have the possibility to address this early in the process (it will make future refactoring easier).\n\nIn SigSlot, if I understand correctly, this is handled by the base class sigslot::has_slots\u003c\u003e which does this: https://source.chromium.org/chromium/chromium/src/+/master:third_party/webrtc/rtc_base/third_party/sigslot/sigslot.h;l\u003d496;drc\u003da4d873786f10eedd72de25ad0d94ad7c53c1f68a. So when a class with slots (a class that has methods connect()\u0027ed to signals) gets destroyed, it automatically disconnects all its slots. In this case, P2PTransportChannel \u003c-- IceTransportInternal \u003c-- PacketTransportInternal \u003c-- sigslot::has_slots\u003c\u003e.\n\nkwiberg@ has added the possibility to do something similar in https://webrtc-review.googlesource.com/c/src/+/195332, I think this CL might be the first one that needs to use it (the class keeps track of what it subscribes to and unsubscribes when it gets destroyed).\n\nOn the other hand, if we are 100% sure that the callback will always have a longer lifetime, we might want to avoid this. How can we signal this from a lifetime point of view? A comment is not good enough, while before we were paying for more locking and cleanup than we were aware of, we now need a way to make these things clear.",
      "parentUuid": "0a90e333_034566ff",
      "revId": "326b28c11b05f52671bd8602c30405ee4e2a8f83",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}