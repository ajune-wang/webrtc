{
  "comments": [
    {
      "key": {
        "uuid": "8466e9bd_c0841636",
        "filename": "api/test/fake_frame_decryptor.cc",
        "patchSetId": 2
      },
      "lineNbr": 28,
      "author": {
        "id": 5525
      },
      "writtenOn": "2018-10-26T10:41:27Z",
      "side": 1,
      "message": "Name these error codes?",
      "range": {
        "startLine": 28,
        "startChar": 0,
        "endLine": 28,
        "endChar": 13
      },
      "revId": "80852422058636af72e371ea101c7bb3909350e0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ec0ab3a6_ba14bd1e",
        "filename": "api/test/fake_frame_encryptor.cc",
        "patchSetId": 2
      },
      "lineNbr": 26,
      "author": {
        "id": 5525
      },
      "writtenOn": "2018-10-26T10:41:27Z",
      "side": 1,
      "message": "Seems like this error code should be named?",
      "range": {
        "startLine": 26,
        "startChar": 0,
        "endLine": 26,
        "endChar": 13
      },
      "revId": "80852422058636af72e371ea101c7bb3909350e0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce6bbd03_42ed9bb3",
        "filename": "video/end_to_end_tests/frame_encryption_tests.cc",
        "patchSetId": 2
      },
      "lineNbr": 46,
      "author": {
        "id": 5527
      },
      "writtenOn": "2018-10-26T11:50:53Z",
      "side": 1,
      "message": "This test does not actually verify that frames were encrypted/decrypted. \n\nIt is too bad that we currently only support VP8 to be used with the generic descriptor, because without a fake encoder it is really hard to write this test.\n\nMaybe you could implement a FakeEncoder::SetCodecType function (like we have for this encoder: https://cs.chromium.org/chromium/src/third_party/webrtc/test/configurable_frame_size_encoder.h?l\u003d47). This way you could use the fake encoder which produce a known output (https://cs.chromium.org/chromium/src/third_party/webrtc/test/fake_encoder.cc?q\u003dfake_encoder.cc\u0026g\u003d0\u0026l\u003d46). You may also want to implement a FakeEncoder::SetEncodedData to override the generated encoded data set here, but I\u0027m not sure if that is necessary.\n\nFinally I would suggest having a decryptor that does not actually decrypt the encrypted data, but modifies it some other way. When you inspect the decoded image you can then verify that the data was first modified by the encryptor and then modified by the decryptor in the way you expected.",
      "range": {
        "startLine": 46,
        "startChar": 6,
        "endLine": 46,
        "endChar": 33
      },
      "revId": "80852422058636af72e371ea101c7bb3909350e0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4d274885_4693da99",
        "filename": "video/end_to_end_tests/frame_encryption_tests.cc",
        "patchSetId": 2
      },
      "lineNbr": 73,
      "author": {
        "id": 5527
      },
      "writtenOn": "2018-10-26T11:50:53Z",
      "side": 1,
      "message": "To keep the test as focused as possible you should not check this in your test.",
      "range": {
        "startLine": 73,
        "startChar": 6,
        "endLine": 73,
        "endChar": 60
      },
      "revId": "80852422058636af72e371ea101c7bb3909350e0",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767",
      "unresolved": true
    }
  ]
}