{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "d99f0b89_24aebf78",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5064
      },
      "writtenOn": "2020-10-23T15:35:38Z",
      "side": 1,
      "message": "mfoltz: Can you provide some input on how Chromium would like to handle this in your desktop_capture code?\n\n",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2493b102_185a816f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2020-10-23T15:50:59Z",
      "side": 1,
      "message": "We actually had a long (very long) discussion about this with Mark, we went through many iterations, where the very first one was actually about skipping the Chromium dialog and that\u0027s why the change description didn\u0027t match. This should be the version approved by Mark as we were basically not allowed any UI changes on Chromium side and the only minor change we did was slight modification of the \"Window tab\" in the preview dialog to behave like \"Screen tab\".",
      "parentUuid": "d99f0b89_24aebf78",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "78403895_b4df492e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5064
      },
      "writtenOn": "2020-10-27T18:31:56Z",
      "side": 1,
      "message": "Hi Jan,\n\nThanks for your patience. I\u0027m still struggling a little to understand the specifics of the XDG interaction, since I originally misunderstood which picker we plan to show, I think.\n\nWhat is the specific mechanism by which we suppress the XDG picker?\n\nThanks,\n\nWez\n",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "42b60dd1_afd0523c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2020-10-27T19:26:52Z",
      "side": 1,
      "message": "Hi,\n\nI will try to explain the concept of xdg-desktop-portal (XDP). XDP is a DBus interface, primarily introduced for sandboxed applications to provide a way how those application can access things outside sandbox. Think of for example a file dialog. In strict sandbox environment apps wouldn\u0027t have access to system files so opening a file dialog inside sandbox would not allow them to open anything useful. That\u0027s where XDP comes on the stage. As I said it\u0027s a DBus interface which is by default accessible by everyone and consists from several portals . In the file dialog scenario it\u0027s a FileChooser portal which lets apps to send a request through XDP and open a file dialog outside the sandbox environment. With screen sharing it\u0027s quite similar, because Wayland is sort of similar to sandboxed environment, because apps on Wayland don\u0027t see each other and because of this we have to go through ScreenSharing portal.\n\nIf you want to share a screen on Wayland, you have to make a ScreenSharing portal request, specifying whether you want to request a screen or a window and then a dialog from XDP is shown where the user has to explicitly allow access to requested content. That\u0027s the only way how we can access screen content or access to some other app window.\n\nIn case of Chromium, we basically want to access screen/window two times, for the first time it\u0027s in the Chromium preview dialog and again on the web page itself, because each uses new webrtc::DesktopCapturer instance. Originally XDP implementation was part of webrtc::DesktopCapturer and deleted together and that was the reason why we did two XDP calls resulting into two XDP dialogs. With this change we no longer keep XDP interface as part of webrtc::DesktopCapturer and it\u0027s left alive so we avoid the second XDP screensharing request where the user would basically pick the same screen/window as before and therefore it was useless and annoying. \n\nDoes this make sense?",
      "parentUuid": "78403895_b4df492e",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "86abc448_6c204e66",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 14134
      },
      "writtenOn": "2020-10-27T20:38:29Z",
      "side": 1,
      "message": "Wez, \n\nThe design doc for this project has some of the background information covered by Jan.\n\nhttps://docs.google.com/document/d/1DTO1GzA1Iwdhw4KQPYSW9iRwA0QRi0Bsobbq6YCK77g/edit?usp\u003dsharing\n\n",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f97233e1_7bb7f080",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2020-10-27T20:43:45Z",
      "side": 1,
      "message": "This was the very first proposal where we didn\u0027t want the Chromium dialog to show up, which was not allowed in the end, but it should help to understand how it works with portals.",
      "parentUuid": "86abc448_6c204e66",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87126abf_3b191607",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5064
      },
      "writtenOn": "2020-10-29T01:01:39Z",
      "side": 1,
      "message": "Thanks Jan.\n\nReading through the document that Mark linked, if I understand correctly, the current situation is actually that we show _three_ pickers, not two - one XDG screen picker, then the Chromium picker, and then another XDG picker - and we want to reduce that to just the initial XDG ScreenSharing picker \u0026 the Chromium picker.  That\u0027s the detail I was confused about. ðŸ˜Š\n\nBut to suppress the second XDG ScreenSharing picker when we actually start the capture do we need just to create the capturer over the same XDG ScreenSharing portal connection, or is there a picker per-request-Id even over a single XDG connection?\n\nEither way, we need to convey sufficient information in the DesktopCaptureOptions of the CreateCapturer request used for the actual capture to link it back to the CreateCapturer call used for the picker.  With the current implementation in the matching Chromium CL I\u0027m not sure how the request-Id is getting preserved between the picker capture operation, and the one used for the actual capture?",
      "parentUuid": "42b60dd1_afd0523c",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3862880b_483e1284",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2020-10-29T07:53:06Z",
      "side": 1,
      "message": "\u003e Thanks Jan.\n\u003e \n\u003e Reading through the document that Mark linked, if I understand correctly, the current situation is actually that we show _three_ pickers, not two - one XDG screen picker, then the Chromium picker, and then another XDG picker - and we want to reduce that to just the initial XDG ScreenSharing picker \u0026 the Chromium picker.  That\u0027s the detail I was confused about. ðŸ˜Š\n\nYes.\n\n\u003e But to suppress the second XDG ScreenSharing picker when we actually start the capture do we need just to create the capturer over the same XDG ScreenSharing portal connection, or is there a picker per-request-Id even over a single XDG connection?\n\nIt needs to be a capturer over the same XDG ScreenSharing portal connection, we don\u0027t want to make a new on or any additional XDG call. We already have what we need from the previous one which is PipeWire stream file descriptor we use to open PipeWire connection on our side.  \n\n\u003e Either way, we need to convey sufficient information in the DesktopCaptureOptions of the CreateCapturer request used for the actual capture to link it back to the CreateCapturer call used for the picker.  With the current implementation in the matching Chromium CL I\u0027m not sure how the request-Id is getting preserved between the picker capture operation, and the one used for the actual capture?\n\nEach capturer provides list of sources (with IDs) by \"webrtc::DesktopCapture:GetSourceList(SourceList *list)\" method and Chromium internally saves the one we picked and uses it later in the actual capturer with \"webrtc::DesktopCapture::SelectSource(SourceId id)\". That\u0027s what we use as an ID for the XDG ScreenSharing request.",
      "parentUuid": "87126abf_3b191607",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f29ff183_1a06ffd4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5064
      },
      "writtenOn": "2020-10-29T11:18:46Z",
      "side": 1,
      "message": "\u003e \u003e Thanks Jan.\n\u003e \u003e \n\u003e \u003e Reading through the document that Mark linked, if I understand correctly, the current situation is actually that we show _three_ pickers, not two - one XDG screen picker, then the Chromium picker, and then another XDG picker - and we want to reduce that to just the initial XDG ScreenSharing picker \u0026 the Chromium picker.  That\u0027s the detail I was confused about. ðŸ˜Š\n\u003e \n\u003e Yes.\n\u003e \n\u003e \u003e But to suppress the second XDG ScreenSharing picker when we actually start the capture do we need just to create the capturer over the same XDG ScreenSharing portal connection, or is there a picker per-request-Id even over a single XDG connection?\n\u003e \n\u003e It needs to be a capturer over the same XDG ScreenSharing portal connection, we don\u0027t want to make a new on or any additional XDG call. We already have what we need from the previous one which is PipeWire stream file descriptor we use to open PipeWire connection on our side.\n\nGreat, thanks for confirming.\n\n\u003e \u003e Either way, we need to convey sufficient information in the DesktopCaptureOptions of the CreateCapturer request used for the actual capture to link it back to the CreateCapturer call used for the picker.  With the current implementation in the matching Chromium CL I\u0027m not sure how the request-Id is getting preserved between the picker capture operation, and the one used for the actual capture?\n\u003e \n\u003e Each capturer provides list of sources (with IDs) by \"webrtc::DesktopCapture:GetSourceList(SourceList *list)\" method and Chromium internally saves the one we picked and uses it later in the actual capturer with \"webrtc::DesktopCapture::SelectSource(SourceId id)\". That\u0027s what we use as an ID for the XDG ScreenSharing request.\n\nThe GetSourceList() / SelectSource() APIs are intended to enumerate or select one of the actual sources that a particular type of capturer can provide imagery from, e.g. the set of available windows, available monitors, etc. Using it to correlate the picker operations doesn\u0027t quite fit that model, but I see why that seems the most straightforward approach.\n\nThe problem with using the SourceId to correlate picker \u0026 capture requests is that you\u0027ve no idea when a SourceId ceases to be valid, unless the client explicitly informs you of that.  The problem with having clients explicitly inform you of these things, though, is that they may forget to do so.  It\u0027s also strange to have the client specify the Id in the DesktopCaptureOptions, for the PipeWire implementation to spit back out via GetSourceList().\n\nWhat makes this difficult is that there both WebRTC and Chromium use _identifiers_ to refer to the capture source, rather than treating them as _resources_ - there\u0027s no notion of the \"lifetime\" of e.g. a content::DesktopMediaId, as such. Ideally the SourceId would be a resource, e.g. a refptr\u003c\u003e to an opaque WebRTC-internal resource type that each capturer implementation could use to retain state of this sort.  That would be a much more involved refactoring. ðŸ˜ž\n\nLooking inside the Chromium implementation, I see that every DisplayMediaAccessHandler::PendingAccessRequest owns the DesktopMediaPicker instance - so we _do_ have a resource in Chromium which has the right scope.  Does that mean that the DesktopCapturer instance created for the picker is only destroyed _after_ the DesktopCapturer instance for the actual capture is created?\n\nWould the following flow work:\n1. When the PipeWire capturer is created for the picker, and GetSourceList() is called, allocate and return a new unique SourceId. Store details of the media picked by that Id in the singleton XDG portal object.\n2. If a capturer is created and SelectSource() is called with a SourceId then look that up and create a new reference to that request-Id in the XDG portal object.\n3. When a capturer is destroyed, dereference the request data for its Id, if any.\n\ni.e. so long as the picker and capturer instances have overlapping lifetimes, the picker\u0027s SourceId will remain valid and we\u0027ll be able to skip re-showing the XDG picker dialog.  But all the magic of maintaining that state remains hidden behind the capturer interface.",
      "parentUuid": "3862880b_483e1284",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9ddef10d_4efcfc4c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 5064
      },
      "writtenOn": "2020-10-29T11:18:46Z",
      "side": 1,
      "message": "tl;dr: The fundamental problem here seems to be that SourceIds are plain _identifiers_, whereas we want to use them more like _resources_, scoped to a particular capture activity.\n\nBesides making optimizations like this one painful to implement, that creates a risk of things getting out-of-sync, if the sources returned do not have stable Ids, e.g. a ScreenCapturer\u0027s SourceIds may presumably change if monitors are added, removed, or even reconfigured, potentially?\n\nMark \u0026 Tommi: WDYT? Would making SourceIds \"resources\" rather than identifiers actually be straightforward? And if not then do you have any concerns with using SourceIds identifiers to refer to XDG state across multiple capturer instances?\n",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfef054d_e19628bf",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 8046
      },
      "writtenOn": "2020-10-29T11:56:13Z",
      "side": 1,
      "message": "\u003e \u003e \u003e Thanks Jan.\n\u003e \u003e \u003e \n\u003e \u003e \u003e Reading through the document that Mark linked, if I understand correctly, the current situation is actually that we show _three_ pickers, not two - one XDG screen picker, then the Chromium picker, and then another XDG picker - and we want to reduce that to just the initial XDG ScreenSharing picker \u0026 the Chromium picker.  That\u0027s the detail I was confused about. ðŸ˜Š\n\u003e \u003e \n\u003e \u003e Yes.\n\u003e \u003e \n\u003e \u003e \u003e But to suppress the second XDG ScreenSharing picker when we actually start the capture do we need just to create the capturer over the same XDG ScreenSharing portal connection, or is there a picker per-request-Id even over a single XDG connection?\n\u003e \u003e \n\u003e \u003e It needs to be a capturer over the same XDG ScreenSharing portal connection, we don\u0027t want to make a new on or any additional XDG call. We already have what we need from the previous one which is PipeWire stream file descriptor we use to open PipeWire connection on our side.\n\u003e \n\u003e Great, thanks for confirming.\n\u003e \n\u003e \u003e \u003e Either way, we need to convey sufficient information in the DesktopCaptureOptions of the CreateCapturer request used for the actual capture to link it back to the CreateCapturer call used for the picker.  With the current implementation in the matching Chromium CL I\u0027m not sure how the request-Id is getting preserved between the picker capture operation, and the one used for the actual capture?\n\u003e \u003e \n\u003e \u003e Each capturer provides list of sources (with IDs) by \"webrtc::DesktopCapture:GetSourceList(SourceList *list)\" method and Chromium internally saves the one we picked and uses it later in the actual capturer with \"webrtc::DesktopCapture::SelectSource(SourceId id)\". That\u0027s what we use as an ID for the XDG ScreenSharing request.\n\u003e \n\u003e The GetSourceList() / SelectSource() APIs are intended to enumerate or select one of the actual sources that a particular type of capturer can provide imagery from, e.g. the set of available windows, available monitors, etc. Using it to correlate the picker operations doesn\u0027t quite fit that model, but I see why that seems the most straightforward approach.\n\u003e \n\u003e The problem with using the SourceId to correlate picker \u0026 capture requests is that you\u0027ve no idea when a SourceId ceases to be valid, unless the client explicitly informs you of that.  The problem with having clients explicitly inform you of these things, though, is that they may forget to do so.  It\u0027s also strange to have the client specify the Id in the DesktopCaptureOptions, for the PipeWire implementation to spit back out via GetSourceList().\n\u003e \n\u003e What makes this difficult is that there both WebRTC and Chromium use _identifiers_ to refer to the capture source, rather than treating them as _resources_ - there\u0027s no notion of the \"lifetime\" of e.g. a content::DesktopMediaId, as such. Ideally the SourceId would be a resource, e.g. a refptr\u003c\u003e to an opaque WebRTC-internal resource type that each capturer implementation could use to retain state of this sort.  That would be a much more involved refactoring. ðŸ˜ž\n\u003e \n\u003e Looking inside the Chromium implementation, I see that every DisplayMediaAccessHandler::PendingAccessRequest owns the DesktopMediaPicker instance - so we _do_ have a resource in Chromium which has the right scope.  Does that mean that the DesktopCapturer instance created for the picker is only destroyed _after_ the DesktopCapturer instance for the actual capture is created?\n\u003e \n\nMy understanding from the code is that the DesktopMediaPicker associated with a screen sharing requests owns all the capturers needed for preview and those are deleted together with the DesktopMediaPicker. Then it continues and calls the callback with the result from picker, where it obtained the ID I use from the capturer. I could verify that putting some debug output into the code now.\n\n\u003e Would the following flow work:\n\u003e 1. When the PipeWire capturer is created for the picker, and GetSourceList() is called, allocate and return a new unique SourceId. Store details of the media picked by that Id in the singleton XDG portal object.\n\u003e 2. If a capturer is created and SelectSource() is called with a SourceId then look that up and create a new reference to that request-Id in the XDG portal object.\n\u003e 3. When a capturer is destroyed, dereference the request data for its Id, if any.\n\nThat would work in case both capturers live at the same time.\n\nWhat I do to make it work and handle all possible cases is described in following scenarios:\n1) A capturer is created and we have an ID provided by the browser, then we instantly initialize XDG portal and then re-use it in the actual capturer in case of 2a.\n2) A capturer is created and we don\u0027t have an ID, in that case we wait for:\n  2a) SelectSource() to be called first before GetSourceList(). That would mean\n      we want to get an already configured XDG portal request so I check if the\n      ID is not null and can be used. In case this ID would be invalid, then a\n      new XDG portal request would be made so it still works, it will just show \n      additional dialog.\n  2b) GetSourceList() to be called, which will be called first in case we want\n      a capturer for the Chromium picker and therefore we don\u0027t need to wait for\n      ID as it won\u0027t be provided by browser and we just create a random one and \n      make a new XDG portal call. This will be case where browser use our\n      capturer without changes.\n\nI also handle closing this way:\n1) When a random ID is generated, it means we won\u0027t re-use the ID and all the XDG portal calls are automatically closed when the capturer is destroyed.\n2) When we use a specific ID provided by broser, then I close XDG portal call once we finish the actual streaming on web (\u003d it was used two times).\n3) In case we provide a specific ID, but the Chromium picker was cancelled or user wanted to share a web tab, we close the recent request from Chromium side.\n\n\u003e i.e. so long as the picker and capturer instances have overlapping lifetimes, the picker\u0027s SourceId will remain valid and we\u0027ll be able to skip re-showing the XDG picker dialog.  But all the magic of maintaining that state remains hidden behind the capturer interface.",
      "parentUuid": "f29ff183_1a06ffd4",
      "revId": "a5685075bdea023492090bec83a6064b71b20b84",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}