// THIS FILE IS EXPERIMENTAL. BREAKING CHANGES MAY BE MADE AT ANY TIME
// WITHOUT PRIOR WARNING. THIS FILE SHOULD NOT BE USED IN PRODUCTION CODE.

syntax = "proto2";
option optimize_for = LITE_RUNTIME;
package webrtc.rtclog2;

// At the top level, a WebRTC event log is just an EventStream object. Note that
// concatenating multiple EventStreams in the same file is equivalent to a
// single EventStream object containing the same events. Hence, it is not
// necessary to wait for the entire log to be complete before beginning to
// write it to a file.
message EventStream {
  // Deprecated - Maintained for compatibility with the old event log.
  repeated Event stream = 1 [deprecated = true];
  // required - The version number must be 2 for tis version of the event log.
  optional uint32 version = 2;
  repeated IncomingRtpPacket incoming_rtp_packets = 3;
  repeated OutgoingRtpPacket outgoing_rtp_packets = 4;
  repeated IncomingRtcpPacket incoming_rtcp_packets = 5;
  repeated OutgoingRtcpPacket outgoing_rtcp_packets = 6;
  repeated AudioPlayoutEvent audio_playout_events = 7;
  repeated LossBasedBweUpdate loss_based_bwe_updates = 8;
  repeated DelayBasedBweUpdate delay_based_bwe_updates = 9;
  // The field tags 10-15 are reserved for the most common events
  repeated AudioNetworkAdaptation audio_network_adaptations = 16;
  repeated BweProbeCluster probe_clusters = 17;
  repeated BweProbeResult probe_results = 18;
  repeated Batch batches = 19;
}

// DEPRECATED.
message Event {
  // TODO(terelius): Do we want to preserve the old Event definition here?
}

message IncomingRtpPacket {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // RTP marker bit, used to label boundaries within e.g. video frames.
  optional bool marker = 2;

  // RTP payload type.
  optional uint32 payload_type = 3;

  // RTP sequence number.
  optional uint32 sequence_number = 4;

  // RTP monotonic clock timestamp (not actual time).
  optional fixed32 rtp_timestamp = 5;

  // Synchronization source of this packet's RTP stream.
  optional fixed32 ssrc = 6;

  // required - The size of the packet including both payload and header.
  optional uint32 packet_size = 7;

  // Optional header extensions.
  optional int32 transmission_time_offset = 8;
  optional uint32 absolute_send_time = 9;
  optional uint32 transport_sequence_number = 10;

  // TODO(terelius): Add video rotation, playout delay, audio level, CSRCs etc?
}

message OutgoingRtpPacket {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // RTP marker bit, used to label boundaries within e.g. video frames.
  optional bool marker = 2;

  optional uint32 payload_type = 3;

  // RTP sequence number.
  optional uint32 sequence_number = 4;

  // RTP monotonic clock timestamp (not actual time).
  optional fixed32 rtp_timestamp = 5;

  // Synchronization source of this packet's RTP stream.
  optional fixed32 ssrc = 6;

  // required - The size of the packet including both payload and header.
  optional uint32 packet_size = 7;

  // TODO(philipel): Think about best way to encode this.
  optional uint32 probe_cluster_id = 8;

  // Optional header extensions.
  optional int32 transmission_time_offset = 9;
  optional uint32 absolute_send_time = 10;
  optional uint32 transport_sequence_number = 11;

  // TODO(terelius): Add video rotation, playout delay, audio level, CSRCs etc?
}

message IncomingRtcpPacket {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // required - The whole packet including both payload and header.
  optional bytes packet = 2;
  // TODO(terelius): Feasible to log parsed RTCP instead?
}

message OutgoingRtcpPacket {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // required - The whole packet including both payload and header.
  optional bytes packet = 2;
  // TODO(terelius): Feasible to log parsed RTCP instead?
}

message AudioPlayoutEvent {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // required - The SSRC of the audio stream associated with the playout event.
  optional uint32 local_ssrc = 2;
}

message LossBasedBweUpdate {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // required - Bandwidth estimate (in bps) after the update.
  optional int32 bitrate_bps = 2;

  // required - Fraction of lost packets since last receiver report
  // computed as floor( 256 * (#lost_packets / #total_packets) ).
  // The possible values range from 0 to 255.
  optional uint32 fraction_loss = 3;

  // TODO(terelius): Is this really needed? Remove or make optional?
  // required - Total number of packets that the BWE update is based on.
  optional int32 total_packets = 4;
}

message DelayBasedBweUpdate {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // required - Bandwidth estimate (in bps) after the update.
  optional int32 bitrate_bps = 2;

  enum DetectorState {
    BWE_NORMAL = 0;
    BWE_UNDERUSING = 1;
    BWE_OVERUSING = 2;
  }
  optional DetectorState detector_state = 3;
}

message LogStartEvent {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?
}

message LogEndEvent {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?
}

// Maps RTP header extension names to numerical IDs.
message RtpHeaderExtensionConfig {
  // Optional IDs for the header extensions. Each ID is a 4-bit number that is
  // only set if that extension is configured.
  optional int32 transmission_time_offset_id = 1;
  optional int32 absolute_send_time_id = 2;
  optional int32 transport_sequence_number_id = 3;
  optional int32 video_rotation_id = 4;
  // TODO(terelius): Add playout delay and audio level?
}

message VideoReceiveConfig {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // required - Synchronization source (stream identifier) to be received.
  optional uint32 remote_ssrc = 2;
  // required - Sender SSRC used for sending RTCP (such as receiver reports).
  optional uint32 local_ssrc = 3;

  // TODO(terelius): Do we need payload type?

  // required if RTX is configured
  optional uint32 rtx_ssrc = 4;

  // Map from video RTP payload type -> RTX payload type.
  map<int32, int32> rtx_payload_map = 5;

  // IDs for the header extension we care about. Only required if there are
  // header extensions configured.
  optional RtpHeaderExtensionConfig header_extensions = 6;
}

message VideoSendConfig {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // Synchronization source (stream identifier) for outgoing stream.
  // One stream can have several ssrcs for e.g. simulcast.
  // At least one ssrc is required.
  repeated uint32 ssrcs = 2;

  // TODO(terelius): Do we need payload type?

  // List of SSRCs for retransmitted packets.
  repeated uint32 rtx_ssrcs = 3;

  // required if rtx_ssrcs is used - Payload type for retransmitted packets.
  optional int32 rtx_payload_type = 4;

  // IDs for the header extension we care about. Only required if there are
  // header extensions configured.
  optional RtpHeaderExtensionConfig header_extensions = 5;
}

message AudioReceiveConfig {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // required - Synchronization source (stream identifier) to be received.
  optional uint32 remote_ssrc = 2;

  // required - Sender SSRC used for sending RTCP (such as receiver reports).
  optional uint32 local_ssrc = 3;

  // TODO(terelius): Do we need RTX for audio?
  // TODO(terelius): Do we need payload type?

  // IDs for the header extension we care about. Only required if there are
  // header extensions configured.
  optional RtpHeaderExtensionConfig header_extensions = 4;
}

message AudioSendConfig {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // required - Synchronization source (stream identifier) for outgoing stream.
  optional uint32 ssrc = 2;

  // TODO(terelius): Do we need RTX for audio?
  // TODO(terelius): Do we need payload type?

  // IDs for the header extension we care about. Only required if there are
  // header extensions configured.
  optional RtpHeaderExtensionConfig header_extensions = 3;
}

message AudioNetworkAdaptation {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // Bit rate that the audio encoder is operating at.
  optional int32 bitrate_bps = 2;

  // Frame length that each encoded audio packet consists of.
  optional int32 frame_length_ms = 3;

  // Packet loss fraction that the encoder's forward error correction (FEC) is
  // optimized for.
  optional float uplink_packet_loss_fraction = 4;

  // Whether forward error correction (FEC) is turned on or off.
  optional bool enable_fec = 5;

  // Whether discontinuous transmission (DTX) is turned on or off.
  optional bool enable_dtx = 6;

  // Number of audio channels that each encoded packet consists of.
  optional uint32 num_channels = 7;
}

message BweProbeCluster {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // required - The id of this probe cluster.
  optional uint32 id = 2;

  // required - The bitrate in bps that this probe cluster is meant to probe.
  optional uint64 bitrate_bps = 3;

  // required - The minimum number of packets used to probe the given bitrate.
  optional uint32 min_packets = 4;

  // required - The minimum number of bytes used to probe the given bitrate.
  optional uint32 min_bytes = 5;
}

message BweProbeResult {
  optional int64 timestamp_ms = 1;  // TODO(terelius): us or ms?

  // required - The id of this probe cluster.
  optional uint32 id = 2;

  enum ResultType {
    SUCCESS = 0;
    INVALID_SEND_RECEIVE_INTERVAL = 1;
    INVALID_SEND_RECEIVE_RATIO = 2;
    TIMEOUT = 3;
  }

  // required - The result of this probing attempt.
  optional ResultType result = 3;

  // optional - but required if result == SUCCESS. The resulting bitrate in bps.
  optional uint64 bitrate_bps = 4;
}

message Batch {
  // required - The number of delta encoded events following the first.
  optional uint32 delta_count = 1;

  // The mapping between field numbers and encodings.
  repeated uint32 field_number = 2 [packed = true];
  repeated uint32 encoding = 3 [packed = true];

  // The deltas packed into a byte array - required if delta_count > 0
  optional bytes deltas = 4;

  // required - The first event in the batch, serialized in it's natural
  // protobuf form.
  oneof subtype {
    IncomingRtpPacket incoming_rtp_packet = 5;
    OutgoingRtpPacket outgoing_rtp_packet = 6;
    IncomingRtcpPacket incoming_rtcp_packet = 7;
    OutgoingRtcpPacket outgoing_rtcp_packet = 8;
    AudioPlayoutEvent audio_playout_event = 9;
    LossBasedBweUpdate loss_based_bwe_update = 10;
    DelayBasedBweUpdate delay_based_bwe_update = 11;
    // The field tags 12-15 are reserved for the most common events
    AudioNetworkAdaptation audio_network_adaptation = 16;
    BweProbeCluster probe_cluster = 17;
    BweProbeResult probe_result = 18;
  }
}

