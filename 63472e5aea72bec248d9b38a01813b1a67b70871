{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f9152b3b_9a56e025",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-02-14T09:59:19Z",
      "side": 0,
      "message": "I think this doesn\u0027t satisfy https://en.cppreference.com/w/cpp/concepts/strict_weak_order (the transitivity) when prefixes have a different length (which should be used to make the comparison) we fallback on names.",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7444a0f7_fc882995",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5508
      },
      "writtenOn": "2022-02-14T10:18:11Z",
      "side": 0,
      "message": "would it make sense to use std::tie() for this?",
      "parentUuid": "f9152b3b_9a56e025",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53972ed0_715f037c",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-02-14T10:35:16Z",
      "side": 0,
      "message": "This isn\u0027t clearly documented. Should it just be an arbitrary well defined order (to be usable with std::map and the like), or correspond to some meaningful semantics?\n\nIf I read the first case correctly, it seems difference in |name| always takes precedence, and then I think it would be clearer to start with\n\n  if (a-\u003ename() !\u003d b-\u003ename()) { return a-\u003ename() \u003c b-\u003ename(); }\n\nand consider prefixes only when names are equal. To me it seems the logic that may break transitivity, is the special case of equal prefix_length, but I\u0027m having some difficulty understanding what\u0027s going on. Say you have three networks A, B, C all with the same name, transitivity means that we must rule out A \u003c\u003d B and B \u003c\u003d C, but A \u003e C.",
      "parentUuid": "7444a0f7_fc882995",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26754cea_b15c45ca",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-04-11T08:29:49Z",
      "side": 0,
      "message": "It is unclear to me as well. For example it is not clear to me why the name takes the precedence over the prefix.\n\nIt also looks like there are no tests so I might have to add some.\n\nI think we can use std::tie() but first we need to understand the comparison a bit more (unless we are OK to use std::tie on name, prefix length and prefix.\n\nWDYT?",
      "parentUuid": "53972ed0_715f037c",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e047f2bb_aa52dc33",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5634
      },
      "writtenOn": "2022-04-17T21:28:16Z",
      "side": 0,
      "message": "When prefix lengths are equal and names are different, order of names is used (fallthrough).\nWhen prefix lengths are different, order of names is used (always) - equal names will return true.\nWhen prefix lengths are equal, and names are equal, prefix is compared.\n\nI *think* this represents that names have higher priority than prefixes, but prefixes are used as a tiebreaker when names and lengths are equal - ordering two prefixes of different length is considered a Bad Idea.\n\n(Consider eth0 129.241.1.0/24 and eth0 0.0.0.0/0  - the first one being derived from the network route, the second one being the default route - they will compare equal under present logic, but would compare different under the changed logic)\n\nTL;DR - I think this function needs documentation on what it\u0027s doing, but the proposed change will change what it\u0027s doing.",
      "parentUuid": "26754cea_b15c45ca",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26f27585_dcbf2802",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-04-19T07:23:45Z",
      "side": 0,
      "message": "I can see only one use, with a call to absl::c_sort, see https://source.chromium.org/chromium/chromium/src/+/main:third_party/webrtc/rtc_base/network.cc;drc\u003d2ab914c6ab73ac0f85f633a5ce499cae74e7b75a;l\u003d347\n\nThe sorting affects iteration order of the loop just below. The networks are then moved into the consolidated_address_list map (indexed (and hence ordered) by the string returned by MakeNetworkKey, not CompareNetworks).\n\nSo not at all clear to me what\u0027s the purpose of this sorting.\n\nIt would make things more consistent of CompareNetworks(a,b) gave a result consistent with `MakeNetworkKey(a-\u003ename(), a-\u003eprefix(), a-\u003eprefix_length()) \u003c MakeNetworkKey(b-\u003ename(), b-\u003eprefix(), b-\u003eprefix_length())`, but if that make sense, I have no idea.",
      "parentUuid": "e047f2bb_aa52dc33",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f4e483d_040c24c0",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5634
      },
      "writtenOn": "2022-04-19T08:06:31Z",
      "side": 0,
      "message": "Sounds to me like CompareNetworks should die altogether (or be reduced to a lambda inside the c_sort on line 347), so that it\u0027s not going to be used by others, and its effects may be documented where it matters.\n\nAdds to the confusion that SortNetworks just below ignores the \"name\" component altogether.\n\nBut since it is used in a c_sort, not a c_stable_sort, I don\u0027t think the strict_weak_ordering criterion is applicable, so I don\u0027t see that the change has a benefit corresponding to the risk of changing behavior.",
      "parentUuid": "26f27585_dcbf2802",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3cba1579_e09bb312",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5234
      },
      "writtenOn": "2022-04-21T07:50:11Z",
      "side": 0,
      "message": "\u003e But since it is used in a c_sort, not a c_stable_sort, I don\u0027t think the strict_weak_ordering criterion is applicable, so I don\u0027t see that the change has a benefit corresponding to the risk of changing behavior.\n\nI\u0027d expect all sorting to require transitivity? Without it, sorting isn\u0027t well defined at all.",
      "parentUuid": "4f4e483d_040c24c0",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5cff7927_880630b9",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5634
      },
      "writtenOn": "2022-04-28T07:02:11Z",
      "side": 0,
      "message": "have we identified a case that is not transitive?",
      "parentUuid": "3cba1579_e09bb312",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee85bf2c_f0009abe",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-04-28T07:07:58Z",
      "side": 0,
      "message": "According to https://danlark.org/2022/04/20/changing-stdsort-at-googles-scale-and-beyond/ (which references this code as an example) the issue is with the Transitivity of incomparability: \"x \u003d\u003d y and y \u003d\u003d z imply x \u003d\u003d z, where x \u003d\u003d y means x \u003c y and y \u003c x are both false\".",
      "parentUuid": "5cff7927_880630b9",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20b13b85_7dcc3f91",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5634
      },
      "writtenOn": "2022-04-29T06:07:40Z",
      "side": 0,
      "message": "Being called out in an article like that is an indication that we\u0027re doing something wrong.\n\n\nGOT IT (I think):\n\nIf x, y, and z all have name \u0027a\u0027\nx and y have prefixlen 1 and 2 respectively\nz has prefixlen 2\ny and z have differing prefixes\n\nx will compare equal to y (compare name only)\nx will compare equal to z (compare name only)\ny will compare not equal to z (compare  prefix)\n\nthus violating rule 4 (x \u003d\u003d y \u0026\u0026 x \u003d\u003d z \u003d\u003e x \u003d\u003d z)\n\nThat took a while!\nI\u0027d like to see such an example embedded in a test.",
      "parentUuid": "ee85bf2c_f0009abe",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "68d87afe_0c2d9b00",
        "filename": "rtc_base/network.cc",
        "patchSetId": 1
      },
      "lineNbr": 69,
      "author": {
        "id": 5087
      },
      "writtenOn": "2022-04-29T13:31:30Z",
      "side": 0,
      "message": "Thanks. Done.",
      "parentUuid": "20b13b85_7dcc3f91",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 69,
        "endChar": 1
      },
      "revId": "63472e5aea72bec248d9b38a01813b1a67b70871",
      "serverId": "58829da1-049c-39fb-b951-ebdcd0984767"
    }
  ]
}